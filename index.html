<!doctype html><html itemscope itemtype=http://schema.org/WebPage lang=zh-cn><head><meta name=generator content="Hugo 0.110.0"><meta name=theme content="FixIt v0.2.18"><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=2"><meta name=robots content="noodp"><title>孔俊的知识库</title><meta name=author content><meta name=author-link content><meta name=description content><meta name=keywords content="Hugo,FixIt"><meta itemprop=name content="孔俊的知识库"><meta itemprop=description content><meta property="og:title" content="孔俊的知识库"><meta property="og:description" content><meta property="og:type" content="website"><meta property="og:url" content="/"><meta name=twitter:card content="summary"><meta name=twitter:title content="孔俊的知识库"><meta name=twitter:description content><meta name=application-name content="FixIt"><meta name=apple-mobile-web-app-title content="FixIt"><meta name=theme-color data-light=#f8f8f8 data-dark=#252627 content="#f8f8f8"><meta name=msapplication-TileColor content="#da532c"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=canonical href=/><link rel=alternate href=/index.xml type=application/rss+xml title=孔俊的知识库><link rel=feed href=/index.xml type=application/rss+xml title=孔俊的知识库><link rel=stylesheet href=/css/style.min.css><link rel=stylesheet href=/lib/fontawesome-free/all.min.css><link rel=stylesheet href=/lib/animate/animate.min.css><script type=application/ld+json>{"@context":"http://schema.org","@type":"WebSite","url":"\/","inLanguage":"zh-CN","name":"孔俊的知识库"}</script></head><body data-header-desktop=sticky data-header-mobile=auto><script>(window.localStorage?.getItem("theme")?localStorage.getItem("theme")==="dark":"auto"==="auto"?window.matchMedia("(prefers-color-scheme: dark)").matches:"auto"==="dark")&&document.body.setAttribute("data-theme","dark")</script><div class=wrapper data-page-style=normal><header class="desktop animate__faster" id=header-desktop><div class=header-wrapper data-github-corner=left><div class=header-title><a href=/ title=孔俊的知识库><img loading=lazy src=/logo.svg srcset="/logo.svg, /logo.svg 1.5x, /logo.svg 2x" sizes=auto data-title=孔俊的知识库 data-alt=孔俊的知识库 class=logo style="background:url(/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'><span class=header-title-text>孔俊的知识库</span></a><span class=header-subtitle></span></div><nav><ul class=menu><li class=menu-item><a class=menu-link href=/posts/>文章</a></li><li class=menu-item><a class=menu-link href=/categories/>分类</a></li><li class=menu-item><a class=menu-link href=/tags/>标签</a></li><li class=menu-item><a class=menu-link href=/archives/>归档</a></li><li class=menu-item><a class=menu-link href=/about/>关于我</a></li><li class="menu-item delimiter"></li><li class="menu-item theme-switch" title=切换主题><i class="fa-solid fa-adjust fa-fw" aria-hidden=true></i></li></ul></nav></div></header><header class="mobile animate__faster" id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title=孔俊的知识库><img loading=lazy src=/logo.svg srcset="/logo.svg, /logo.svg 1.5x, /logo.svg 2x" sizes=auto data-title=/logo.svg data-alt=/logo.svg class=logo style="background:url(/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'><span class=header-title-text>孔俊的知识库</span></a><span class=header-subtitle></span></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><nav><ul class=menu id=menu-mobile><li class=menu-item><a class=menu-link href=/posts/>文章</a></li><li class=menu-item><a class=menu-link href=/categories/>分类</a></li><li class=menu-item><a class=menu-link href=/tags/>标签</a></li><li class=menu-item><a class=menu-link href=/archives/>归档</a></li><li class=menu-item><a class=menu-link href=/about/>关于我</a></li><li class="menu-item menu-system"><span class="menu-system-item theme-switch" title=切换主题><i class="fa-solid fa-adjust fa-fw" aria-hidden=true></i></span></li></ul></nav></div></header><main class=container><div class="page home posts"><article class="single summary" itemscope itemtype=http://schema.org/Article><div class=featured-image-preview><a href=/posts/2022/12/12/ aria-label="致敬经典：K&R allocator 内存分配器"><img loading=lazy src=/posts/2022/12/12/images/featured-image.png srcset="/posts/2022/12/12/images/featured-image.png, /posts/2022/12/12/images/featured-image.png 1.5x, /posts/2022/12/12/images/featured-image.png 2x" sizes=auto data-title=/posts/2022/12/12/images/featured-image.png data-alt=/posts/2022/12/12/images/featured-image.png style="background:url(/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'></a></div><h1 class=single-title itemprop="name headline"><span title=转载 class=icon-repost><i class="fa-solid fa-share fa-fw" aria-hidden=true></i></span><a href=/posts/2022/12/12/>致敬经典：K&R allocator 内存分配器</a></h1><div class=post-meta><span class=post-author><span class=author><i class="fa-solid fa-user-circle" aria-hidden=true></i>
孔俊</span></span>&nbsp;<span class=post-publish title='2022-12-12 21:01:48'>发布于 <time datetime=2022-12-12>2022-12-12</time></span>&nbsp;<span class=post-category>收录于 <a href=/categories/allocator/><i class="fa-regular fa-folder fa-fw" aria-hidden=true></i> Allocator</a></span></div><div class=content>k&R allocator 是Brain Kernighan和 Dennis Ritchie 的名著 The C Programming Language 第 8.7 节中介绍的一个简单 malloc 实现。因为该书被称为 K&R C，这个 malloc 实现也被称为 K&C allocator。 K&R allocator 的实现非常简洁，Linux 内核基于 K&R allocator 实现了用于嵌入式系统 slob allocator。见 slob: introduce the SLOB allocator，邮件摘要如下： SLOB is a traditional K&R/UNIX allocator with a SLAB emulation layer, similar to the original Linux kmalloc allocator that SLAB replaced. It's signicantly smaller code and is more memory efficient. But like all similar allocators, it scales poorly and suffers from fragmentation more than</div><div class=post-footer><a href=/posts/2022/12/12/>阅读全文</a><div class=post-tags><i class="fa-solid fa-tags fa-fw me-1" aria-hidden=true></i><a href=/tags/allocator/ class=post-tag>Allocator</a><a href=/tags/c/ class=post-tag>C</a></div></div></article><article class="single summary" itemscope itemtype=http://schema.org/Article><div class=featured-image-preview><a href=/posts/2022/11/21/ aria-label="深入剖析 Go 语言运行时：IO 轮询器"><img loading=lazy src=/posts/2022/11/21/images/featured-image.png srcset="/posts/2022/11/21/images/featured-image.png, /posts/2022/11/21/images/featured-image.png 1.5x, /posts/2022/11/21/images/featured-image.png 2x" sizes=auto data-title=/posts/2022/11/21/images/featured-image.png data-alt=/posts/2022/11/21/images/featured-image.png style="background:url(/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'></a></div><h1 class=single-title itemprop="name headline"><span title=转载 class=icon-repost><i class="fa-solid fa-share fa-fw" aria-hidden=true></i></span><a href=/posts/2022/11/21/>深入剖析 Go 语言运行时：IO 轮询器</a></h1><div class=post-meta><span class=post-author><span class=author><i class="fa-solid fa-user-circle" aria-hidden=true></i>
孔俊</span></span>&nbsp;<span class=post-publish title='2022-11-21 17:42:25'>发布于 <time datetime=2022-11-21>2022-11-21</time></span>&nbsp;<span class=post-category>收录于 <a href=/categories/go/><i class="fa-regular fa-folder fa-fw" aria-hidden=true></i> Go</a></span></div><div class=content>netpoller 概述 考虑一个基于 goroutine-per-connection 模型的 TCP echo server： import ( "fmt" "io" "log" "net" ) func worker(conn net.Conn) { defer conn.Close() b := make([]byte, 512) for { size, err := conn.Read(b) if err == io.EOF { break } if err != nil { log.Fatal(err) } size, err = conn.Write(b[0:size]) if err != nil { log.Fatal(err) } } } func main() { listner, err := net.Listen("tcp", "127.0.0.1:8080") if err != nil { log.Fatal(err) } for { conn, err := listner.Accept() if err != nil { log.Fatal(err) } go worker(conn) } } 从用户侧看，系统该调用阻塞 goroutine，Go scheduler 调度其他 goroutine。问题在于，goroutine 复用在线程上，如果 IO 系统调用（如read(2</div><div class=post-footer><a href=/posts/2022/11/21/>阅读全文</a><div class=post-tags><i class="fa-solid fa-tags fa-fw me-1" aria-hidden=true></i><a href=/tags/go/ class=post-tag>Go</a><a href=/tags/network/ class=post-tag>Network</a><a href=/tags/unix/ class=post-tag>UNIX</a></div></div></article><article class="single summary" itemscope itemtype=http://schema.org/Article><div class=featured-image-preview><a href=/posts/2022/11/03/ aria-label=【译】内存屏障：软件黑客的硬件视角><img loading=lazy src=/posts/2022/11/03/images/featured-image.png srcset="/posts/2022/11/03/images/featured-image.png, /posts/2022/11/03/images/featured-image.png 1.5x, /posts/2022/11/03/images/featured-image.png 2x" sizes=auto data-title=/posts/2022/11/03/images/featured-image.png data-alt=/posts/2022/11/03/images/featured-image.png style="background:url(/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'></a></div><h1 class=single-title itemprop="name headline"><span title=转载 class=icon-repost><i class="fa-solid fa-share fa-fw" aria-hidden=true></i></span><a href=/posts/2022/11/03/>【译】内存屏障：软件黑客的硬件视角</a></h1><div class=post-meta><span class=post-author><span class=author><i class="fa-solid fa-user-circle" aria-hidden=true></i>
孔俊</span></span>&nbsp;<span class=post-publish title='2022-11-03 11:00:56'>发布于 <time datetime=2022-11-03>2022-11-03</time></span>&nbsp;<span class=post-category>收录于 <a href=/categories/concurrency/><i class="fa-regular fa-folder fa-fw" aria-hidden=true></i> Concurrency</a></span></div><div class=content>译者序 Memory Barriers: a Hardware View for Software Hackers 是并发编程专家 Paul E. McKenney 的经典论文，该论文同时收录在他的著作 Is Parallel Programming Hard, And, If So, What Can You Do About It? 附录 C Why Memory Barriers? 中。 本文全文翻译该论文。 为什么中了邪的 CPU 设计者要让可怜的一无所知的软件设计者受内存屏障（memory barrier）的伤害？ 简单地说，因为乱序内存引用可以带来更好的性能，所以需要用内存屏障在同步原语这类其正确操作依赖于排序的内存引用的东西中强制</div><div class=post-footer><a href=/posts/2022/11/03/>阅读全文</a><div class=post-tags><i class="fa-solid fa-tags fa-fw me-1" aria-hidden=true></i><a href=/tags/memory-model/ class=post-tag>Memory Model</a><a href=/tags/computer-architecture/ class=post-tag>Computer Architecture</a><a href=/tags/concurrency/ class=post-tag>Concurrency</a></div></div></article><article class="single summary" itemscope itemtype=http://schema.org/Article><div class=featured-image-preview><a href=/posts/2022/10/25/ aria-label="【译】Go 语言数据竞争检测器"><img loading=lazy src=/posts/2022/10/25/images/featured-image.gif srcset="/posts/2022/10/25/images/featured-image.gif, /posts/2022/10/25/images/featured-image.gif 1.5x, /posts/2022/10/25/images/featured-image.gif 2x" sizes=auto data-title=/posts/2022/10/25/images/featured-image.gif data-alt=/posts/2022/10/25/images/featured-image.gif style="background:url(/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'></a></div><h1 class=single-title itemprop="name headline"><span title=转载 class=icon-repost><i class="fa-solid fa-share fa-fw" aria-hidden=true></i></span><a href=/posts/2022/10/25/>【译】Go 语言数据竞争检测器</a></h1><div class=post-meta><span class=post-author><span class=author><i class="fa-solid fa-user-circle" aria-hidden=true></i>
孔俊</span></span>&nbsp;<span class=post-publish title='2022-10-25 09:43:35'>发布于 <time datetime=2022-10-25>2022-10-25</time></span>&nbsp;<span class=post-category>收录于 <a href=/categories/go/><i class="fa-regular fa-folder fa-fw" aria-hidden=true></i> Go</a></span></div><div class=content>简介 数据竞争是并发程序中最普遍和最难调试的 bug。当两个 goroutine 并发访问同一变量且至少一个访问是写时发生数据竞争。更多细节参考 The Go Memory Model。 译者注 The Go Memory Model 可以参考我的博客 【译】Go 语言内存模型：2022-06-06 版。 这有一个可以导致程序崩溃（crashes）和内存损坏（memory corruption）的数据竞争的例子： xian sxian sfunc main() { c := make(chan bool) m := make(map[string]string) go func() { m["1"] = "a" //</div><div class=post-footer><a href=/posts/2022/10/25/>阅读全文</a><div class=post-tags><i class="fa-solid fa-tags fa-fw me-1" aria-hidden=true></i><a href=/tags/go/ class=post-tag>Go</a><a href=/tags/concurrency/ class=post-tag>Concurrency</a></div></div></article><article class="single summary" itemscope itemtype=http://schema.org/Article><div class=featured-image-preview><a href=/posts/2022/10/20/ aria-label="【译】Go 语言内存模型：2022-06-06 版"><img loading=lazy src=/posts/2022/10/20/images/featured-image.png srcset="/posts/2022/10/20/images/featured-image.png, /posts/2022/10/20/images/featured-image.png 1.5x, /posts/2022/10/20/images/featured-image.png 2x" sizes=auto data-title=/posts/2022/10/20/images/featured-image.png data-alt=/posts/2022/10/20/images/featured-image.png style="background:url(/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'></a></div><h1 class=single-title itemprop="name headline"><span title=转载 class=icon-repost><i class="fa-solid fa-share fa-fw" aria-hidden=true></i></span><a href=/posts/2022/10/20/>【译】Go 语言内存模型：2022-06-06 版</a></h1><div class=post-meta><span class=post-author><span class=author><i class="fa-solid fa-user-circle" aria-hidden=true></i>
孔俊</span></span>&nbsp;<span class=post-publish title='2022-10-20 11:46:49'>发布于 <time datetime=2022-10-20>2022-10-20</time></span>&nbsp;<span class=post-category>收录于 <a href=/categories/go/><i class="fa-regular fa-folder fa-fw" aria-hidden=true></i> Go</a></span></div><div class=content>译者序 原文 The Go Memory Model 描述 Go 语言内存模型，这里的内存模型实际上是“内存一致性模型”（memory consistency model）。笔者修改了格式错误并翻译全文。 The Go Memory Model 在内存一致性模型层面，描述 Go 语言实现（Go implementation）提供的一致性保证，并进一步指出该保证对 Go 语言实现的限制；在工程实践层面，描述使用同步原语确保 goroutine 间可见性的方法，并进一步指出常见的错误同步手法。</div><div class=post-footer><a href=/posts/2022/10/20/>阅读全文</a><div class=post-tags><i class="fa-solid fa-tags fa-fw me-1" aria-hidden=true></i><a href=/tags/go/ class=post-tag>Go</a><a href=/tags/memory-model/ class=post-tag>Memory Model</a><a href=/tags/concurrency/ class=post-tag>Concurrency</a></div></div></article><article class="single summary" itemscope itemtype=http://schema.org/Article><div class=featured-image-preview><a href=/posts/2022/10/13/ aria-label=【译】一种面向多核架构的无锁、缓存高效的共享环形缓冲区><img loading=lazy src=/posts/2022/10/13/images/featured-image.webp srcset="/posts/2022/10/13/images/featured-image.webp, /posts/2022/10/13/images/featured-image.webp 1.5x, /posts/2022/10/13/images/featured-image.webp 2x" sizes=auto data-title=/posts/2022/10/13/images/featured-image.webp data-alt=/posts/2022/10/13/images/featured-image.webp style="background:url(/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'></a></div><h1 class=single-title itemprop="name headline"><span title=转载 class=icon-repost><i class="fa-solid fa-share fa-fw" aria-hidden=true></i></span><a href=/posts/2022/10/13/>【译】一种面向多核架构的无锁、缓存高效的共享环形缓冲区</a></h1><div class=post-meta><span class=post-author><span class=author><i class="fa-solid fa-user-circle" aria-hidden=true></i>
孔俊</span></span>&nbsp;<span class=post-publish title='2022-10-13 22:26:21'>发布于 <time datetime=2022-10-13>2022-10-13</time></span>&nbsp;<span class=post-category>收录于 <a href=/categories/concurrency/><i class="fa-regular fa-folder fa-fw" aria-hidden=true></i> Concurrency</a></span></div><div class=content>译者序 论文 A Lock-Free, Cache-Efficient Shared Ring Buffer for Multi-Core Architectures 介绍了一种专为多核架构设计、用于单生产者/单消费者模型的环形缓冲区，称为 MCRingBuffer。论文性能测试表明，其吞吐量数倍于 Lamport 提出的 BasicRingBuffer。 MCRingBuffer 将环形缓存区划分为多个块，块划分为多个槽。 论文基于基础的环形缓冲区，从以下两方面着手提高性能： 降低读共享控制变量的频率：维护私有变量，仅在缓冲区可能满/空时读取</div><div class=post-footer><a href=/posts/2022/10/13/>阅读全文</a><div class=post-tags><i class="fa-solid fa-tags fa-fw me-1" aria-hidden=true></i><a href=/tags/concurrency/ class=post-tag>Concurrency</a><a href=/tags/data-structure/ class=post-tag>Data Structure</a></div></div></article><ul class=pagination><li class="page-item active"><span class=page-link><a href=/>1</a></span></li><li class=page-item><span class=page-link><a href=/page/2/>2</a></span></li><li class=page-item><span class=page-link><a href=/page/3/>3</a></span></li></ul></div></main><footer class=footer><div class=footer-container><div class="footer-line powered">由 <a href=https://gohugo.io/ target=_blank rel="external nofollow noopener noreferrer" title="Hugo 0.110.0">Hugo</a> 强力驱动 | 主题 - <a href=https://github.com/hugo-fixit/FixIt target=_blank rel=external title="FixIt v0.2.18"><img class=fixit-icon src=/fixit.min.svg alt="FixIt logo">&nbsp;FixIt</a></div><div class="footer-line copyright" itemscope itemtype=http://schema.org/CreativeWork><i class="fa-regular fa-copyright fa-fw" aria-hidden=true></i>
<span itemprop=copyrightYear>2022 - 2023</span><span class=author itemprop=copyrightHolder>
<a href=/></a></span><span class="license footer-divider"><a rel="license external nofollow noopener noreferrer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span></div><div class="footer-line statistics"></div></div></footer></div><div class=widgets><div class="fixed-buttons animate__faster d-none"><div class="fixed-button back-to-top" role=button aria-label=回到顶部><i class="fa-solid fa-arrow-up fa-fw" aria-hidden=true></i><span class="variant-numeric d-none">0%</span></div><div class="fixed-button view-comments d-none" role=button aria-label=查看评论><i class="fa-solid fa-comment fa-fw" aria-hidden=true></i></div></div><a href=https://github.com/kongjun18/blog title=查看博客源代码 target=_blank rel="external nofollow" class="github-corner left d-none-mobile"><svg viewBox="0 0 250 250" aria-hidden="true"><path d="M0 0 115 115h15l12 27L250 250V0z"/><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentcolor" style="transform-origin:130px 106px" class="octo-arm"/><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4l13.9-13.8C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8z" fill="currentcolor" class="octo-body"/></svg></a><div id=mask></div><noscript><div class=noscript-warning>FixIt 主题在启用 JavaScript 的情况下效果最佳。</div></noscript></div><link rel=stylesheet href=/lib/katex/katex.min.css><link rel=stylesheet href=/lib/cookieconsent/cookieconsent.min.css><script src=/lib/sharer/sharer.min.js async defer></script><script src=/lib/katex/katex.min.js defer></script><script src=/lib/katex/auto-render.min.js defer></script><script src=/lib/katex/copy-tex.min.js defer></script><script src=/lib/katex/mhchem.min.js defer></script><script src=/lib/cookieconsent/cookieconsent.min.js defer></script><script src=/lib/pangu/pangu.min.js defer></script><script>window.config={code:{copyTitle:"复制到剪贴板",editLockTitle:"锁定可编辑代码块",editUnLockTitle:"解锁可编辑代码块",editable:!0,maxShownLines:40},cookieconsent:{content:{dismiss:"同意",link:"了解更多",message:"本网站使用 Cookies 来改善您的浏览体验。"},enable:!0,palette:{button:{background:"#f0f0f0"},popup:{background:"#1aa3ff"}},theme:"edgeless"},math:{delimiters:[{display:!0,left:"$$",right:"$$"},{display:!0,left:"\\[",right:"\\]"},{display:!0,left:"\\begin{equation}",right:"\\end{equation}"},{display:!0,left:"\\begin{equation*}",right:"\\end{equation*}"},{display:!0,left:"\\begin{align}",right:"\\end{align}"},{display:!0,left:"\\begin{align*}",right:"\\end{align*}"},{display:!0,left:"\\begin{alignat}",right:"\\end{alignat}"},{display:!0,left:"\\begin{alignat*}",right:"\\end{alignat*}"},{display:!0,left:"\\begin{gather}",right:"\\end{gather}"},{display:!0,left:"\\begin{CD}",right:"\\end{CD}"},{display:!1,left:"$",right:"$"},{display:!1,left:"\\(",right:"\\)"}],strict:!1},pangu:{enable:!0,selector:"article"}}</script><script src=/js/theme.min.js defer></script></body></html>