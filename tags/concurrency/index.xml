<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>Concurrency - 标签 - 孔俊的知识库</title><link>/tags/concurrency/</link><description>Concurrency - 标签 - 孔俊的知识库</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Thu, 03 Nov 2022 11:00:56 +0800</lastBuildDate><atom:link href="/tags/concurrency/" rel="self" type="application/rss+xml"/><item><title>【译】内存屏障：软件黑客的硬件视角</title><link>/posts/2022/11/03/</link><pubDate>Thu, 03 Nov 2022 11:00:56 +0800</pubDate><author>作者</author><guid>/posts/2022/11/03/</guid><description>译者序 Memory Barriers: a Hardware View for Software Hackers 是并发编程专家 Paul E. McKenney 的经典论文，该论文同时收录在他的著作 Is Parallel Programming Hard, And, If So, What Can You Do About It? 附录 C Why Memory Barriers? 中。 本文全文翻译该论文。 为什么中了邪的 CPU 设计者要让可怜的一无所知的软件设计者受内存屏障（memory barrier）的伤害？ 简单地说，因为乱序内存引用可以带来更好的性能，所以需要用内存屏障在同步原语这类其正确操作依赖于排序的内存引用的东西中强制</description></item><item><title>【译】Go 语言数据竞争检测器</title><link>/posts/2022/10/25/</link><pubDate>Tue, 25 Oct 2022 09:43:35 +0800</pubDate><author>作者</author><guid>/posts/2022/10/25/</guid><description><![CDATA[简介 数据竞争是并发程序中最普遍和最难调试的 bug。当两个 goroutine 并发访问同一变量且至少一个访问是写时发生数据竞争。更多细节参考 The Go Memory Model。 译者注 The Go Memory Model 可以参考我的博客 【译】Go 语言内存模型：2022-06-06 版。 这有一个可以导致程序崩溃（crashes）和内存损坏（memory corruption）的数据竞争的例子： xian sxian sfunc main() { c := make(chan bool) m := make(map[string]string) go func() { m[&#34;1&#34;] = &#34;a&#34; //]]></description></item><item><title>【译】Go 语言内存模型：2022-06-06 版</title><link>/posts/2022/10/20/</link><pubDate>Thu, 20 Oct 2022 11:46:49 +0800</pubDate><author>作者</author><guid>/posts/2022/10/20/</guid><description>译者序 原文 The Go Memory Model 描述 Go 语言内存模型，这里的内存模型实际上是“内存一致性模型”（memory consistency model）。笔者修改了格式错误并翻译全文。 The Go Memory Model 在内存一致性模型层面，描述 Go 语言实现（Go implementation）提供的一致性保证，并进一步指出该保证对 Go 语言实现的限制；在工程实践层面，描述使用同步原语确保 goroutine 间可见性的方法，并进一步指出常见的错误同步手法。</description></item><item><title>【译】一种面向多核架构的无锁、缓存高效的共享环形缓冲区</title><link>/posts/2022/10/13/</link><pubDate>Thu, 13 Oct 2022 22:26:21 +0800</pubDate><author>作者</author><guid>/posts/2022/10/13/</guid><description>译者序 论文 A Lock-Free, Cache-Efficient Shared Ring Buffer for Multi-Core Architectures 介绍了一种专为多核架构设计、用于单生产者/单消费者模型的环形缓冲区，称为 MCRingBuffer。论文性能测试表明，其吞吐量数倍于 Lamport 提出的 BasicRingBuffer。 MCRingBuffer 将环形缓存区划分为多个块，块划分为多个槽。 论文基于基础的环形缓冲区，从以下两方面着手提高性能： 降低读共享控制变量的频率：维护私有变量，仅在缓冲区可能满/空时读取</description></item><item><title>【译】 如何设计正确运行多进程程序的多核计算机</title><link>/posts/2022/10/09/</link><pubDate>Sun, 09 Oct 2022 15:24:14 +0800</pubDate><author>作者</author><guid>/posts/2022/10/09/</guid><description>TL;DR SC(Sequential Consistency)：任何执行的结果看起来就像所有处理器都顺序执行，并且单个处理器按照程序指定次序执行。 每个处理器都是顺序的，不意味着整个多核系统是顺序一致的。 SC 是一个定义在内存访问上的偏序。 为了实现 SC，处理器需要满足两个条件： 处理器按照程序次序发起请求。发起请求包括进入内存模块的队列。 内存模块按照 FIFO 次序响应请求。 SC 虽然符合人类直觉，但限制了处理器</description></item></channel></rss>