<!doctype html><html itemscope itemtype=http://schema.org/WebPage lang=zh-cn><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=2"><meta name=robots content="noodp"><title>【译】Go 语言数据竞争检测器 - 孔俊的知识库</title><meta name=author content><meta name=author-link content><meta name=description content="简介 数据竞争是并发程序中最普遍和最难调试的 bug。当两个 goroutine 并发访问同一变量且至少一个访问是写时发生数据竞争。更多细节参考 The Go Memory Model。 译者注 The Go Memory Model 可以参考我的博客 【译】Go 语言内存模型：2022-06-06 版。 这有一个可以导致程序崩溃（crashes）和内存损坏（memory corruption）的数据竞争的例子： xian sxian sfunc main() { c := make(chan bool) m := make(map[string]string) go func() { m[&#34;1&#34;] = &#34;a&#34; //"><meta name=keywords content="Concurrency,Go,Data Race"><meta itemprop=name content="【译】Go 语言数据竞争检测器"><meta itemprop=description content="简介 数据竞争是并发程序中最普遍和最难调试的 bug。当两个 goroutine 并发访问同一变量且至少一个访问是写时发生数据竞争。更多细节参考 The Go Memory Model。 译者注 The Go Memory Model 可以参考我的博客 【译】Go 语言内存模型：2022-06-06 版。 这有一个可以导致程序崩溃（crashes）和内存损坏（memory corruption）的数据竞争的例子： xian sxian sfunc main() { c := make(chan bool) m := make(map[string]string) go func() { m[&#34;1&#34;] = &#34;a&#34; //"><meta itemprop=datePublished content="2022-10-25T09:43:35+08:00"><meta itemprop=dateModified content="2022-10-25T09:43:35+08:00"><meta itemprop=wordCount content="2453"><meta itemprop=image content="/posts/2022/10/25/images/featured-image.gif"><meta itemprop=keywords content="Go,Concurrency,"><meta property="og:title" content="【译】Go 语言数据竞争检测器"><meta property="og:description" content="简介 数据竞争是并发程序中最普遍和最难调试的 bug。当两个 goroutine 并发访问同一变量且至少一个访问是写时发生数据竞争。更多细节参考 The Go Memory Model。 译者注 The Go Memory Model 可以参考我的博客 【译】Go 语言内存模型：2022-06-06 版。 这有一个可以导致程序崩溃（crashes）和内存损坏（memory corruption）的数据竞争的例子： xian sxian sfunc main() { c := make(chan bool) m := make(map[string]string) go func() { m[&#34;1&#34;] = &#34;a&#34; //"><meta property="og:type" content="article"><meta property="og:url" content="/posts/2022/10/25/"><meta property="og:image" content="/posts/2022/10/25/images/featured-image.gif"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-10-25T09:43:35+08:00"><meta property="article:modified_time" content="2022-10-25T09:43:35+08:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="/posts/2022/10/25/images/featured-image.gif"><meta name=twitter:title content="【译】Go 语言数据竞争检测器"><meta name=twitter:description content="简介 数据竞争是并发程序中最普遍和最难调试的 bug。当两个 goroutine 并发访问同一变量且至少一个访问是写时发生数据竞争。更多细节参考 The Go Memory Model。 译者注 The Go Memory Model 可以参考我的博客 【译】Go 语言内存模型：2022-06-06 版。 这有一个可以导致程序崩溃（crashes）和内存损坏（memory corruption）的数据竞争的例子： xian sxian sfunc main() { c := make(chan bool) m := make(map[string]string) go func() { m[&#34;1&#34;] = &#34;a&#34; //"><meta name=application-name content="FixIt"><meta name=apple-mobile-web-app-title content="FixIt"><meta name=theme-color data-light=#f8f8f8 data-dark=#252627 content="#f8f8f8"><meta name=msapplication-TileColor content="#da532c"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=canonical href=/posts/2022/10/25/><link rel=prev href=/posts/2022/10/20/><link rel=next href=/posts/2022/11/03/><link rel=stylesheet href=/css/style.min.css><link rel=stylesheet href=/lib/fontawesome-free/all.min.css><link rel=stylesheet href=/lib/animate/animate.min.css><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"【译】Go 语言数据竞争检测器","inLanguage":"zh-CN","mainEntityOfPage":{"@type":"WebPage","@id":"\/posts\/2022\/10\/25\/"},"image":[{"@type":"ImageObject","url":"\/posts\/2022\/10\/25\/images\/featured-image.gif","width":566,"height":127}],"genre":"posts","keywords":"Go, Concurrency","wordcount":2453,"url":"\/posts\/2022\/10\/25\/","datePublished":"2022-10-25T09:43:35+08:00","dateModified":"2022-10-25T09:43:35+08:00","publisher":{"@type":"Organization","name":""},"author":{"@type":"Person","name":"孔俊"},"description":""}</script></head><body data-header-desktop=sticky data-header-mobile=auto><script>(window.localStorage?.getItem("theme")?localStorage.getItem("theme")==="dark":"auto"==="auto"?window.matchMedia("(prefers-color-scheme: dark)").matches:"auto"==="dark")&&document.body.setAttribute("data-theme","dark")</script><div class=wrapper data-page-style=normal><header class="desktop animate__faster" id=header-desktop><div class=header-wrapper data-github-corner=left><div class=header-title><a href=/ title=孔俊的知识库><img loading=lazy src=/logo.svg srcset="/logo.svg, /logo.svg 1.5x, /logo.svg 2x" sizes=auto data-title=孔俊的知识库 data-alt=孔俊的知识库 class=logo style="background:url(/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'><span class=header-title-text>孔俊的知识库</span></a><span class=header-subtitle></span></div><nav><ul class=menu><li class=menu-item><a class=menu-link href=/posts/>文章</a></li><li class=menu-item><a class=menu-link href=/categories/>分类</a></li><li class=menu-item><a class=menu-link href=/tags/>标签</a></li><li class=menu-item><a class=menu-link href=/archives/>归档</a></li><li class=menu-item><a class=menu-link href=/about/>关于我</a></li><li class="menu-item delimiter"></li><li class="menu-item theme-switch" title=切换主题><i class="fa-solid fa-adjust fa-fw" aria-hidden=true></i></li></ul></nav></div></header><header class="mobile animate__faster" id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title=孔俊的知识库><img loading=lazy src=/logo.svg srcset="/logo.svg, /logo.svg 1.5x, /logo.svg 2x" sizes=auto data-title=/logo.svg data-alt=/logo.svg class=logo style="background:url(/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'><span class=header-title-text>孔俊的知识库</span></a><span class=header-subtitle></span></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><nav><ul class=menu id=menu-mobile><li class=menu-item><a class=menu-link href=/posts/>文章</a></li><li class=menu-item><a class=menu-link href=/categories/>分类</a></li><li class=menu-item><a class=menu-link href=/tags/>标签</a></li><li class=menu-item><a class=menu-link href=/archives/>归档</a></li><li class=menu-item><a class=menu-link href=/about/>关于我</a></li><li class="menu-item menu-system"><span class="menu-system-item theme-switch" title=切换主题><i class="fa-solid fa-adjust fa-fw" aria-hidden=true></i></span></li></ul></nav></div></header><main class=container><aside class=toc id=toc-auto><h2 class=toc-title>目录&nbsp;<i class="toc-icon fa-solid fa-angle-down fa-fw" aria-hidden=true></i></h2><div class=toc-content id=toc-content-auto></div></aside><aside class=aside-custom></aside><article class="page single"><div class=header><h1 class="single-title animate__animated animate__flipInX"><span title=转载 class=icon-repost><i class="fa-solid fa-share fa-fw" aria-hidden=true></i></span><span>【译】Go 语言数据竞争检测器</span></h1><p class="single-subtitle animate__animated animate__fadeIn">Data Race Detector</p></div><div class=post-meta><div class=post-meta-line><span class=post-author><span class=author><i class="fa-solid fa-user-circle" aria-hidden=true></i>
孔俊</span></span>
<span class=post-category>收录于 <a href=/categories/go/><i class="fa-regular fa-folder fa-fw" aria-hidden=true></i> Go</a></span></div><div class=post-meta-line><span title="发布于 2022-10-25 09:43:35"><i class="fa-regular fa-calendar-alt fa-fw me-1" aria-hidden=true></i><time datetime=2022-10-25>2022-10-25</time></span>&nbsp;<span title="更新于 2022-10-25 09:43:35"><i class="fa-regular fa-edit fa-fw me-1" aria-hidden=true></i><time datetime=2022-10-25>2022-10-25</time></span>&nbsp;<span><i class="fa-solid fa-pencil-alt fa-fw me-1" aria-hidden=true></i>约 2453 字</span>&nbsp;<span><i class="fa-regular fa-clock fa-fw me-1" aria-hidden=true></i>预计阅读 5 分钟</span>&nbsp;</div></div><div class=featured-image><img loading=lazy src=/posts/2022/10/25/images/featured-image.gif srcset="/posts/2022/10/25/images/featured-image.gif, /posts/2022/10/25/images/featured-image.gif 1.5x, /posts/2022/10/25/images/featured-image.gif 2x" sizes=auto data-title=/posts/2022/10/25/images/featured-image.gif data-alt=/posts/2022/10/25/images/featured-image.gif style="background:url(/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'></div><div class="details toc" id=toc-static data-kept=false><div class="details-summary toc-title"><span>目录</span>
<span><i class="details-icon fa-solid fa-angle-right" aria-hidden=true></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><a href=#简介>简介</a></li><li><a href=#使用>使用</a></li><li><a href=#报告格式>报告格式</a></li><li><a href=#选项>选项</a></li><li><a href=#排除测试>排除测试</a></li><li><a href=#怎样使用>怎样使用</a></li><li><a href=#典型的数据竞争>典型的数据竞争</a><ul><li><a href=#循环计数器上的竞争>循环计数器上的竞争</a></li><li><a href=#意外的共享变量>意外的共享变量</a></li><li><a href=#不受保护的全局变量>不受保护的全局变量</a></li><li><a href=#不受保护的原始类型变量>不受保护的原始类型变量。</a></li><li><a href=#未同步的发送和关闭操作>未同步的发送和关闭操作</a></li></ul></li><li><a href=#要求>要求</a></li><li><a href=#运行时开销>运行时开销</a></li></ul></nav></div></div><div class=content id=content><h2 id=简介>简介</h2><p>数据竞争是并发程序中最普遍和最难调试的 bug。当两个 goroutine 并发访问同一变量且至少一个访问是写时发生数据竞争。更多细节参考 <a href=https://go.dev/ref/mem/ target=_blank rel="external nofollow noopener noreferrer">The Go Memory Model<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a>。</p><blockquote><p><strong>译者注</strong></p><p><a href=https://go.dev/ref/mem/ target=_blank rel="external nofollow noopener noreferrer">The Go Memory Model<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a> 可以参考我的博客 <a href=https://www.kongjun18.me/posts/the-go-memory-model/ target=_blank rel="external nofollow noopener noreferrer">【译】Go 语言内存模型：2022-06-06 版<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a>。</p></blockquote><p>这有一个可以导致程序崩溃（crashes）和内存损坏（memory corruption）的数据竞争的例子：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>xian</span> <span class=nx>sxian</span> <span class=nx>sfunc</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>c</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kt>bool</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>m</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=kt>string</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>go</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>m</span><span class=p>[</span><span class=s>&#34;1&#34;</span><span class=p>]</span> <span class=p>=</span> <span class=s>&#34;a&#34;</span> <span class=c1>// First conflicting access.
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nx>c</span> <span class=o>&lt;-</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl>    <span class=p>}()</span>
</span></span><span class=line><span class=cl>    <span class=nx>m</span><span class=p>[</span><span class=s>&#34;2&#34;</span><span class=p>]</span> <span class=p>=</span> <span class=s>&#34;b&#34;</span> <span class=c1>// Second conflicting access.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=o>&lt;-</span><span class=nx>c</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>k</span><span class=p>,</span> <span class=nx>v</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>m</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>k</span><span class=p>,</span> <span class=nx>v</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=使用>使用</h2><p>为了帮助调试这些 bug，Go 内置了数据竞争检测器（data race detector）。给 go 命令加<code>-race</code>标志来使用它：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ go <span class=nb>test</span> -race mypkg    // to <span class=nb>test</span> the package
</span></span><span class=line><span class=cl>$ go run -race mysrc.go  // to run the <span class=nb>source</span> file
</span></span><span class=line><span class=cl>$ go build -race mycmd   // to build the <span class=nb>command</span>
</span></span><span class=line><span class=cl>$ go install -race mypkg // to install the package
</span></span></code></pre></div><h2 id=报告格式>报告格式</h2><p>当数据竞争检测器发现程序中的数据竞争时，它会打印一份报告。报告包含冲突访问（conflicting accesses）的 goroutine 和创建它的 goroutine 的堆栈跟踪（stack traces）。这是一个例子：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>WARNING: DATA RACE
</span></span><span class=line><span class=cl>Read by goroutine 185:
</span></span><span class=line><span class=cl>  net.<span class=o>(</span>*pollServer<span class=o>)</span>.AddFD<span class=o>()</span>
</span></span><span class=line><span class=cl>      src/net/fd_unix.go:89 +0x398
</span></span><span class=line><span class=cl>  net.<span class=o>(</span>*pollServer<span class=o>)</span>.WaitWrite<span class=o>()</span>
</span></span><span class=line><span class=cl>      src/net/fd_unix.go:247 +0x45
</span></span><span class=line><span class=cl>  net.<span class=o>(</span>*netFD<span class=o>)</span>.Write<span class=o>()</span>
</span></span><span class=line><span class=cl>      src/net/fd_unix.go:540 +0x4d4
</span></span><span class=line><span class=cl>  net.<span class=o>(</span>*conn<span class=o>)</span>.Write<span class=o>()</span>
</span></span><span class=line><span class=cl>      src/net/net.go:129 +0x101
</span></span><span class=line><span class=cl>  net.func·060<span class=o>()</span>
</span></span><span class=line><span class=cl>      src/net/timeout_test.go:603 +0xaf
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Previous write by goroutine 184:
</span></span><span class=line><span class=cl>  net.setWriteDeadline<span class=o>()</span>
</span></span><span class=line><span class=cl>      src/net/sockopt_posix.go:135 +0xdf
</span></span><span class=line><span class=cl>  net.setDeadline<span class=o>()</span>
</span></span><span class=line><span class=cl>      src/net/sockopt_posix.go:144 +0x9c
</span></span><span class=line><span class=cl>  net.<span class=o>(</span>*conn<span class=o>)</span>.SetDeadline<span class=o>()</span>
</span></span><span class=line><span class=cl>      src/net/net.go:161 +0xe3
</span></span><span class=line><span class=cl>  net.func·061<span class=o>()</span>
</span></span><span class=line><span class=cl>      src/net/timeout_test.go:616 +0x3ed
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Goroutine <span class=m>185</span> <span class=o>(</span>running<span class=o>)</span> created at:
</span></span><span class=line><span class=cl>  net.func·061<span class=o>()</span>
</span></span><span class=line><span class=cl>      src/net/timeout_test.go:609 +0x288
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Goroutine <span class=m>184</span> <span class=o>(</span>running<span class=o>)</span> created at:
</span></span><span class=line><span class=cl>  net.TestProlongTimeout<span class=o>()</span>
</span></span><span class=line><span class=cl>      src/net/timeout_test.go:618 +0x298
</span></span><span class=line><span class=cl>  testing.tRunner<span class=o>()</span>
</span></span><span class=line><span class=cl>      src/testing/testing.go:301 +0xe8
</span></span></code></pre></div><h2 id=选项>选项</h2><p>环境变量<code>GORACE</code>设置竞争检测器选项，格式为<code>GORACE="option1=val1 option2=val2"</code>。</p><p>有以下选项：</p><ul><li><p><code>log_path</code>（默认值为<code>stderr</code>）：竞争检测器把报告写入名为<code>log_path.pid</code>的文件。专用文件名<code>stdout</code>和<code>stderr</code>分别将报告写到标准输出和标准错误。</p></li><li><p><code>exitcode</code>（默认值为<code>66</code>）：检测到数据竞争后退出时的退出码（exit status）。</p></li><li><p><code>strip_path_prefix</code>（默认值为<code>""</code>）：去除所有报告中的路径的前缀，让报告更简洁。</p></li><li><p><code>history_size</code>（默认值为<code>1</code>）：每个 goroutine 的内存访问历史是``32K * 2**history_size`个元素。增大这个值会增大内存开销，但可以避免报告报 &ldquo;failed to restore the stack&rdquo; 错误。</p></li><li><p><code>atexit_sleep_ms</code>（默认值为<code>1000</code>）：主 goroutine 退出前的总休眠（sleep）毫秒数。</p></li></ul><h2 id=排除测试>排除测试</h2><p>当你使用<code>-race</code>标志构建（build）时，<code>go</code>命令定义了<a href=https://go.dev/pkg/go/build/#hdr-Build_Constraints target=_blank rel="external nofollow noopener noreferrer">构建标签<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a><code>race</code>。你可以使用这个标签在运行竞争检测器时排除一些代码和测试。一些例子：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// +build !race
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=kn>package</span> <span class=nx>foo</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// The test contains a data race. See issue 123.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>TestFoo</span><span class=p>(</span><span class=nx>t</span> <span class=o>*</span><span class=nx>testing</span><span class=p>.</span><span class=nx>T</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// The test fails under the race detector due to timeouts.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>TestBar</span><span class=p>(</span><span class=nx>t</span> <span class=o>*</span><span class=nx>testing</span><span class=p>.</span><span class=nx>T</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// The test takes too long under the race detector.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>TestBaz</span><span class=p>(</span><span class=nx>t</span> <span class=o>*</span><span class=nx>testing</span><span class=p>.</span><span class=nx>T</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><h2 id=怎样使用>怎样使用</h2><p>使用竞争检测器（<code>go test -race</code>）运行你的测试。竞争检测器只检测到发生在运行时的竞争，所以它不能发现未执行代码路径中的竞争。如果你的测试覆盖率不足，你运行真实负载下使用<code>-race</code>构建的可执行文件时可能会发现更多竞争。</p><h2 id=典型的数据竞争>典型的数据竞争</h2><p>这里有一些典型的数据竞争。竞争检测器可以检测到它们。</p><h3 id=循环计数器上的竞争>循环计数器上的竞争</h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>var</span> <span class=nx>wg</span> <span class=nx>sync</span><span class=p>.</span><span class=nx>WaitGroup</span>
</span></span><span class=line><span class=cl>    <span class=nx>wg</span><span class=p>.</span><span class=nf>Add</span><span class=p>(</span><span class=mi>5</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=mi>5</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>go</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>i</span><span class=p>)</span> <span class=c1>// Not the &#39;i&#39; you are looking for.
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=nx>wg</span><span class=p>.</span><span class=nf>Done</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=p>}()</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nx>wg</span><span class=p>.</span><span class=nf>Wait</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>函数字面量中的变量<code>i</code>与循环使用的变量相同，因此 goroutine 的读取与递增循环变量竞争。（该程序通常打印 55555，而不是 01234。）通过拷贝变量来修复这个程序：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>var</span> <span class=nx>wg</span> <span class=nx>sync</span><span class=p>.</span><span class=nx>WaitGroup</span>
</span></span><span class=line><span class=cl>    <span class=nx>wg</span><span class=p>.</span><span class=nf>Add</span><span class=p>(</span><span class=mi>5</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=mi>5</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>go</span> <span class=kd>func</span><span class=p>(</span><span class=nx>j</span> <span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>j</span><span class=p>)</span> <span class=c1>// Good. Read local copy of the loop counter.
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=nx>wg</span><span class=p>.</span><span class=nf>Done</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=p>}(</span><span class=nx>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nx>wg</span><span class=p>.</span><span class=nf>Wait</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><blockquote><p><strong>译者注</strong></p><p>在 Go 语言中，for 语句中定义的循环变量，存在于整个循环期间，而非一次循环。例如上面的<code>for i:= 0; i &lt; 5; i++</code>，整个循环期间的<code>i</code>是同一个变量，而非每次循环创建一个新的局部变量<code>i</code>。</p><p>有人提议修改循环变量的语义，见 <a href=https://github.com/golang/go/discussions/56010 target=_blank rel="external nofollow noopener noreferrer">redefining for loop variable semantics #56010<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a>。</p></blockquote><h3 id=意外的共享变量>意外的共享变量</h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// ParallelWrite writes data to file1 and file2, returns the errors.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>ParallelWrite</span><span class=p>(</span><span class=nx>data</span> <span class=p>[]</span><span class=kt>byte</span><span class=p>)</span> <span class=kd>chan</span> <span class=kt>error</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>res</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kt>error</span><span class=p>,</span> <span class=mi>2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>f1</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>os</span><span class=p>.</span><span class=nf>Create</span><span class=p>(</span><span class=s>&#34;file1&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>res</span> <span class=o>&lt;-</span> <span class=nx>err</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>go</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=c1>// This err is shared with the main goroutine,
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=c1>// so the write races with the write below.
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=nx>_</span><span class=p>,</span> <span class=nx>err</span> <span class=p>=</span> <span class=nx>f1</span><span class=p>.</span><span class=nf>Write</span><span class=p>(</span><span class=nx>data</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=nx>res</span> <span class=o>&lt;-</span> <span class=nx>err</span>
</span></span><span class=line><span class=cl>            <span class=nx>f1</span><span class=p>.</span><span class=nf>Close</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=p>}()</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nx>f2</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>os</span><span class=p>.</span><span class=nf>Create</span><span class=p>(</span><span class=s>&#34;file2&#34;</span><span class=p>)</span> <span class=c1>// The second conflicting write to err.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>res</span> <span class=o>&lt;-</span> <span class=nx>err</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>go</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>_</span><span class=p>,</span> <span class=nx>err</span> <span class=p>=</span> <span class=nx>f2</span><span class=p>.</span><span class=nf>Write</span><span class=p>(</span><span class=nx>data</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=nx>res</span> <span class=o>&lt;-</span> <span class=nx>err</span>
</span></span><span class=line><span class=cl>            <span class=nx>f2</span><span class=p>.</span><span class=nf>Close</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=p>}()</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>res</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>解决办法是在 goroutine 中引入新变量（注意<code>:=</code>的使用）。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl>        <span class=err>    </span><span class=o>...</span>
</span></span><span class=line><span class=cl>            <span class=nx>_</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>f1</span><span class=p>.</span><span class=nf>Write</span><span class=p>(</span><span class=nx>data</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=o>...</span>
</span></span><span class=line><span class=cl>            <span class=nx>_</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>f2</span><span class=p>.</span><span class=nf>Write</span><span class=p>(</span><span class=nx>data</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=o>...</span>
</span></span></code></pre></div><h3 id=不受保护的全局变量>不受保护的全局变量</h3><p>从多个 goroutine 调用以下代码会导致在<code>service</code>map上竞争。对同一 map 的并发读写是是安全的：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>var</span> <span class=nx>service</span> <span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=nx>net</span><span class=p>.</span><span class=nx>Addr</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>RegisterService</span><span class=p>(</span><span class=nx>name</span> <span class=kt>string</span><span class=p>,</span> <span class=nx>addr</span> <span class=nx>net</span><span class=p>.</span><span class=nx>Addr</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>service</span><span class=p>[</span><span class=nx>name</span><span class=p>]</span> <span class=p>=</span> <span class=nx>addr</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>LookupService</span><span class=p>(</span><span class=nx>name</span> <span class=kt>string</span><span class=p>)</span> <span class=nx>net</span><span class=p>.</span><span class=nx>Addr</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>service</span><span class=p>[</span><span class=nx>name</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>为了让这份代码安全，使用互斥锁保护访问。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>var</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=nx>service</span>   <span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=nx>net</span><span class=p>.</span><span class=nx>Addr</span>
</span></span><span class=line><span class=cl>    <span class=nx>serviceMu</span> <span class=nx>sync</span><span class=p>.</span><span class=nx>Mutex</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>RegisterService</span><span class=p>(</span><span class=nx>name</span> <span class=kt>string</span><span class=p>,</span> <span class=nx>addr</span> <span class=nx>net</span><span class=p>.</span><span class=nx>Addr</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>serviceMu</span><span class=p>.</span><span class=nf>Lock</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=k>defer</span> <span class=nx>serviceMu</span><span class=p>.</span><span class=nf>Unlock</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=nx>service</span><span class=p>[</span><span class=nx>name</span><span class=p>]</span> <span class=p>=</span> <span class=nx>addr</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>LookupService</span><span class=p>(</span><span class=nx>name</span> <span class=kt>string</span><span class=p>)</span> <span class=nx>net</span><span class=p>.</span><span class=nx>Addr</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>serviceMu</span><span class=p>.</span><span class=nf>Lock</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=k>defer</span> <span class=nx>serviceMu</span><span class=p>.</span><span class=nf>Unlock</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>service</span><span class=p>[</span><span class=nx>name</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=不受保护的原始类型变量>不受保护的原始类型变量。</h3><p>数据竞争也会发生在原始类型变量（<code>bool</code>、<code>int</code>、<code>int64</code>等等）上，如下例所示：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Watchdog</span> <span class=kd>struct</span><span class=p>{</span> <span class=nx>last</span> <span class=kt>int64</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>w</span> <span class=o>*</span><span class=nx>Watchdog</span><span class=p>)</span> <span class=nf>KeepAlive</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>w</span><span class=p>.</span><span class=nx>last</span> <span class=p>=</span> <span class=nx>time</span><span class=p>.</span><span class=nf>Now</span><span class=p>().</span><span class=nf>UnixNano</span><span class=p>()</span> <span class=c1>// First conflicting access.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>w</span> <span class=o>*</span><span class=nx>Watchdog</span><span class=p>)</span> <span class=nf>Start</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>go</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>time</span><span class=p>.</span><span class=nf>Sleep</span><span class=p>(</span><span class=nx>time</span><span class=p>.</span><span class=nx>Second</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=c1>// Second conflicting access.
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=k>if</span> <span class=nx>w</span><span class=p>.</span><span class=nx>last</span> <span class=p>&lt;</span> <span class=nx>time</span><span class=p>.</span><span class=nf>Now</span><span class=p>().</span><span class=nf>Add</span><span class=p>(</span><span class=o>-</span><span class=mi>10</span><span class=o>*</span><span class=nx>time</span><span class=p>.</span><span class=nx>Second</span><span class=p>).</span><span class=nf>UnixNano</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;No keepalives for 10 seconds. Dying.&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=nx>os</span><span class=p>.</span><span class=nf>Exit</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}()</span>
</span></span></code></pre></div><p>即使是这种”无辜的“的数据竞争，由于编译器优化或处理器的内存乱序，也会导致难以调试的问题。</p><p>解决这种竞争的经典方法是使用 channel 或 mutex。为了保持无锁行为，也可以使用<code>sync/atomic</code>包。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Watchdog</span> <span class=kd>struct</span><span class=p>{</span> <span class=nx>last</span> <span class=kt>int64</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>w</span> <span class=o>*</span><span class=nx>Watchdog</span><span class=p>)</span> <span class=nf>KeepAlive</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>atomic</span><span class=p>.</span><span class=nf>StoreInt64</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>w</span><span class=p>.</span><span class=nx>last</span><span class=p>,</span> <span class=nx>time</span><span class=p>.</span><span class=nf>Now</span><span class=p>().</span><span class=nf>UnixNano</span><span class=p>())</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>w</span> <span class=o>*</span><span class=nx>Watchdog</span><span class=p>)</span> <span class=nf>Start</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>go</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>for</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>time</span><span class=p>.</span><span class=nf>Sleep</span><span class=p>(</span><span class=nx>time</span><span class=p>.</span><span class=nx>Second</span><span class=p>)</span>
</span></span><span class=line><span class=cl>			<span class=k>if</span> <span class=nx>atomic</span><span class=p>.</span><span class=nf>LoadInt64</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>w</span><span class=p>.</span><span class=nx>last</span><span class=p>)</span> <span class=p>&lt;</span> <span class=nx>time</span><span class=p>.</span><span class=nf>Now</span><span class=p>().</span><span class=nf>Add</span><span class=p>(</span><span class=o>-</span><span class=mi>10</span><span class=o>*</span><span class=nx>time</span><span class=p>.</span><span class=nx>Second</span><span class=p>).</span><span class=nf>UnixNano</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>				<span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;No keepalives for 10 seconds. Dying.&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>				<span class=nx>os</span><span class=p>.</span><span class=nf>Exit</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>			<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}()</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=未同步的发送和关闭操作>未同步的发送和关闭操作</h3><p>像这个例子展示的那样，同一 channel 上未同步的发送和关闭操作也可能是竞争条件。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>c</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kd>struct</span><span class=p>{})</span> <span class=c1>// or buffered channel
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=c1>// The race detector cannot derive the happens before relation
</span></span></span><span class=line><span class=cl><span class=c1>// for the following send and close operations. These two operations
</span></span></span><span class=line><span class=cl><span class=c1>// are unsynchronized and happen concurrently.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>go</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span> <span class=nx>c</span> <span class=o>&lt;-</span> <span class=kd>struct</span><span class=p>{}{}</span> <span class=p>}()</span>
</span></span><span class=line><span class=cl><span class=nb>close</span><span class=p>(</span><span class=nx>c</span><span class=p>)</span>
</span></span></code></pre></div><p>根据 Go 语言内存模型，channel 上的发送 happens before 其上对应的接收完成。为了同步发送和关闭操作，使用接收操作确保发送在关闭前完成。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>c</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kd>struct</span><span class=p>{})</span> <span class=c1>// or buffered channel
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=k>go</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span> <span class=nx>c</span> <span class=o>&lt;-</span> <span class=kd>struct</span><span class=p>{}{}</span> <span class=p>}()</span>
</span></span><span class=line><span class=cl><span class=o>&lt;-</span><span class=nx>c</span>
</span></span><span class=line><span class=cl><span class=nb>close</span><span class=p>(</span><span class=nx>c</span><span class=p>)</span>
</span></span></code></pre></div><h2 id=要求>要求</h2><p>数据竞争检测器需要启用 cgo，支持<code>linux/amd64</code>、 <code>linux/ppc64le</code>、<code>linux/arm64</code>、<code>freebsd/amd64</code>、 <code>netbsd/amd64</code>、 <code>darwin/amd64</code>、 <code>darwin/arm64</code>和 <code>windows/amd64</code>。</p><h2 id=运行时开销>运行时开销</h2><p>竞争检测的开销因程序而异。对于典型的程序，内存使用量可能增加 5 到 10 倍，执行时间增加 2 到 20 倍。</p><p>目前竞争检测器额外为每个<code>defer</code>和<code>recover</code>语句分配 8 字节。这些额外分配的内存<a href=https://go.dev/issue/26813 target=_blank rel="external nofollow noopener noreferrer">直到 goroutine 退出才释放<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a>。这意味着如果你有一个长时间运行的、定期执行<code>defer</code>和<code>recover</code>调用的 goroutine，程序的内存使用量可能无限量增加。这些内存分配不会显示在<code>runtime.ReadMemStats</code>或<code>runtime/pprof</code>的输出中。</p></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span title="更新于 2022-10-25 09:43:35">更新于 2022-10-25&nbsp;</span></div><div class=post-info-license><span><a rel="license external nofollow noopener noreferrer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span></div></div><div class=post-info-line><div class=post-info-md></div><div class=post-info-share><span><a href=javascript:void(0); title="分享到 Twitter" data-sharer=twitter data-url=/posts/2022/10/25/ data-title="【译】Go 语言数据竞争检测器" data-hashtags=Go,Concurrency><i class="fa-brands fa-twitter fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); title="分享到 Facebook" data-sharer=facebook data-url=/posts/2022/10/25/ data-hashtag=Go><i class="fa-brands fa-facebook-square fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); title="分享到 微博" data-sharer=weibo data-url=/posts/2022/10/25/ data-title="【译】Go 语言数据竞争检测器"><i class="fa-brands fa-weibo fa-fw" aria-hidden=true></i></a></span></div></div></div><div class=post-info-more><section class=post-tags><i class="fa-solid fa-tags fa-fw me-1" aria-hidden=true></i><a href=/tags/go/ class=post-tag>Go</a><a href=/tags/concurrency/ class=post-tag>Concurrency</a></section><section><span><a href=javascript:void(0); onclick=window.history.back()>返回</a></span>&nbsp;|&nbsp;<span><a href=/>主页</a></span></section></div><div class=post-nav><a href=/posts/2022/10/20/ class=post-nav-item rel=prev title="【译】Go 语言内存模型：2022-06-06 版"><i class="fa-solid fa-angle-left fa-fw" aria-hidden=true></i>【译】Go 语言内存模型：2022-06-06 版</a>
<a href=/posts/2022/11/03/ class=post-nav-item rel=next title=【译】内存屏障：软件黑客的硬件视角>【译】内存屏障：软件黑客的硬件视角<i class="fa-solid fa-angle-right fa-fw" aria-hidden=true></i></a></div></div><div class=post-reward><div class=comment></div><input type=checkbox class=reward-input name=reward id=fi-reward hidden>
<label class=reward-button for=fi-reward>赞赏</label><div class=reward-ways data-mode=static><div><img loading=lazy src=/alipay.jpg srcset="/alipay.jpg, /alipay.jpg 1.5x, /alipay.jpg 2x" sizes=auto data-title="孔俊 支付宝" data-alt="孔俊 支付宝" style="background:url(/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'><span>支付宝</span></div><div><img loading=lazy src=/wechatpay.png srcset="/wechatpay.png, /wechatpay.png 1.5x, /wechatpay.png 2x" sizes=auto data-title="孔俊 微信" data-alt="孔俊 微信" style="background:url(/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'><span>微信</span></div></div></div><div id=comments><div id=giscus><script src=https://giscus.app/client.js data-repo=kongjun18/kongjun18.github.io data-repo-id=R_kgDOICeqmQ data-category=Announcements data-category-id=DIC_kwDOICeqmc4CVeTb data-mapping=pathname data-strict=0 data-theme=preferred_color_scheme data-reactions-enabled=1 data-emit-metadata=0 data-input-position=top data-lang=zh-CN data-loading=lazy crossorigin=anonymous async defer></script></div><noscript>Please enable JavaScript to view the comments powered by <a href=https://giscus.app/ rel="external nofollow noopener noreferrer">giscus</a>.</noscript></div></article></main><footer class=footer><div class=footer-container><div class="footer-line powered">由 <a href=https://gohugo.io/ target=_blank rel="external nofollow noopener noreferrer" title="Hugo 0.110.0">Hugo</a> 强力驱动 | 主题 - <a href=https://github.com/hugo-fixit/FixIt target=_blank rel=external title="FixIt v0.2.18"><img class=fixit-icon src=/fixit.min.svg alt="FixIt logo">&nbsp;FixIt</a></div><div class="footer-line copyright" itemscope itemtype=http://schema.org/CreativeWork><i class="fa-regular fa-copyright fa-fw" aria-hidden=true></i>
<span itemprop=copyrightYear>2022 - 2023</span><span class=author itemprop=copyrightHolder>
<a href=/></a></span><span class="license footer-divider"><a rel="license external nofollow noopener noreferrer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span></div><div class="footer-line statistics"></div></div></footer></div><div class=widgets><div class="fixed-buttons animate__faster d-none"><div class="fixed-button back-to-top" role=button aria-label=回到顶部><i class="fa-solid fa-arrow-up fa-fw" aria-hidden=true></i><span class="variant-numeric d-none">0%</span></div><div class="fixed-button view-comments d-none" role=button aria-label=查看评论><i class="fa-solid fa-comment fa-fw" aria-hidden=true></i></div></div><a href=https://github.com/kongjun18/blog title=查看博客源代码 target=_blank rel="external nofollow" class="github-corner left d-none-mobile"><svg viewBox="0 0 250 250" aria-hidden="true"><path d="M0 0 115 115h15l12 27L250 250V0z"/><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentcolor" style="transform-origin:130px 106px" class="octo-arm"/><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4l13.9-13.8C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8z" fill="currentcolor" class="octo-body"/></svg></a><div id=mask></div><noscript><div class=noscript-warning>FixIt 主题在启用 JavaScript 的情况下效果最佳。</div></noscript></div><link rel=stylesheet href=/lib/cookieconsent/cookieconsent.min.css><script src=/lib/sharer/sharer.min.js async defer></script><script src=/lib/cookieconsent/cookieconsent.min.js defer></script><script src=/lib/pangu/pangu.min.js defer></script><script>window.config={autoBookmark:!0,code:{copyTitle:"复制到剪贴板",editLockTitle:"锁定可编辑代码块",editUnLockTitle:"解锁可编辑代码块",editable:!0,maxShownLines:40},comment:{enable:!0,expired:!1,giscus:{darkTheme:"dark_dimmed",lightTheme:"light"}},cookieconsent:{content:{dismiss:"同意",link:"了解更多",message:"本网站使用 Cookies 来改善您的浏览体验。"},enable:!0,palette:{button:{background:"#f0f0f0"},popup:{background:"#1aa3ff"}},theme:"edgeless"},pangu:{enable:!0,selector:"article"}}</script><script src=/js/theme.min.js defer></script></body></html>