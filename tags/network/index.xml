<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>Network - 标签 - 孔俊的知识库</title><link>/tags/network/</link><description>Network - 标签 - 孔俊的知识库</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Mon, 21 Nov 2022 17:42:25 +0800</lastBuildDate><atom:link href="/tags/network/" rel="self" type="application/rss+xml"/><item><title>深入剖析 Go 语言运行时：IO 轮询器</title><link>/posts/2022/11/21/</link><pubDate>Mon, 21 Nov 2022 17:42:25 +0800</pubDate><author>作者</author><guid>/posts/2022/11/21/</guid><description><![CDATA[netpoller 概述 考虑一个基于 goroutine-per-connection 模型的 TCP echo server： import ( &#34;fmt&#34; &#34;io&#34; &#34;log&#34; &#34;net&#34; ) func worker(conn net.Conn) { defer conn.Close() b := make([]byte, 512) for { size, err := conn.Read(b) if err == io.EOF { break } if err != nil { log.Fatal(err) } size, err = conn.Write(b[0:size]) if err != nil { log.Fatal(err) } } } func main() { listner, err := net.Listen(&#34;tcp&#34;, &#34;127.0.0.1:8080&#34;) if err != nil { log.Fatal(err) } for { conn, err := listner.Accept() if err != nil { log.Fatal(err) } go worker(conn) } } 从用户侧看，系统该调用阻塞 goroutine，Go scheduler 调度其他 goroutine。问题在于，goroutine 复用在线程上，如果 IO 系统调用（如read(2]]></description></item><item><title>网络层：控制面板</title><link>/posts/2022/01/01/</link><pubDate>Sat, 01 Jan 2022 11:38:14 +0800</pubDate><author>作者</author><guid>/posts/2022/01/01/</guid><description>路由器中和路由（决定数据包从源主机到目的主机的路径）相关的功能成为控制面板。 传统上，每个路由器都有自己的控制面板，即每个路由器都独立实现了路由算法。 per-router-control-plane 现在，软件定义网络迅速发展，使用远程控制器连接路由器，实现逻辑上集中式的控制，路由器给控制器提供必要链路信息，控制器计算路由表并安装到路由器中。 SND-contral-plane 路由算法 路由算法决定数据报从主机发送到目的主机的路径，路由算法探</description></item></channel></rss>