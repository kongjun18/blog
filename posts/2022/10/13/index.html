<!doctype html><html itemscope itemtype=http://schema.org/WebPage lang=zh-cn><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=2"><meta name=robots content="noodp"><title>【译】一种面向多核架构的无锁、缓存高效的共享环形缓冲区 - 孔俊的知识库</title><meta name=author content><meta name=author-link content><meta name=description content="译者序 论文 A Lock-Free, Cache-Efficient Shared Ring Buffer for Multi-Core Architectures 介绍了一种专为多核架构设计、用于单生产者/单消费者模型的环形缓冲区，称为 MCRingBuffer。论文性能测试表明，其吞吐量数倍于 Lamport 提出的 BasicRingBuffer。 MCRingBuffer 将环形缓存区划分为多个块，块划分为多个槽。 论文基于基础的环形缓冲区，从以下两方面着手提高性能： 降低读共享控制变量的频率：维护私有变量，仅在缓冲区可能满/空时读取"><meta name=keywords content="Concurrency,Data Structure"><meta itemprop=name content="【译】一种面向多核架构的无锁、缓存高效的共享环形缓冲区"><meta itemprop=description content="译者序 论文 A Lock-Free, Cache-Efficient Shared Ring Buffer for Multi-Core Architectures 介绍了一种专为多核架构设计、用于单生产者/单消费者模型的环形缓冲区，称为 MCRingBuffer。论文性能测试表明，其吞吐量数倍于 Lamport 提出的 BasicRingBuffer。 MCRingBuffer 将环形缓存区划分为多个块，块划分为多个槽。 论文基于基础的环形缓冲区，从以下两方面着手提高性能： 降低读共享控制变量的频率：维护私有变量，仅在缓冲区可能满/空时读取"><meta itemprop=datePublished content="2022-10-13T22:26:21+08:00"><meta itemprop=dateModified content="2022-10-13T22:26:21+08:00"><meta itemprop=wordCount content="3040"><meta itemprop=image content="/posts/2022/10/13/images/featured-image.webp"><meta itemprop=keywords content="Concurrency,Data Structure,"><meta property="og:title" content="【译】一种面向多核架构的无锁、缓存高效的共享环形缓冲区"><meta property="og:description" content="译者序 论文 A Lock-Free, Cache-Efficient Shared Ring Buffer for Multi-Core Architectures 介绍了一种专为多核架构设计、用于单生产者/单消费者模型的环形缓冲区，称为 MCRingBuffer。论文性能测试表明，其吞吐量数倍于 Lamport 提出的 BasicRingBuffer。 MCRingBuffer 将环形缓存区划分为多个块，块划分为多个槽。 论文基于基础的环形缓冲区，从以下两方面着手提高性能： 降低读共享控制变量的频率：维护私有变量，仅在缓冲区可能满/空时读取"><meta property="og:type" content="article"><meta property="og:url" content="/posts/2022/10/13/"><meta property="og:image" content="/posts/2022/10/13/images/featured-image.webp"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-10-13T22:26:21+08:00"><meta property="article:modified_time" content="2022-10-13T22:26:21+08:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="/posts/2022/10/13/images/featured-image.webp"><meta name=twitter:title content="【译】一种面向多核架构的无锁、缓存高效的共享环形缓冲区"><meta name=twitter:description content="译者序 论文 A Lock-Free, Cache-Efficient Shared Ring Buffer for Multi-Core Architectures 介绍了一种专为多核架构设计、用于单生产者/单消费者模型的环形缓冲区，称为 MCRingBuffer。论文性能测试表明，其吞吐量数倍于 Lamport 提出的 BasicRingBuffer。 MCRingBuffer 将环形缓存区划分为多个块，块划分为多个槽。 论文基于基础的环形缓冲区，从以下两方面着手提高性能： 降低读共享控制变量的频率：维护私有变量，仅在缓冲区可能满/空时读取"><meta name=application-name content="FixIt"><meta name=apple-mobile-web-app-title content="FixIt"><meta name=theme-color data-light=#f8f8f8 data-dark=#252627 content="#f8f8f8"><meta name=msapplication-TileColor content="#da532c"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=canonical href=/posts/2022/10/13/><link rel=prev href=/posts/2022/10/09/><link rel=next href=/posts/2022/10/20/><link rel=stylesheet href=/css/style.min.css><link rel=stylesheet href=/lib/fontawesome-free/all.min.css><link rel=stylesheet href=/lib/animate/animate.min.css><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"【译】一种面向多核架构的无锁、缓存高效的共享环形缓冲区","inLanguage":"zh-CN","mainEntityOfPage":{"@type":"WebPage","@id":"\/posts\/2022\/10\/13\/"},"image":[{"@type":"ImageObject","url":"\/posts\/2022\/10\/13\/images\/featured-image.webp","width":1500,"height":500}],"genre":"posts","keywords":"Concurrency, Data Structure","wordcount":3040,"url":"\/posts\/2022\/10\/13\/","datePublished":"2022-10-13T22:26:21+08:00","dateModified":"2022-10-13T22:26:21+08:00","publisher":{"@type":"Organization","name":""},"author":{"@type":"Person","name":"孔俊"},"description":""}</script></head><body data-header-desktop=sticky data-header-mobile=auto><script>(window.localStorage?.getItem("theme")?localStorage.getItem("theme")==="dark":"auto"==="auto"?window.matchMedia("(prefers-color-scheme: dark)").matches:"auto"==="dark")&&document.body.setAttribute("data-theme","dark")</script><div class=wrapper data-page-style=normal><header class="desktop animate__faster" id=header-desktop><div class=header-wrapper data-github-corner=left><div class=header-title><a href=/ title=孔俊的知识库><img loading=lazy src=/logo.svg srcset="/logo.svg, /logo.svg 1.5x, /logo.svg 2x" sizes=auto data-title=孔俊的知识库 data-alt=孔俊的知识库 class=logo style="background:url(/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'><span class=header-title-text>孔俊的知识库</span></a><span class=header-subtitle></span></div><nav><ul class=menu><li class=menu-item><a class=menu-link href=/posts/>文章</a></li><li class=menu-item><a class=menu-link href=/categories/>分类</a></li><li class=menu-item><a class=menu-link href=/tags/>标签</a></li><li class=menu-item><a class=menu-link href=/archives/>归档</a></li><li class=menu-item><a class=menu-link href=/about/>关于我</a></li><li class="menu-item delimiter"></li><li class="menu-item theme-switch" title=切换主题><i class="fa-solid fa-adjust fa-fw" aria-hidden=true></i></li></ul></nav></div></header><header class="mobile animate__faster" id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title=孔俊的知识库><img loading=lazy src=/logo.svg srcset="/logo.svg, /logo.svg 1.5x, /logo.svg 2x" sizes=auto data-title=/logo.svg data-alt=/logo.svg class=logo style="background:url(/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'><span class=header-title-text>孔俊的知识库</span></a><span class=header-subtitle></span></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><nav><ul class=menu id=menu-mobile><li class=menu-item><a class=menu-link href=/posts/>文章</a></li><li class=menu-item><a class=menu-link href=/categories/>分类</a></li><li class=menu-item><a class=menu-link href=/tags/>标签</a></li><li class=menu-item><a class=menu-link href=/archives/>归档</a></li><li class=menu-item><a class=menu-link href=/about/>关于我</a></li><li class="menu-item menu-system"><span class="menu-system-item theme-switch" title=切换主题><i class="fa-solid fa-adjust fa-fw" aria-hidden=true></i></span></li></ul></nav></div></header><main class=container><aside class=toc id=toc-auto><h2 class=toc-title>目录&nbsp;<i class="toc-icon fa-solid fa-angle-down fa-fw" aria-hidden=true></i></h2><div class=toc-content id=toc-content-auto></div></aside><aside class=aside-custom></aside><article class="page single"><div class=header><h1 class="single-title animate__animated animate__flipInX"><span title=转载 class=icon-repost><i class="fa-solid fa-share fa-fw" aria-hidden=true></i></span><span>【译】一种面向多核架构的无锁、缓存高效的共享环形缓冲区</span></h1><p class="single-subtitle animate__animated animate__fadeIn">A Lock-Free, Cache-Efficient Shared Ring Buffer for Multi-Core Architectures</p></div><div class=post-meta><div class=post-meta-line><span class=post-author><span class=author><i class="fa-solid fa-user-circle" aria-hidden=true></i>
孔俊</span></span>
<span class=post-category>收录于 <a href=/categories/concurrency/><i class="fa-regular fa-folder fa-fw" aria-hidden=true></i> Concurrency</a></span></div><div class=post-meta-line><span title="发布于 2022-10-13 22:26:21"><i class="fa-regular fa-calendar-alt fa-fw me-1" aria-hidden=true></i><time datetime=2022-10-13>2022-10-13</time></span>&nbsp;<span title="更新于 2022-10-13 22:26:21"><i class="fa-regular fa-edit fa-fw me-1" aria-hidden=true></i><time datetime=2022-10-13>2022-10-13</time></span>&nbsp;<span><i class="fa-solid fa-pencil-alt fa-fw me-1" aria-hidden=true></i>约 3040 字</span>&nbsp;<span><i class="fa-regular fa-clock fa-fw me-1" aria-hidden=true></i>预计阅读 7 分钟</span>&nbsp;</div></div><div class=featured-image><img loading=lazy src=/posts/2022/10/13/images/featured-image.webp srcset="/posts/2022/10/13/images/featured-image.webp, /posts/2022/10/13/images/featured-image.webp 1.5x, /posts/2022/10/13/images/featured-image.webp 2x" sizes=auto data-title=/posts/2022/10/13/images/featured-image.webp data-alt=/posts/2022/10/13/images/featured-image.webp style="background:url(/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'></div><div class="details toc" id=toc-static data-kept=false><div class="details-summary toc-title"><span>目录</span>
<span><i class="details-icon fa-solid fa-angle-right" aria-hidden=true></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><a href=#译者序>译者序</a></li><li><a href=#版权>版权</a></li><li><a href=#摘要>摘要</a></li><li><a href=#类别和主题>类别和主题</a></li><li><a href=#关键词>关键词</a></li><li><a href=#简介>简介</a></li><li><a href=#设计>设计</a></li><li><a href=#评估>评估</a></li><li><a href=#结论>结论</a></li><li><a href=#参考>参考</a></li></ul></nav></div></div><div class=content id=content><h2 id=译者序>译者序</h2><p>论文 <em>A Lock-Free, Cache-Efficient Shared Ring Buffer for Multi-Core Architectures</em> 介绍了一种专为多核架构设计、用于<em>单生产者/单消费者模型</em>的环形缓冲区，称为 <em>MCRingBuffer</em>。论文性能测试表明，其吞吐量数倍于 Lamport 提出的 <em>BasicRingBuffer</em>。</p><p>MCRingBuffer 将环形缓存区划分为多个块，块划分为多个槽。</p><p>论文基于基础的环形缓冲区，从以下两方面着手提高性能：</p><ol><li>降低读共享控制变量的频率：维护私有变量，仅在缓冲区可能满/空时读取共享控制变量。</li></ol><p>写者维护私有变量<code>localRead</code>，记录写者看到的读者最近一次读取位置。当写者发现<code>NEXT(nextWrite)==localRead</code>时，说明缓冲区可能已满。这时去读取共享控制变量<code>read</code>判断缓存区是否真的已满。读者也有类似逻辑。</p><ol start=2><li>降低写共享控制变量的频率：批量更新控制变量。</li></ol><p>按块更新<code>read</code>和<code>write</code>。读者读完一个块后更新<code>read</code>，写者写完一个块后更新<code>write</code>。因此写者维护的<code>localRead</code>/读者的<code>read</code>落后于读者当前读取到的槽（读者读了几个槽，但没读完块，不更新<code>read</code>）。</p><p>以下是写者视角的 MCRingBuffer。</p><p><figure><img src=images/writer-view-of-MCRingBuffer.png alt=writer-view-of-MCRingBuffer><figcaption>writer-view-of-MCRingBuffer</figcaption></figure></p><h2 id=版权>版权</h2><blockquote><p>Permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page. To copy otherwise, or republish, to post on servers or to redistribute to lists, requires prior specific permission and/or a fee.</p><p>ICS’09, June 8–12, 2009, York Town Heights, New York, USA. Copyright 2009 ACM 978-1-60558-498-0/09/06&mldr;$5.00.</p></blockquote><center><b>A Lock-Free, Cache-Efficient Shared Ring Buffer for Multi-Core Architectures</b></center><h2 id=摘要>摘要</h2><p>我们提出一个无锁、缓存高效的共享环形缓冲区 <em>MCRingBuffer</em>，在多核架构中提供跨线程的高速数据访问。MCRingBuffer 通过并发的无锁数据访问来降低跨核通信的开销，并改善访问用于线程同步的控制变量的缓存局部性。在 Intel Xeon 多核机器上的性能测试表明 MCRingBuffer 的吞吐量是现存其他无锁并发环形缓冲区的 4.9 倍。MCRingBUffer 的一个重要应用是<em>并行网络流量检测</em>(<em>parallel network traffic monitorin</em>)，MCRingBuffer 有利于多核架构下以<em>线速</em>（<em>line rate</em>）处理网络包。</p><h2 id=类别和主题>类别和主题</h2><p>D.4.1 [<strong>Operating Systems</strong>]: Process Management—Synchronization</p><h2 id=关键词>关键词</h2><p>Design, Experimentation, Performance</p><h2 id=简介>简介</h2><p>我们提出 <em>MCRingBuffer</em>，一个无锁、缓存高效的环形缓冲区，用于加速多线程的多核流量检测系统的的共享数据访问。MCRingBuffer 通过提高引用<em>缓冲区槽</em>（<em>buffer slot</em>)的控制变量的缓存局部性来最小化线程同步的内存访问开销。注意，MCRingBuffer 在通用 CPU 上工作，不依赖任何硬件同步原语的软件方法。MCRingBuffer 的性能提升与传输的数据元素的类型和多线程应用的实现无关。</p><p>MCRingBuffer 的一个重要应用是高速网络中的数据流量监控系统。多核架构通过<em>并行化</em>（<em>parallelizing</em>）数据包的处理，提供了一种潜在的线速流量监控方案。</p><p>MCRingBuffer 力求开发多核架构的全部潜力，它最小化跨核通信的开销，以便不同核心上的线程可以高效交换信息用于网络数据分析。</p><h2 id=设计>设计</h2><p>我们聚焦于单生产者/单消费者模型。Lamport [2] 提出了一个我们称之为 <em>BasicRingBuffer</em> 的并发无锁环形缓冲区，它不需要任何硬件同步原语（比如 compare-and-swap）。BasicRingBuffer 的正确性依赖于读写控制变量（整数类型）是不可分隔的原子操作。现代硬件架构通常满足这一假设。</p><p>其他无锁环形缓冲区 [1,3] 通过直接比较控制变量和保存数据的缓冲区槽来优化 BasicRingBuffer。然而，这种数据/控制耦合的方案要求环形缓冲区必须定义一个不可以被应用使用的空数据元素，因此将环形缓冲区用于通用数据类型时引入了额外约束。</p><p>我们提出 MCRingBuffer，一个支持并发无锁访问的环形缓冲区。MCRingBuffer 基于 BasicRingBuffer，专门优化了控制变量的缓存局部性。图 1 展示了 MCRIngBuffer 的框架，包括控制变量的放置和生产者/消费者执行的插入/提取过程。MCRingBuffer 包括两个主要的设计特性：(i) 缓存行保护和 (ii) 批量更新控制变量。</p><p><strong>缓存行保护</strong>。把控制变量放置在缓存中。为了避免<em>伪共享</em>（<em>false sharing</em>)（比如两个线程都访问同一缓存行中的变量），我们这样放置控制变量以便不同线程的局部、非共享变量不会存放于同一缓存行。通过缓存行保护，我们可以最小化访问共享控制变量的开销。当生产者（消费者）将要插入（提取）元素，它首先检查它自己缓存行中的局部控制变量<code>localRead</code>(<code>localWrite</code>)来决定缓存区是否<strong>可能</strong>满（空）。如果是，生成者（消费者）再进一步检查<code>read</code>(<code>write</code>)来决定缓冲区是否<strong>真的</strong>满（空）。生产者（消费者）将在缓冲区不可能或没有真的满（空）时插入（提取）元素。直觉上看，从内存重新加载<code>read</code>(<code>write</code>)时，它可能已经被消费者（生产者）递增多次以指向前面的缓冲区槽。因此，生产者（消费者）只需要在多于一个插入（提取）操作后访问<code>read</code>(<code>write</code>)。因此，<em>MCRingBUffer 降低了从内存读取共享控制变量的频率</em>。</p><p><strong>批量更新控制变量</strong>。在 BasicRingBuffer 中，在每次提取（插入）操作后更新共享变量<code>read</code>(<code>write</code>)。这里，我们在控制变量<code>read</code>和<code>write</code>上应用批量更新，所以我们更少更新它们。我们将环形缓冲区划分为块，每个块包含<code>batchSize</code>个槽。我们只在<code>batchSize</code>个元素被提取（插入）后递增<code>read</code>(<code>write</code>)指向下一个块。因此，<em>我们降低了写共享变量到内存的频率</em>。注意，我们的批量更新策略只用于控制变量，对如何调度数据元素上的插入、提取操作是透明的。</p><p>批量更新策略假定数据元素始终可用，以便可以更新控制变量。 这对包含大量数据包的高速网络共享数据包信息的环形缓冲区是合理的。</p><pre tabindex=0><code>/* Variable definitions */
1: char cachePad0[CACHE LINE];
2: /*shared control variables*/
3: volatile int read;
4: volatile int write;
5: char cachePad1[CACHE LINE - 2 * sizeof(int)];
6: /*consumer’s local control variables*/
7: int localWrite;
8: int nextRead;
9: int rBatch;
10: char cachePad2[CACHE LINE - 3 * sizeof(int)];
11: /*producer’s local control variables*/
12: int localRead;
13: int nextWrite;
14: int wBatch;
15: char cachePad3[CACHE LINE - 3 * sizeof(int)];
16: /*constants*/
17: int max;
18: int blockOnEmpty;
19: int batchSize;
20: char cachePad4[CACHE LINE - 3 * sizeof(int)];
21: T* element;

function Insert(T element)
1: int afterNextWrite = NEXT(nextWrite);
2: if afterNextWrite == localRead then
3:   while afterNextWrite == read do
4:   /*busy waiting*/
5:   end while
6:   localRead = read;
7: end if
8: buffer[nextWrite] = element;
9: nextWrite = afterNextWrite;
10: wBatch++;
11: if wBatch ≥ batchSize then
12:   write = nextWrite;
13:   wBatch = 0;
14: end if

function Extract(T* element)
1: if nextRead == localWrite then
2:   while nextRead == write do
3:     if blockOnEmpty == 0 then
4:       return -1; /*no element is read*/
5:     end if
6:   /*busy waiting*/
7:   end while
8:   localWrite = write;
9: end if
10: *element = buffer[nextRead];
11: nextRead = NEXT(nextRead);
12: rBatch++;
13: if rBatch ≥ batchSize then
14:   read = nextRead;
15:   rBatch = 0;
16: end if
17: return 0; /*an element is read*/
</code></pre><h2 id=评估>评估</h2><p>我们在配备 2.66 GHz CPU 和 32 GB RAM 的 Intel Xeon 5355 四核 Linux 机器上评估 BasicRingBuffer 和 MCRingBuffer。 CPU 包括双核模块的两个副本，每个副本都有一对核心和一个共享的二级 (L2) 缓存。 如果一对核心位于同一个模块中，我们称它们为同级核心，否则称为非同级核心。 环形缓冲区是用 C++ 编写的，并使用带有 -O2 选项的 GCC 4.1.2 编译。</p><p>在我们的评估中，生产者线程插入 10M 元素，消费者线程依次提取插入的元素。我们测量<em>吞吐量</em>（<em>throughput</em>），例如每秒执行的插入/提取操作对数。每个数据点平均进行超过 30 次实验。</p><p>图 2 展示了环形缓冲区容量为 2000 个元素的时，BasicRingBuffer 和不同 MCRingBuffer 变种的吞吐量与数据元素大小的关系。总体而言，MCRingBuffer 实现了比 BasicRingBuffer 更大的吞吐量。例如，当元素大小为 64 字节时，<code>bachSize=50</code>的 MCRingBuffer 的吞吐量分别是同级和不同级核心上的 BasicRingBuffer 的 4.9 被和 2.5 倍。</p><p><figure><img src=images/throughput-vs-element-size.png alt=throughput-vs-element-size><figcaption>throughput-vs-element-size</figcaption></figure></p><h2 id=结论>结论</h2><p>我们介绍了 MCRingBuffer，一个实现高效多核架构线程通信的无锁、缓存高效的环形缓冲区。MCRingBuffer 通过缓存行保护和批量更新控制变量改善了控制变量的缓存局部性。</p><h2 id=参考>参考</h2><p>[1] J. Giacomoni, T. Moseley, and M. Vachharajani. FastForward for Efficient Pipeline Parallelism - A Cache-Optimized Concurrent Lock-Free Queue. In PPoPP, 2008.</p><p>[2] L. Lamport. Proving the Correctness of Multiprocess Programs. IEEE Trans. on Software Engineering, 3(2), Mar 1977.</p><p>[3] J. Wang, H. Cheng, B. Hua, and X. Tang. Practice of Parallelizing Network Applications on Multi-core Architectures. In ISC, 2009.</p></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span title="更新于 2022-10-13 22:26:21">更新于 2022-10-13&nbsp;</span></div><div class=post-info-license><span><a rel="license external nofollow noopener noreferrer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span></div></div><div class=post-info-line><div class=post-info-md></div><div class=post-info-share><span><a href=javascript:void(0); title="分享到 Twitter" data-sharer=twitter data-url=/posts/2022/10/13/ data-title=【译】一种面向多核架构的无锁、缓存高效的共享环形缓冲区 data-hashtags="Concurrency,Data Structure"><i class="fa-brands fa-twitter fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); title="分享到 Facebook" data-sharer=facebook data-url=/posts/2022/10/13/ data-hashtag=Concurrency><i class="fa-brands fa-facebook-square fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); title="分享到 微博" data-sharer=weibo data-url=/posts/2022/10/13/ data-title=【译】一种面向多核架构的无锁、缓存高效的共享环形缓冲区><i class="fa-brands fa-weibo fa-fw" aria-hidden=true></i></a></span></div></div></div><div class=post-info-more><section class=post-tags><i class="fa-solid fa-tags fa-fw me-1" aria-hidden=true></i><a href=/tags/concurrency/ class=post-tag>Concurrency</a><a href=/tags/data-structure/ class=post-tag>Data Structure</a></section><section><span><a href=javascript:void(0); onclick=window.history.back()>返回</a></span>&nbsp;|&nbsp;<span><a href=/>主页</a></span></section></div><div class=post-nav><a href=/posts/2022/10/09/ class=post-nav-item rel=prev title="【译】 如何设计正确运行多进程程序的多核计算机"><i class="fa-solid fa-angle-left fa-fw" aria-hidden=true></i>【译】 如何设计正确运行多进程程序的多核计算机</a>
<a href=/posts/2022/10/20/ class=post-nav-item rel=next title="【译】Go 语言内存模型：2022-06-06 版">【译】Go 语言内存模型：2022-06-06 版<i class="fa-solid fa-angle-right fa-fw" aria-hidden=true></i></a></div></div><div class=post-reward><div class=comment></div><input type=checkbox class=reward-input name=reward id=fi-reward hidden>
<label class=reward-button for=fi-reward>赞赏</label><div class=reward-ways data-mode=static><div><img loading=lazy src=/alipay.jpg srcset="/alipay.jpg, /alipay.jpg 1.5x, /alipay.jpg 2x" sizes=auto data-title="孔俊 支付宝" data-alt="孔俊 支付宝" style="background:url(/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'><span>支付宝</span></div><div><img loading=lazy src=/wechatpay.png srcset="/wechatpay.png, /wechatpay.png 1.5x, /wechatpay.png 2x" sizes=auto data-title="孔俊 微信" data-alt="孔俊 微信" style="background:url(/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'><span>微信</span></div></div></div><div id=comments><div id=giscus><script src=https://giscus.app/client.js data-repo=kongjun18/kongjun18.github.io data-repo-id=R_kgDOICeqmQ data-category=Announcements data-category-id=DIC_kwDOICeqmc4CVeTb data-mapping=pathname data-strict=0 data-theme=preferred_color_scheme data-reactions-enabled=1 data-emit-metadata=0 data-input-position=top data-lang=zh-CN data-loading=lazy crossorigin=anonymous async defer></script></div><noscript>Please enable JavaScript to view the comments powered by <a href=https://giscus.app/ rel="external nofollow noopener noreferrer">giscus</a>.</noscript></div></article></main><footer class=footer><div class=footer-container><div class="footer-line powered">由 <a href=https://gohugo.io/ target=_blank rel="external nofollow noopener noreferrer" title="Hugo 0.110.0">Hugo</a> 强力驱动 | 主题 - <a href=https://github.com/hugo-fixit/FixIt target=_blank rel=external title="FixIt v0.2.18"><img class=fixit-icon src=/fixit.min.svg alt="FixIt logo">&nbsp;FixIt</a></div><div class="footer-line copyright" itemscope itemtype=http://schema.org/CreativeWork><i class="fa-regular fa-copyright fa-fw" aria-hidden=true></i>
<span itemprop=copyrightYear>2022 - 2023</span><span class=author itemprop=copyrightHolder>
<a href=/></a></span><span class="license footer-divider"><a rel="license external nofollow noopener noreferrer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span></div><div class="footer-line statistics"></div></div></footer></div><div class=widgets><div class="fixed-buttons animate__faster d-none"><div class="fixed-button back-to-top" role=button aria-label=回到顶部><i class="fa-solid fa-arrow-up fa-fw" aria-hidden=true></i><span class="variant-numeric d-none">0%</span></div><div class="fixed-button view-comments d-none" role=button aria-label=查看评论><i class="fa-solid fa-comment fa-fw" aria-hidden=true></i></div></div><a href=https://github.com/kongjun18/blog title=查看博客源代码 target=_blank rel="external nofollow" class="github-corner left d-none-mobile"><svg viewBox="0 0 250 250" aria-hidden="true"><path d="M0 0 115 115h15l12 27L250 250V0z"/><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentcolor" style="transform-origin:130px 106px" class="octo-arm"/><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4l13.9-13.8C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8z" fill="currentcolor" class="octo-body"/></svg></a><div id=mask></div><noscript><div class=noscript-warning>FixIt 主题在启用 JavaScript 的情况下效果最佳。</div></noscript></div><link rel=stylesheet href=/lib/cookieconsent/cookieconsent.min.css><script src=/lib/sharer/sharer.min.js async defer></script><script src=/lib/cookieconsent/cookieconsent.min.js defer></script><script src=/lib/pangu/pangu.min.js defer></script><script>window.config={autoBookmark:!0,code:{copyTitle:"复制到剪贴板",editLockTitle:"锁定可编辑代码块",editUnLockTitle:"解锁可编辑代码块",editable:!0,maxShownLines:40},comment:{enable:!0,expired:!1,giscus:{darkTheme:"dark_dimmed",lightTheme:"light"}},cookieconsent:{content:{dismiss:"同意",link:"了解更多",message:"本网站使用 Cookies 来改善您的浏览体验。"},enable:!0,palette:{button:{background:"#f0f0f0"},popup:{background:"#1aa3ff"}},theme:"edgeless"},pangu:{enable:!0,selector:"article"}}</script><script src=/js/theme.min.js defer></script></body></html>