<!doctype html><html itemscope itemtype=http://schema.org/WebPage lang=zh-cn><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=2"><meta name=robots content="noodp"><title>【译】拨开 Linux 平均负载的谜团 - 孔俊的知识库</title><meta name=author content><meta name=author-link content><meta name=description content="平均负载（load averages）是一个很关键的指标——我所在的公司基于平均负载和其他指标，花费数百万去自动伸缩云实例——但在 Linux 上存在许多和平均负载相关的谜题。Linux 平均负载不仅追踪运行态（runnable）任务，也追踪处于不可中断休眠状态（uninterruptible sleep state）的任务。为什么？从没有人给我解释过。在这篇文章中，我将解决这个谜团，"><meta name=keywords content="Linux"><meta itemprop=name content="【译】拨开 Linux 平均负载的谜团"><meta itemprop=description content="平均负载（load averages）是一个很关键的指标——我所在的公司基于平均负载和其他指标，花费数百万去自动伸缩云实例——但在 Linux 上存在许多和平均负载相关的谜题。Linux 平均负载不仅追踪运行态（runnable）任务，也追踪处于不可中断休眠状态（uninterruptible sleep state）的任务。为什么？从没有人给我解释过。在这篇文章中，我将解决这个谜团，"><meta itemprop=datePublished content="2022-09-27T14:27:44+08:00"><meta itemprop=dateModified content="2022-09-27T14:27:44+08:00"><meta itemprop=wordCount content="10015"><meta itemprop=image content="/posts/2022/09/27/images/featured-image.webp"><meta itemprop=keywords content="Linux,"><meta property="og:title" content="【译】拨开 Linux 平均负载的谜团"><meta property="og:description" content="平均负载（load averages）是一个很关键的指标——我所在的公司基于平均负载和其他指标，花费数百万去自动伸缩云实例——但在 Linux 上存在许多和平均负载相关的谜题。Linux 平均负载不仅追踪运行态（runnable）任务，也追踪处于不可中断休眠状态（uninterruptible sleep state）的任务。为什么？从没有人给我解释过。在这篇文章中，我将解决这个谜团，"><meta property="og:type" content="article"><meta property="og:url" content="/posts/2022/09/27/"><meta property="og:image" content="/posts/2022/09/27/images/featured-image.webp"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-09-27T14:27:44+08:00"><meta property="article:modified_time" content="2022-09-27T14:27:44+08:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="/posts/2022/09/27/images/featured-image.webp"><meta name=twitter:title content="【译】拨开 Linux 平均负载的谜团"><meta name=twitter:description content="平均负载（load averages）是一个很关键的指标——我所在的公司基于平均负载和其他指标，花费数百万去自动伸缩云实例——但在 Linux 上存在许多和平均负载相关的谜题。Linux 平均负载不仅追踪运行态（runnable）任务，也追踪处于不可中断休眠状态（uninterruptible sleep state）的任务。为什么？从没有人给我解释过。在这篇文章中，我将解决这个谜团，"><meta name=application-name content="FixIt"><meta name=apple-mobile-web-app-title content="FixIt"><meta name=theme-color data-light=#f8f8f8 data-dark=#252627 content="#f8f8f8"><meta name=msapplication-TileColor content="#da532c"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=canonical href=/posts/2022/09/27/><link rel=prev href=/posts/2022/09/21/><link rel=next href=/posts/2022/10/09/><link rel=stylesheet href=/css/style.min.css><link rel=stylesheet href=/lib/fontawesome-free/all.min.css><link rel=stylesheet href=/lib/animate/animate.min.css><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"【译】拨开 Linux 平均负载的谜团","inLanguage":"zh-CN","mainEntityOfPage":{"@type":"WebPage","@id":"\/posts\/2022\/09\/27\/"},"image":[{"@type":"ImageObject","url":"\/posts\/2022\/09\/27\/images\/featured-image.webp","width":1126,"height":588}],"genre":"posts","keywords":"Linux","wordcount":10015,"url":"\/posts\/2022\/09\/27\/","datePublished":"2022-09-27T14:27:44+08:00","dateModified":"2022-09-27T14:27:44+08:00","publisher":{"@type":"Organization","name":""},"author":{"@type":"Person","name":"孔俊"},"description":""}</script></head><body data-header-desktop=sticky data-header-mobile=auto><script>(window.localStorage?.getItem("theme")?localStorage.getItem("theme")==="dark":"auto"==="auto"?window.matchMedia("(prefers-color-scheme: dark)").matches:"auto"==="dark")&&document.body.setAttribute("data-theme","dark")</script><div class=wrapper data-page-style=normal><header class="desktop animate__faster" id=header-desktop><div class=header-wrapper data-github-corner=left><div class=header-title><a href=/ title=孔俊的知识库><img loading=lazy src=/logo.svg srcset="/logo.svg, /logo.svg 1.5x, /logo.svg 2x" sizes=auto data-title=孔俊的知识库 data-alt=孔俊的知识库 class=logo style="background:url(/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'><span class=header-title-text>孔俊的知识库</span></a><span class=header-subtitle></span></div><nav><ul class=menu><li class=menu-item><a class=menu-link href=/posts/>文章</a></li><li class=menu-item><a class=menu-link href=/categories/>分类</a></li><li class=menu-item><a class=menu-link href=/tags/>标签</a></li><li class=menu-item><a class=menu-link href=/archives/>归档</a></li><li class=menu-item><a class=menu-link href=/about/>关于我</a></li><li class="menu-item delimiter"></li><li class="menu-item theme-switch" title=切换主题><i class="fa-solid fa-adjust fa-fw" aria-hidden=true></i></li></ul></nav></div></header><header class="mobile animate__faster" id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title=孔俊的知识库><img loading=lazy src=/logo.svg srcset="/logo.svg, /logo.svg 1.5x, /logo.svg 2x" sizes=auto data-title=/logo.svg data-alt=/logo.svg class=logo style="background:url(/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'><span class=header-title-text>孔俊的知识库</span></a><span class=header-subtitle></span></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><nav><ul class=menu id=menu-mobile><li class=menu-item><a class=menu-link href=/posts/>文章</a></li><li class=menu-item><a class=menu-link href=/categories/>分类</a></li><li class=menu-item><a class=menu-link href=/tags/>标签</a></li><li class=menu-item><a class=menu-link href=/archives/>归档</a></li><li class=menu-item><a class=menu-link href=/about/>关于我</a></li><li class="menu-item menu-system"><span class="menu-system-item theme-switch" title=切换主题><i class="fa-solid fa-adjust fa-fw" aria-hidden=true></i></span></li></ul></nav></div></header><main class=container><aside class=toc id=toc-auto><h2 class=toc-title>目录&nbsp;<i class="toc-icon fa-solid fa-angle-down fa-fw" aria-hidden=true></i></h2><div class=toc-content id=toc-content-auto></div></aside><aside class=aside-custom></aside><article class="page single"><div class=header><h1 class="single-title animate__animated animate__flipInX"><span title=转载 class=icon-repost><i class="fa-solid fa-share fa-fw" aria-hidden=true></i></span><span>【译】拨开 Linux 平均负载的谜团</span></h1><p class="single-subtitle animate__animated animate__fadeIn">Linux Load Averages: Solving the Mystery</p></div><div class=post-meta><div class=post-meta-line><span class=post-author><span class=author><i class="fa-solid fa-user-circle" aria-hidden=true></i>
孔俊</span></span>
<span class=post-category>收录于 <a href=/categories/linux/><i class="fa-regular fa-folder fa-fw" aria-hidden=true></i> Linux</a></span></div><div class=post-meta-line><span title="发布于 2022-09-27 14:27:44"><i class="fa-regular fa-calendar-alt fa-fw me-1" aria-hidden=true></i><time datetime=2022-09-27>2022-09-27</time></span>&nbsp;<span title="更新于 2022-09-27 14:27:44"><i class="fa-regular fa-edit fa-fw me-1" aria-hidden=true></i><time datetime=2022-09-27>2022-09-27</time></span>&nbsp;<span><i class="fa-solid fa-pencil-alt fa-fw me-1" aria-hidden=true></i>约 10015 字</span>&nbsp;<span><i class="fa-regular fa-clock fa-fw me-1" aria-hidden=true></i>预计阅读 20 分钟</span>&nbsp;</div></div><div class="details toc" id=toc-static data-kept=false><div class="details-summary toc-title"><span>目录</span>
<span><i class="details-icon fa-solid fa-angle-right" aria-hidden=true></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><a href=#历史>历史</a></li><li><a href=#三个数字>三个数字</a></li><li><a href=#linux-不可中断任务>Linux 不可中断任务</a></li><li><a href=#搜索古代-linux-补丁>搜索古代 Linux 补丁</a></li><li><a href=#不可中断状态的起源>不可中断状态的起源</a></li><li><a href=#今天的不可中断状态>今天的不可中断状态</a></li><li><a href=#测量非中断任务>测量非中断任务</a></li><li><a href=#分解-linux-平均负载>分解 Linux 平均负载</a></li><li><a href=#理解-linux-平均负载>理解 Linux 平均负载</a></li><li><a href=#什么是好的或坏的平均负载>什么是”好”的或“坏”的平均负载？</a></li><li><a href=#更好的指标>更好的指标</a></li><li><a href=#总结>总结</a></li><li><a href=#参考资料>参考资料</a></li></ul></nav></div></div><div class=content id=content><p>平均负载（<em>load averages</em>）是一个很关键的指标——我所在的公司基于平均负载和其他指标，花费数百万去自动伸缩云实例——但在 Linux 上存在许多和平均负载相关的谜题。Linux 平均负载不仅追踪运行态（<em>runnable</em>）任务，也追踪处于不可中断休眠状态（<em>uninterruptible sleep state</em>）的任务。为什么？从没有人给我解释过。在这篇文章中，我将解决这个谜团，并总结平均负载以供他人参考。</p><p>Linux 平均负载是“系统负载（<em>system load averages</em>）”，它通过系统中可运行的和不可中断睡眠的平均线程数量，来表征运行中的线程（任务）对系统资源的需求。平均负载衡量需求，这可能大于系统中正在处理的需求。大多数工具展示 1、5、15 分钟平均负载：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ uptime
</span></span><span class=line><span class=cl> 16:48:24 up  4:11,  <span class=m>1</span> user,  load average: 25.25, 23.40, 23.46
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>top - 16:48:42 up  4:12,  <span class=m>1</span> user,  load average: 25.25, 23.14, 23.37
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>$ cat /proc/loadavg
</span></span><span class=line><span class=cl>25.72 23.19 23.35 42/3411 <span class=m>43603</span>
</span></span></code></pre></div><p>一些解释：</p><ul><li><p>平均值为 0.0，说明你的系统空闲。</p></li><li><p>一分钟平均负载大于五或十五分钟平均负载，说明负载增大。</p></li><li><p>一分钟平均负载小于五或十五分钟平均负载，说明负载减小。</p></li><li><p>平均负载大于你的 CPU 数，那么你的系统<strong>可能</strong>（不一定）存在性能问题。</p></li></ul><p>这三个平均负载非常有用，你一眼就可以看出系统负载是在增大还是减小。在只需要单个平均负载值，比如云上的自动伸缩规则时，这些指标也非常有用。但是，如果没有别的辅助指标，很难更深入地理解他们代表了什么。如果只知道平均负载为 23-25 ，这没有任何意义。如果我们知道 CPU 数和运行的是 CPU 密集型任务，那么也许能看出些什么。</p><p>与其通过平均负载诊断性能问题，我更愿意使用其他指标。我将在后面的“更好的指标”一节讨论这些指标。</p><h2 id=历史>历史</h2><p>最初的平均负载只表征对 CPU 的需求：平均负载是正在运行以及等待运行的进程数。1973 年 8 月的 <a href=https://tools.ietf.org/html/rfc546 target=_blank rel="external nofollow noopener noreferrer">RFC 546<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a> <em>TENEX Load Averages</em> 定义了平均负载：</p><blockquote><p>[1] The TENEX load average is a measure of CPU demand. The load
average is an average of the number of runnable processes over a given
time period. For example, an hourly load average of 10 would mean
that (for a single CPU system) at any time during that hour one could
expect to see 1 process running and 9 others ready to run (i.e., not
blocked for I/O) waiting for the CPU.</p><hr><p>[1] TENEX 平均负载是衡量 CPU 需求量的指标。平均负载是一段时间内可运行进程
的平均数量。比如，一小时平均负载为 10 可能意味着（对于一个单 CPU 系统），
用户可以认为这一个小时内的任何时刻，都有 1 一个正在运行的进程和 9 个准备
就绪（比如，没有因 IO 阻塞）在等待 CPU 的进程。</p></blockquote><p><a href=https://tools.ietf.org/html/rfc546 target=_blank rel="external nofollow noopener noreferrer">ietf.org<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a> 上链接了一个于 1973 年手绘的平均负载折线图，这说明多年前人们就用平均负载监控系统。</p><p><figure><img src=images/rfc546.png alt="source: https://tools.ietf.org/html/rfc546"><figcaption>source: https://tools.ietf.org/html/rfc546</figcaption></figure></p><p>今天可以在网上找到这个古老操作系统的源代码，这里是上世纪 70 年代早期的 <a href=https://github.com/PDP-10/tenex target=_blank rel="external nofollow noopener noreferrer">TENEX<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a> 系统的 DEC 汇编代码节选：</p><pre tabindex=0><code class=language-asm6502 data-lang=asm6502>NRJAVS==3               ;NUMBER OF LOAD AVERAGES WE MAINTAIN
GS RJAV,NRJAVS          ;EXPONENTIAL AVERAGES OF NUMBER OF ACTIVE PROCESSES
[...]
;UPDATE RUNNABLE JOB AVERAGES

DORJAV: MOVEI 2,^D5000
        MOVEM 2,RJATIM          ;SET TIME OF NEXT UPDATE
        MOVE 4,RJTSUM           ;CURRENT INTEGRAL OF NBPROC+NGPROC
        SUBM 4,RJAVS1           ;DIFFERENCE FROM LAST UPDATE
        EXCH 4,RJAVS1
        FSC 4,233               ;FLOAT IT
        FDVR 4,[5000.0]         ;AVERAGE OVER LAST 5000 MS
[...]
;TABLE OF EXP(-T/C) FOR T = 5 SEC.

EXPFF:  EXP 0.920043902 ;C = 1 MIN
        EXP 0.983471344 ;C = 5 MIN
        EXP 0.994459811 ;C = 15 MIN
</code></pre><p>这是今天的 <a href=https://github.com/torvalds/linux/blob/master/include/linux/sched/loadavg.h target=_blank rel="external nofollow noopener noreferrer">Linux<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a> 源代码节选（include/linux/sched/loadavg.h）：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#define EXP_1           1884            </span><span class=cm>/* 1/exp(5sec/1min) as fixed-point */</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#define EXP_5           2014            </span><span class=cm>/* 1/exp(5sec/5min) */</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#define EXP_15          2037            </span><span class=cm>/* 1/exp(5sec/15min) */</span><span class=cp>
</span></span></span></code></pre></div><p>Linux 也硬编码 1、5 和 15 分钟常量。</p><p>许多旧系统也有类似的平均负载指标 ，比如 <a href=http://web.mit.edu/Saltzer/www/publications/instrumentation.html target=_blank rel="external nofollow noopener noreferrer">Multics<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a> 有指数调度队列平均值。</p><h2 id=三个数字>三个数字</h2><p>这三个数字是 1、5、15 分钟平均负载。实际上，平均负载并不是平均值，也不是 1、5、15 分钟内的负载值。就像我们从源代码看到的那样，1、5、15 分钟只是公式中的常量，用来计算每 5 秒负载的指数阻尼移动和（<em>exponentially-damped moving sum</em>）。计算出的 1、5、15 分钟平均负载所反映的负载远超 1、5、15 分钟。</p><p>如果你有一个空闲的系统，然后运行一个单线程 CPU 密集型负载（一个死循环的单线程），60 秒后一分钟平均负载会是多少？如果它只是一个平均值，那它应该是 1.0。这里是一个实验，结果如下：</p><p><figure><img src=images/loadavg.png alt="Load average experiment to visualize exponential damping"><figcaption>Load average experiment to visualize exponential damping</figcaption></figure></p><p>所谓的“一分钟平均负载”在一分钟后只到达 0.62。想了解更多公式和类似实验的话可以阅读 Dr. Neil Gunther 的文章 <a href=http://www.teamquest.com/import/pdfs/whitepaper/ldavg1.pdf target=_blank rel="external nofollow noopener noreferrer">How It Works<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a> 以及 Linux 源代码 <a href=https://github.com/torvalds/linux/blob/master/kernel/sched/loadavg.c target=_blank rel="external nofollow noopener noreferrer">loadavg.c<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a> 中的注释。</p><blockquote><p><strong>译者注</strong></p><p>指数阻尼移动和（<em>exponentially-damped moving sum</em>）是一种数学方法，经常用来处理和时间相关的数据。它用于估计变量的局部均值，使得变量的当前值与一段时间内的历史取值有关。从几何上看，它使得曲线更加平滑。</p><p>维基百科 <a href=https://en.wikipedia.org/wiki/Exponential_smoothing target=_blank rel="external nofollow noopener noreferrer">Exponential smoothing<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a> 中的公式如下，$\alpha$ 称为平滑因子：</p><p>$$
s_0=x_0
$$
$$
s_t=\alpha x_t+(1-\alpha)s_{t-1}, t>0
$$</p><p>直观地看，就是让变量的当前值不仅取决于上一时刻的值，还受更久之前的值的影响。</p><p>kernel/sched/loadavg.c 注释中描述了平均负载公式：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm> * Global load-average calculations
</span></span></span><span class=line><span class=cl><span class=cm> *
</span></span></span><span class=line><span class=cl><span class=cm> * We take a distributed and async approach to calculating the global load-avg
</span></span></span><span class=line><span class=cl><span class=cm> * in order to minimize overhead.
</span></span></span><span class=line><span class=cl><span class=cm> *
</span></span></span><span class=line><span class=cl><span class=cm> * The global load average is an exponentially decaying average of nr_running +
</span></span></span><span class=line><span class=cl><span class=cm> * nr_uninterruptible.
</span></span></span><span class=line><span class=cl><span class=cm> *
</span></span></span><span class=line><span class=cl><span class=cm> * Once every LOAD_FREQ:
</span></span></span><span class=line><span class=cl><span class=cm> *
</span></span></span><span class=line><span class=cl><span class=cm> *   nr_active = 0;
</span></span></span><span class=line><span class=cl><span class=cm> *   for_each_possible_cpu(cpu)
</span></span></span><span class=line><span class=cl><span class=cm> *    nr_active += cpu_of(cpu)-&gt;nr_running + cpu_of(cpu)-&gt;nr_uninterruptible;
</span></span></span><span class=line><span class=cl><span class=cm> *
</span></span></span><span class=line><span class=cl><span class=cm> *   avenrun[n] = avenrun[0] * exp_n + nr_active * (1 - exp_n)
</span></span></span><span class=line><span class=cl><span class=cm> *
</span></span></span><span class=line><span class=cl><span class=cm> * ...
</span></span></span><span class=line><span class=cl><span class=cm> *
</span></span></span><span class=line><span class=cl><span class=cm> */</span>
</span></span></code></pre></div><p>其中<code>avenrun</code>是平均负载值数组，元素是 1、5、15 分钟平均负载。公式中的 <code>avenrun[0]</code>指上次平均负载，<code>exp_n</code>是 1、5、15 分钟对应的魔数（文章前面有引用）。</p><p><code>LOAD_FREQ</code>定义在 include/linux/sched/loadacg.c：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#define LOAD_FREQ    (5*HZ+1)    </span><span class=cm>/* 5 sec intervals */</span><span class=cp>
</span></span></span></code></pre></div><p>Linux 每 5 秒更新一次平均负载。</p><p>在此公式下，1、5、15 分钟平均负载是同一公式、不同常量计算出的三个值，而不是真的“前 X 分钟平均负载”，更不是真的平均值。</p></blockquote><h2 id=linux-不可中断任务>Linux 不可中断任务</h2><p>平均负载第一次出现在 Linux 时，它和其他操作系统中的平均负载一样反映对 CPU 的需求。后续 Linux 版本的平均负载不仅包括运行态的任务，还包括在不可中断（<em>uninterruptible</em>）状态（<code>TASK_UNINTERRUPTIBLE</code>或<code>nr_uninterruptible</code>）的任务。此状态通常由希望避免被信号中断的代码使用，包括阻塞于磁盘 IO 或某些锁的任务。你可能之前就见过它们，它们在<code>ps</code>和<code>top</code>命令中展示为 D 状态。ps(1) man page 称它为”不可中断睡眠（通常是由于 IO 操作）”。</p><p>添加了不可中断状态意味着 Linux 平均工作负载会因为磁盘（或 NFS）IO 增大，而不只是 CPU 需求。对于任何熟悉其他操作系统上的衡量“对 CPU 需求”的平均负载的人来说，为什么 Linux 平均负载包括这个状态是第一个令人迷惑的问题。</p><p><strong>为什么？</strong> 为什么 Linux 要这样做？</p><p>有无数关于平均负载的文章，其中许多都指出了 Linux <code>nr_uninterruptible</code> 的陷阱。但我从未看到谁解释了为什么 Linux 平均负载要包括它，甚至连猜测的都没。我猜测这是为了让平均负载放映更加一般意义上的需求，而不只是 CPU 需求。</p><h2 id=搜索古代-linux-补丁>搜索古代 Linux 补丁</h2><p>弄清楚为什么平均负载的含义在 Linux 中发生了变化很简单，阅读 Linux 相关文件的 Git 提交记录和变更描述即可。我检查了 <a href=https://github.com/torvalds/linux/commits/master/kernel/sched/loadavg.c target=_blank rel="external nofollow noopener noreferrer">loadavg.c<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a> 的提交记录，但修改了平均负载含义的提交早于这个文件，loadavg.c 是从更古老的文件中的代码创建的。我还检查了别的文件，但是这条路更加艰难，这些代码分布在不同的文件中。为了走捷径，我在整个 Linux github 代码仓库上执行<code>git log -p</code>，在足足 4GB 文本中从后往前寻找这些代码第一次出现的地方。然而，这又是一条死胡同。Linux 代码库最早的记录也只能追溯到 2005 年，那一年 Linus 导入了 Linux 2.6.12-rc2 版本，但我要找的修改早于这一版本。</p><p>存在许多 Linux 历史版本的代码仓库（<a href=https://git.kernel.org/pub/scm/linux/kernel/git/tglx/history.git target=_blank rel="external nofollow noopener noreferrer">这个<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a> 和 <a href=https://kernel.googlesource.com/pub/scm/linux/kernel/git/nico/archive/ target=_blank rel="external nofollow noopener noreferrer">这个<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a>），但是里面也没有我想找变更描述。为了最起码弄清楚这个变化是什么时候引入的，我搜索了 <a href=https://www.kernel.org/pub/linux/kernel/Historic/v0.99/ target=_blank rel="external nofollow noopener noreferrer">kernel.org<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a> 上的归档（<em>tarball</em>），发现在 Linux 0.99.15 修改了平均负载的含义，0.99.13 没有修改，但 0.99.14 版本丢失了。我又从别的地方发现了这一点，确认这个变化由 1993 年 11 月的 Linux 0.99 patchlevel 14 引入。我希望 Linus 写的 0.99.14 发版公告能解释这个变化，但是这也是死胡同。</p><blockquote><p>&ldquo;Changes to the last official release (p13) are too numerous to mention (or even to remember)&mldr;&rdquo; – Linus</p><hr><p>“对上一个正式版本 (p13) 的更改太多了，无法提及（甚至无法记住）&mldr;&mldr;” – Linus</p></blockquote><p>他提到了主要变更，但是没有提及平均负载含义的变化。</p><p>根据这个日期，我搜索了<a href=http://lkml.iu.edu/hypermail/linux/kernel/index.html target=_blank rel="external nofollow noopener noreferrer">内核邮件列表归档<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a> 想找到具体的 patch，然而可以找到的最早邮件来自 1995 年 6 月，当时一位系统管理员写道：</p><blockquote><p>&ldquo;While working on a system to make these mailing archives scale more
effecitvely I accidently destroyed the current set of archives (ah
whoops).&rdquo;</p><hr><p>在扩容的过程中我不小心删除了一部分归档（哎呀）</p></blockquote><p>我倒霉得就像被诅咒了一样。幸运的是，我找到了一些从服务器备份中恢复出来的更古老的 Linux 开发列表邮件归档，就是那种以文件摘要（digest，即文件的哈希值）为名的 tarball。我搜索了超过 6000 个 tarball，其中包含超过 98000 封邮件，里面有 30000 封邮件来自 1993 年。所有的邮件似乎都缺了点什么，看起来原始的补丁描述已经彻底丢失了，Linux 为什么这样做将永远是个谜题。</p><h2 id=不可中断状态的起源>不可中断状态的起源</h2><p>我最后很幸运地在 <a href=http://oldlinux.org/Linux.old/mail-archive/ target=_blank rel="external nofollow noopener noreferrer">oldlinux.org<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a> 找到一封 1993 年的压缩过的邮件中发现了这个变更（<em>change</em>），这封邮件如下：</p><pre tabindex=0><code>From: Matthias Urlichs &lt;urlichs@smurf.sub.org&gt;
Subject: Load average broken ?
Date: Fri, 29 Oct 1993 11:37:23 +0200


The kernel only counts &#34;runnable&#34; processes when computing the load average.
I don&#39;t like that; the problem is that processes which are swapping or
waiting on &#34;fast&#34;, i.e. noninterruptible, I/O, also consume resources.

It seems somewhat nonintuitive that the load average goes down when you
replace your fast swap disk with a slow swap disk...

Anyway, the following patch seems to make the load average much more
consistent WRT the subjective speed of the system. And, most important, the
load is still zero when nobody is doing anything. ;-)

--- kernel/sched.c.orig Fri Oct 29 10:31:11 1993
+++ kernel/sched.c  Fri Oct 29 10:32:51 1993
@@ -414,7 +414,9 @@
    unsigned long nr = 0;

    for(p = &amp;LAST_TASK; p &gt; &amp;FIRST_TASK; --p)
-       if (*p &amp;&amp; (*p)-&gt;state == TASK_RUNNING)
+       if (*p &amp;&amp; ((*p)-&gt;state == TASK_RUNNING) ||
+                  (*p)-&gt;state == TASK_UNINTERRUPTIBLE) ||
+                  (*p)-&gt;state == TASK_SWAPPING))
            nr += FIXED_1;
    return nr;
 }
--
Matthias Urlichs        \ XLink-POP N|rnberg   | EMail: urlichs@smurf.sub.org
Schleiermacherstra_e 12  \  Unix+Linux+Mac     | Phone: ...please use email.
90491 N|rnberg (Germany)  \   Consulting+Networking+Programming+etc&#39;ing      42
</code></pre><blockquote><p><strong>译者注</strong></p><p>邮件大意如下：</p><p>内核计算平均负载时只考虑“可运行”的进程，我不喜欢这样。问题在于当进程正在换出或在等待“快”IO时，比如不可中断 IO 仍然在消耗资源。</p><p>当你把很快的硬盘换成更慢的硬盘后，平均负载会下降，这看起来就不符合直觉。</p><p>无论如何，下面的补丁让平均负载和系统性能更加匹配。更重要的是，如果没有人做任何事，平均负载仍然是 0。</p></blockquote><p>阅读 24 年前的这一变化背后的想法真是太神奇了。</p><p>这封邮件证明了平均负载的改变确实是为了反映对其它系统资源的需求，而不仅仅对 CPU。Linux 把它从“CPU 平均负载”改成了“系统平均负载”。</p><p>他（Matthias Urlichs）举的使用低速交换磁盘（<em>slow swap disk</em>）的例子很有道理：降低系统性能，系统上的需求（通过估计正在运行和排队的任务数）应该增加。然而，因为平均负载只追踪运行态的任务，不追踪被换出的任务，平均负载反而会降低。Matthias 认为这不符合直觉，所以他修了这个 bug。</p><h2 id=今天的不可中断状态>今天的不可中断状态</h2><p>但是，Linux 平均负载是否有时会高到超过磁盘 I/O 可以解释的程度？是的，尽管我猜测这是因为现在存在许多在 1993 年不存在的使用<code>TASK_UNINTERRUPTIBLE</code>的代码路径。Linux 0.99.14 只有 13 处代码直接设置<code>TASK_UNINTERRUPTIBLE</code>或<code>TASK_SWAPPING</code>（后续版本移除了“交换中”状态）。今天，Linux 4.12 中有接近 400 处代码设置<code>TASK_UNINTERRUPTIBLE</code>，比如一些锁原语（<em>lock primitives</em>）。其中有些代码路径可能被不应该包含在平均负载中。下一次我发现平均负载过高，我会查看是否是这种情况以及能否修复它。</p><p>我发邮件给 Matthias，问他 24 年后怎么看待平均负载含义的变化。他一个小时后回复了我（就像我 <a href=https://twitter.com/brendangregg/status/891716419892551680 target=_blank rel="external nofollow noopener noreferrer">Twitter<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a> 上提到的那样）：</p><blockquote><p>&ldquo;The point of &ldquo;load average&rdquo; is to arrive at a number relating how busy
the system is from a human point of view. TASK_UNINTERRUPTIBLE means
(meant?) that the process is waiting for something like a disk read
which contributes to system load. A heavily disk-bound system might be
extremely sluggish but only have a TASK_RUNNING average of 0.1, which
doesn&rsquo;t help anybody.&rdquo;</p><hr><p>平均负载的意义在于给出一个从用户侧看来可以表示系统有多繁忙的数值。TASK_UNINTERRUPTIBLE （也许）意味着进程正在等待磁盘读取之类的会增加系统负载的事件。一个磁盘 IO 密集型系统可能非常慢，但只考虑 TASK_RUNNING 的平均负载却只有 0.1，这对任何人都没帮助。</p></blockquote><p>（得到他如此快速的回应，真的让我一天都很开心。感谢！）</p><p>Matthias 仍然认为这是有道理的，至少在当年<code>TASK_UNINTERRUPTIBLE</code>的语义下是有道理的。</p><p>但是今天的<code>TASK_UNINTERRUPTIBLE</code>匹配更多的东西（<strong>译者注</strong>：指有更多设置<code>TASK_UNINTERRUPTIBLE</code>的代码路径）。我们应该把平均负载修改为对 CPU 和磁盘的需求吗？Linux 调度器维护者 Peter Zijstra 给了我一个聪明的方案：将<code>task_struct->in_iowait</code>而非<code>TASK_UNINTERRUPTIBLE</code>包含在平均负载中，以便让它更匹配磁盘 IO。这种方案带来了其他问题。这真的是我们想要的吗？我们应该用线程的需求衡量对系统资源的需求，还是用对物理资源的需求来衡量？如果是前者，等待非中断的锁（<em>uninterruptible lock</em>）应该被算进平均负载中，线程需要这些资源，系统不是空闲状态。所以，Linux 平均负载可能已经按我们期待的那样工作。</p><p>为了更好地理解非中断代码路径，我想找一个办法测量他们。我们来看一个不同的例子，计算花在非中断代码路径上的时间，然后看看这一切是否讲得通。</p><h2 id=测量非中断任务>测量非中断任务</h2><p>下面的 <a href=http://www.brendangregg.com/blog/2016-01-20/ebpf-offcpu-flame-graph.html target=_blank rel="external nofollow noopener noreferrer">Off-CPU 火焰图<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a> 展示了生产环境服务器上 60 秒内的<code>TASK_UNINTERRUPTIBLE</code>状态的函数调用栈（<a href=/posts/2022/09/27/images/out.offcputime_unint02.svg>SVG</a>）。它提供了许多非中断代码路径的例子：</p><p><object data=images/out.offcputime_unint02.svg type=image/svg+xml alt="Kernel Uninterruptible Off-CPU Flame Graph (60 secs)" data-align=center></object></p><p>如果你是刚接触 off-CPU 火焰图的新人，既可以尝试单击帧放大，查看完整的函数调用栈（显示为一个由帧构成的塔）。X 轴方向的大小正比与阻塞时间，排列次序（从左往右）没有实际意义。off-CPU 函数调用栈显示为蓝色（on-CPU 栈用暖色调），通过随机的饱和度区分不同的帧。</p><p>我使用我的 <a href=https://github.com/iovisor/bcc target=_blank rel="external nofollow noopener noreferrer">bcc<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a>（这个工具需要 Linux 4.8+ 支持的 eBPF 特性）中的 offcputime 以及我的<a href=https://github.com/brendangregg/FlameGraph target=_blank rel="external nofollow noopener noreferrer">火焰图<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a>)软件：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=c1># ./bcc/tools/offcputime.py -K --state 2 -f 60 &gt; out.stacks</span>
</span></span><span class=line><span class=cl><span class=c1># awk &#39;{ print $1, $2 / 1000 }&#39; out.stacks | ./FlameGraph/flamegraph.pl --color=io --countname=ms &gt; out.offcpu.svg</span>
</span></span></code></pre></div><blockquote><p><strong>译者注</strong></p><p>以上命令需要下载对应工具，python 解释器及有关 pip 包，root 权限。</p></blockquote><p>我用 awk 把输出中的微秒转换为毫秒。offcputime 脚本的<code>--state 2</code>匹配<code>TASK_UNINTERRUPTIBLE</code>（见 sched.h）。Facebook 的 Josef Bacik 首次用他编写的 <a href=https://github.com/josefbacik/kernelscope target=_blank rel="external nofollow noopener noreferrer">kernelscope<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a> 做了这件事，他也使用了 bcc 和火焰图。在我举的例子中，只展示了内核栈，但 offcputime.py 也支持打印用户堆栈。</p><p>上面的火焰图表示内核 60s 内在不可中断睡眠中消耗了 926ms。这只让平均负载增加了 0.015。这是花在一些 cgroup 相关的代码路径中的时间，这个服务器没有做太多磁盘 IO 操作。</p><blockquote><p><strong>译者注</strong></p><p>平均负载增加 0.015 指，当平均负载到达稳态时，926ms/60s=0.015，为平均负载贡献了 0.015。后面的同理。</p></blockquote><p>这里有一个更有意思的例子，这次观测耗时 10 秒（<a href=out.offcputime_unint01.svg>SVG</a>）：</p><p><object data=images/out.offcputime_unint01.svg type=image/svg+xml alt="Kernel Uninterruptible Off-CPU Flame Graph (10 secs)" data-align=center></object></p><p>右边宽的调用栈表示<code>systemd-journal</code>在<code>proc_pid_cmdline_read()</code>（读取 /proc/PID/cmdline）中阻塞并为平均负载贡献了 0.07（732ms/10s）。左边有一个更宽的页错误（<em>page fault</em>）调用栈，结束于<code>rwsem_down_read_failed</code>，为平均负载贡献了 (2307ms+694ms)/1s = 0.23。我已经用火焰图搜索功能把这两个帧高亮为粉红色。</p><blockquote><p><strong>译者注</strong></p><p>systemd-journal 和 page_fault 都调用了 rwsem_down_read_failed，因此火焰图中有两个 rwsem_down_read_failed 帧。计算对平均负载的贡献时，两个都算上了。</p></blockquote><p><code>rwsem_down_read_failed</code>的节选如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl>   <span class=cm>/* wait to be given the lock */</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=p>(</span><span class=nb>true</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>set_task_state</span><span class=p>(</span><span class=n>tsk</span><span class=p>,</span> <span class=n>TASK_UNINTERRUPTIBLE</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>waiter</span><span class=p>.</span><span class=n>task</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=nf>schedule</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span></code></pre></div><p>这段获取锁的代码使用了<code>TASK_UNINTERRUPTIBLE</code>。Linux 为获取锁的函数提供了可中断与不可中断的两个版本，如<code>mutex_lock()</code>和<code>mutex_lock_interruptible()</code>，以及信号量的<code>down()</code>和<code>down_interruptible()</code>。可中断版本允许任务被信号中断，然后在获取到锁之前唤醒并处理它。在不可中断锁中睡眠的时间通常不长，不会对平均负载造成太大影响，但这里为平均负载增加了 0.30。如果不可中断睡眠让平均负载增大得太多了，那就值得分析是否可以减少锁争用，就像我研究<code>systemd-journal</code>和<code>proc_pid_cmdline_read()</code>那样！这可以提高系统性能并降低平均负载。</p><p>这些代码路径被包含在平均负载中有道理吗？是的，这是有道理的。这些线程正在做他们的工作，碰巧阻塞在锁上，他们并不空闲。他们在向系统请求资源，尽管是软件资源而非硬件资源。</p><h2 id=分解-linux-平均负载>分解 Linux 平均负载</h2><p>可以把 Linux 平均负载值完全分解开吗？这里有一个例子：在一个空闲的 8 核系统上，我执行<code>tar</code>来归档（<em>archive</em>）许多未缓存的文件。这花了几分钟，大时间被阻塞在磁盘读取上。这里是从不同终端窗口收集到的统计数据：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>terma$ pidstat -p <span class=sb>`</span>pgrep -x tar<span class=sb>`</span> <span class=m>60</span>
</span></span><span class=line><span class=cl>Linux 4.9.0-rc5-virtual <span class=o>(</span>bgregg-xenial-bpf-i-0b7296777a2585be1<span class=o>)</span>     08/01/2017  _x86_64_    <span class=o>(</span><span class=m>8</span> CPU<span class=o>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>10:15:51 PM   UID       PID    %usr %system  %guest    %CPU   CPU  Command
</span></span><span class=line><span class=cl>10:16:51 PM     <span class=m>0</span>     <span class=m>18468</span>    2.85   29.77    0.00   32.62     <span class=m>3</span>  tar
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>termb$ iostat -x <span class=m>60</span>
</span></span><span class=line><span class=cl><span class=o>[</span>...<span class=o>]</span>
</span></span><span class=line><span class=cl>avg-cpu:  %user   %nice %system %iowait  %steal   %idle
</span></span><span class=line><span class=cl>           0.54    0.00    4.03    8.24    0.09   87.10
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Device:         rrqm/s   wrqm/s     r/s     w/s    rkB/s    wkB/s avgrq-sz avgqu-sz   await r_await w_await  svctm  %util
</span></span><span class=line><span class=cl>xvdap1            0.00     0.05   30.83    0.18   638.33     0.93    41.22     0.06    1.84    1.83    3.64   0.39   1.21
</span></span><span class=line><span class=cl>xvdb            958.18  1333.83 2045.30  499.38 60965.27 63721.67    98.00     3.97    1.56    0.31    6.67   0.24  60.47
</span></span><span class=line><span class=cl>xvdc            957.63  1333.78 2054.55  499.38 61018.87 63722.13    97.69     4.21    1.65    0.33    7.08   0.24  61.65
</span></span><span class=line><span class=cl>md0               0.00     0.00 4383.73 1991.63 121984.13 127443.80    78.25     0.00    0.00    0.00    0.00   0.00   0.00
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>termc$ uptime
</span></span><span class=line><span class=cl> 22:15:50 up <span class=m>154</span> days, 23:20,  <span class=m>5</span> users,  load average: 1.25, 1.19, 1.05
</span></span><span class=line><span class=cl><span class=o>[</span>...<span class=o>]</span>
</span></span><span class=line><span class=cl>termc$ uptime
</span></span><span class=line><span class=cl> 22:17:14 up <span class=m>154</span> days, 23:21,  <span class=m>5</span> users,  load average: 1.19, 1.17, 1.06
</span></span></code></pre></div><p>我也收集了不可中断状态的 off-CPU 火焰图（<a href=/posts/2022/09/27/images/out.offcputime_unint08.svg>SVG</a>）。</p><p><object data=images/out.offcputime_unint08.svg type=image/svg+xml alt="Kernel Uninterruptible Off-CPU Flame Graph (60 secs)" data-align=center></object></p><p>最后的一分钟平均负载为 1.19。让我分解它：</p><ul><li><p>0.33 来自 tar 消耗的 CPU 时间（pidstat)</p></li><li><p><strong>推测</strong> 0.67 来自 tar 的不可中断磁盘读取（off-CPU 火焰图计算得到 0.69，我怀疑这是因为开始收集得稍微有点晚，跨越了不同的时间范围）</p></li><li><p>0.04 来自其他 CPU 消费者（iostat user + system 减去从 pidstat 看到的 tar CPU 时间）</p></li><li><p>0.11 来自内核 workers 不可中断磁盘 IO 和刷新磁盘。</p></li></ul><blockquote><p><strong>译者注</strong></p><p>分别解释上面的计算过程：</p><ul><li><p>从 pidstat 看到 tar 运行在 CPU 3 上，有 32.62% 的时间是 CPU 时间，即 tar CPU 时间让平均负载增加了 0.33。</p></li><li><p>从火焰图看是 0.69，0.67 是作者的推测。火焰图中 tar 帧用时 41164ms，占取样时间范围（60s) 的 0.686，约等于 0.69。即 tar 不可中断状态让平均负载增加了 0.69。</p></li><li><p>iostat 显示的 CPU 时间比例是整个系统（8核）的，pidstat 显示的是一个核的。因此 pidstat 显示的 32.62% 对应整个系统的 4.0775%，iostat user+system 为 4.57%，总 CPU 时间减去 tar CPU 时间得到 4.077%，约等于 0.04。</p></li><li><p>kworker 是一种专用于中断处理的内核线程。火焰图中两个帧占取样时间比例为 (3684ms+3102ms)/60s = 0.11。</p></li></ul></blockquote><p>上面加起来总共只有 1.15，仍然缺了 0.04。其中一些可能是舍入或测量误差，但大部分是因为平均工作负载是指数阻尼移动和，而这里使用的其他平均值（pidstat、iostat）是普通的平均值。1.19 之前的平均负载是 1.25，这说明有什么东西在拖累平均负载的增长。到底是多少呢？从上面的图片可以看到，在 60s 时，一分钟平均负载值有 62% 来自于该时刻，其余来自历史值。所以 0.62 x 1.15 + 0.38 x 1.25 = 1.18。这和 uptime 报告的平均负载非常接近。</p><blockquote><p><strong>译者注</strong></p><p>这一段很难理解。</p><p>1.19 之前的平均负载为 1.25，平均负载下降说明系统负载变小了，因此作者说”有什么东西拖累了平均负载的增长“。</p><p>后面的计算似乎有问题，作者应该是想套用平均负载公式，其中 1.15 是当前的值，1.25 是历史值。但是作者似乎取了错误的平滑因子。</p><p>尽管如此，作者的意图很清晰：</p><ul><li><p>平均工作负载是计算得到的</p></li><li><p>其他工具报告的指标未必和平均工作负载匹配</p></li></ul></blockquote><p>这个系统中只有一个线程（tar）和很少的其它线程（内核 worker 线程）在工作，1 分钟平均负载为 1.19，这是讲的通的。如果只测量”CPU 平均负载“，系统的平均负载为 0.37（从 mpstat 的报告中推测），这只对 CPU 资源是正确的，这掩盖了有多个线程要工作的事实。</p><blockquote><p><strong>译者注</strong></p><p>这里指只考虑 CPU，忽略了还有别的暂时阻塞的工作线程。</p></blockquote><p>我希望这个例子成功展示了平均负载真的意味着一些事情（CPU+不可中断状态），并且让你弄明白它。</p><h2 id=理解-linux-平均负载>理解 Linux 平均负载</h2><p>一开始我接触的操作系统就把平均负载规定为 CPU 平均负载，所以 Linux 版本的平均负载总是让我感到困惑。也许平均负载真正的问题在于，”平均负载“这个词和“IO”一样模糊，到底是哪种 IO？磁盘 IO？文件系统 IO？还是网络 IO？同样的，平均负载是哪种负载？CPU 平均负载？系统平均负载？澄清到底什么是平均负载才能真正理解它：</p><ul><li><p>在 Linux 中，平均负载是“<strong>系统平均负载</strong>”，衡量整个系统中正在工作或等待工作（CPU、磁盘、不可中断锁）的进程数。这种平均负载的优点是：考虑到了对各种资源的需求。</p></li><li><p>在其他操作系统中，平均负载只是“<strong>CPU 平均负载</strong>”，衡量正在 CPU 上运行的或可运行的线程数。这种平均负载的优点是：只考虑 CPU，更容易理解。</p></li></ul><p>注意，还有另外一种可能的类型：“<strong>物理资源平均负载</strong>”，只考虑 CPU 和磁盘这样的物理资源。</p><p>也许有一天我们会给 Linux 添加额外的平均负载，让用户选择使用何种类型的平均负载：一个单独的”CPU 平均负载“、”磁盘平均负载“、”网络平均负载“等等。或者，我们直接使用别的指标。</p><h2 id=什么是好的或坏的平均负载>什么是”好”的或“坏”的平均负载？</h2><p><figure><img src=images/vectorloadavg.png alt="Load averages measured in a modern tool"><figcaption>Load averages measured in a modern tool</figcaption></figure></p><p>一些人发现某些阈值适用于他们的系统和工作负载：当他们的平均负载超过 X 时，应用延迟很高并且客户开始抱怨。但是这里并没有一种普世的规则。</p><p>许多人说，用 CPU 平均负载除以你的 CPU 数，如果这个比值超过 1.0，你的系统就在满负荷运转，这会导致性能问题。但这种说法非常模糊。平均负载是一个长期平均值（至少一分钟），这会隐藏很多问题。一个比值为 1.5 的系统可能运行良好，但另一个比值一分钟内飙升到 1.5 的系统应该性能不佳。</p><p>我曾经管理过一个双 CPU 的邮件服务器，这个服务器 CPU 负载长期在 11 到 16 之间（比值在 5.5 到 8）。邮件服务器的延迟是可接受的，没人会抱怨这个。这是一个极端的例子，大多数系统的平均负载/CPU 比值为 2 时就有性能问题了。</p><p>因为 Linux 系统平均负载包含了不同的资源，语义更加模糊，所以你不能简单地用它除以 CPU 数。比较平均负载的相对大小更加有用：如果你知道系统在平均负载为 20 时运行良好，此时系统平均负载为 40，那你就该去研究别的指标弄清楚到底发生了什么。</p><h2 id=更好的指标>更好的指标</h2><p>当 Linux 平均负载增大时，你只知道任务对系统资源的需求增大了，但不知道究竟是哪些需求。可以用别的指标弄清楚这一切，比如对于 CPU：</p><ul><li><p>每个 CPU 利用率：<code>mpstat -P ALL</code></p></li><li><p>每个进程 CPU 利用率：<code>top</code>、<code>pidstat 1</code>等</p></li><li><p>每个线程运行队列（调度器）延迟：例如 /proc/PID/schedstats、delaystats 和<code>perf sched</code>。</p></li><li><p>CPU 运行队列延迟：比如 /proc/schedstat、<code>perf sched</code>和我的 <a href=http://www.brendangregg.com/blog/2016-10-08/linux-bcc-runqlat.html target=_blank rel="external nofollow noopener noreferrer">runqlat<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a> <a href=https://github.com/iovisor/bcc target=_blank rel="external nofollow noopener noreferrer">bcc<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a>。</p></li><li><p>CPU 运行队列长度：比如使用<code>vmstat 1</code>中名为 r 的那一列，或者我的 unqlen bcc 工具。</p></li></ul><p>前两个是利用率指标，后面三个是饱和度指标。利用率指标可以用来标示工作负载类别，饱和度指标对定位性能问题非常有用。最好的 CPU 饱和度指标是运行队列（或调度器）延迟，即一个可运行的任务/线程等待被调度的时间。这些指标允许你估计性能问题的严重程度，比如一个线程花在调度器延迟上的时间占比。运行队列长度可以表明是否有问题，但是很难用来估计问题有多严重。</p><p>schedstats 是 Linux 4.6 的一个可调整参数，默认关闭。延迟记账（<em>delay account</em>）暴露了相同的调度器延迟指标，<a href=https://github.com/uber-common/cpustat target=_blank rel="external nofollow noopener noreferrer">cpustat<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a> 就使用了它。我建议把它添加到 <a href=https://github.com/hishamhm/htop/issues/665 target=_blank rel="external nofollow noopener noreferrer">htop<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a> 中以方便用户。简单地说，从文档未记录的 /proc/sched_debug 中获取等待时间（调度器延迟）指标：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ awk <span class=s1>&#39;NF &gt; 7 { if ($1 == &#34;task&#34;) { if (h == 0) { print; h=1 } } else { print } }&#39;</span> /proc/sched_debug
</span></span><span class=line><span class=cl>            task   PID         tree-key  switches  prio     wait-time             sum-exec        sum-sleep
</span></span><span class=line><span class=cl>         systemd     <span class=m>1</span>      5028.684564    <span class=m>306666</span>   <span class=m>120</span>        43.133899     48840.448980   2106893.162610 <span class=m>0</span> <span class=m>0</span> /init.scope
</span></span><span class=line><span class=cl>     ksoftirqd/0     <span class=m>3</span> 99071232057.573051   <span class=m>1109494</span>   <span class=m>120</span>         5.682347     21846.967164   2096704.183312 <span class=m>0</span> <span class=m>0</span> /
</span></span><span class=line><span class=cl>    kworker/0:0H     <span class=m>5</span> 99062732253.878471         <span class=m>9</span>   <span class=m>100</span>         0.014976         0.037737         0.000000 <span class=m>0</span> <span class=m>0</span> /
</span></span><span class=line><span class=cl>     migration/0     <span class=m>9</span>         0.000000   <span class=m>1995690</span>     <span class=m>0</span>         0.000000     25020.580993         0.000000 <span class=m>0</span> <span class=m>0</span> /
</span></span><span class=line><span class=cl>   lru-add-drain    <span class=m>10</span>        28.548203         <span class=m>2</span>   <span class=m>100</span>         0.000000         0.002620         0.000000 <span class=m>0</span> <span class=m>0</span> /
</span></span><span class=line><span class=cl>      watchdog/0    <span class=m>11</span>         0.000000   <span class=m>3368570</span>     <span class=m>0</span>         0.000000     23989.957382         0.000000 <span class=m>0</span> <span class=m>0</span> /
</span></span><span class=line><span class=cl>         cpuhp/0    <span class=m>12</span>      1216.569504         <span class=m>6</span>   <span class=m>120</span>         0.000000         0.010958         0.000000 <span class=m>0</span> <span class=m>0</span> /
</span></span><span class=line><span class=cl>          xenbus    <span class=m>58</span>  72026342.961752       <span class=m>343</span>   <span class=m>120</span>         0.000000         1.471102         0.000000 <span class=m>0</span> <span class=m>0</span> /
</span></span><span class=line><span class=cl>      khungtaskd    <span class=m>59</span> 99071124375.968195    <span class=m>111514</span>   <span class=m>120</span>         0.048912      5708.875023   2054143.190593 <span class=m>0</span> <span class=m>0</span> /
</span></span><span class=line><span class=cl><span class=o>[</span>...<span class=o>]</span>
</span></span><span class=line><span class=cl>         dockerd <span class=m>16014</span>    247832.821522   <span class=m>2020884</span>   <span class=m>120</span>        95.016057    131987.990617   2298828.078531 <span class=m>0</span> <span class=m>0</span> /system.slice/docker.service
</span></span><span class=line><span class=cl>         dockerd <span class=m>16015</span>    106611.777737   <span class=m>2961407</span>   <span class=m>120</span>         0.000000    160704.014444         0.000000 <span class=m>0</span> <span class=m>0</span> /system.slice/docker.service
</span></span><span class=line><span class=cl>         dockerd <span class=m>16024</span>       101.600644        <span class=m>16</span>   <span class=m>120</span>         0.000000         0.915798         0.000000 <span class=m>0</span> <span class=m>0</span> /system.slice/
</span></span><span class=line><span class=cl><span class=o>[</span>...<span class=o>]</span>
</span></span></code></pre></div><blockquote><p><strong>译者注</strong></p><p>/proc/sched_debug 在我的系统上不存在。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ uname -a
</span></span><span class=line><span class=cl>Linux Saturday 5.19.0-1-amd64 <span class=c1>#1 SMP PREEMPT_DYNAMIC Debian 5.19.6-1 (2022-09-01) x86_64 GNU/Linux</span>
</span></span></code></pre></div></blockquote><p>除了 CPU 指标，你也可以查看磁盘利用率和饱和度指标。我在 <a href=http://www.brendangregg.com/usemethod.html target=_blank rel="external nofollow noopener noreferrer">USE method<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a> 中专注于此，还专门弄了个 <a href=http://www.brendangregg.com/USEmethod/use-linux.html target=_blank rel="external nofollow noopener noreferrer">Linux 清单<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a>。</p><p>有许多更清晰的指标，但不意味着平均负载就完全没用了。它与其他指标一起成功地用于云计算微服务的扩展策略。这有助于微服务响应不同类型的负载增大，比如 CPU或者磁盘 IO。错误的扩容（费钱）总比不扩容（失去客户）强，所以拓展策略应该考虑更多的征兆。如果扩容得太多了，我们会在第二天调试。</p><p>我使用平均负载的一大原因是它可以展示历史信息。如果我在登录一个性能很差的云上实例，看到 1 分钟平均负载远低于 15 分钟平均负载。这是一个大线索，告诉我性能问题早已发生。我只扫一眼平均负载，就去观察其他指标。</p><h2 id=总结>总结</h2><p>1993 年，一个 Linux 工程师发现了平均负载的不合常理之处，用 3 行补丁永远地把它从“CPU 平均负载”改成了“系统平均负载”。他让平均负载包括了不可中断状态的任务，所以平均工作负载不仅反映对 CPU 的需求，还反映对磁盘资源的需求。系统平均负载计算正在工作、等待工作的线程数，用三个以 1、5、15 分钟为常量的公式计算出阻尼移动和。可以通过比较三个平均负载值来判断系统负载是增大还是减小。</p><p>Linux 内核中不可中断状态的使用场景越来越多，今天包括了不可中断锁原语。如果平均负载是对运行或等待中的线程（不只是等待硬件资源的线程）数的估量，那么平均负载仍然和我们期待的一样运作。</p><p>在这篇文章中，我挖出了1993 年的包含完整解释的 Linux 平均负载补丁（真实太难找了）。我还在现代 Linux 系统上用 bcc/eBPF 监测了处于不可中断状态的函数调用栈，并绘制了 off-CPU 火焰图。火焰图提供了许多有关不可中断睡眠的例子，每次要弄明白不正常的高负载都可以使用火焰图。我还介绍了许多其他的可以用来理解系统负载的指标。</p><p>我想用 Linux 调度器维护者 Peter Zijlstra 在源代码 <a href=https://github.com/torvalds/linux/blob/master/kernel/sched/loadavg.c target=_blank rel="external nofollow noopener noreferrer">kernel/sched/loadavg.c<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a> 中的一段注释结束全文：</p><blockquote><p>This file contains the magic bits required to compute the global loadavg
figure. <strong>Its a silly number but people think its important.</strong> We go through
great pains to make it work on big machines and tickless kernels.</p></blockquote><h2 id=参考资料>参考资料</h2><ul><li>Saltzer, J., and J. Gintell. “<a href=http://web.mit.edu/Saltzer/www/publications/instrumentation.html target=_blank rel="external nofollow noopener noreferrer">The Instrumentation of Multics<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a>,” CACM, August 1970 (explains exponentials).</li><li>Multics <a href=http://web.mit.edu/multics-history/source/Multics/doc/privileged/system_performance_graph.info target=_blank rel="external nofollow noopener noreferrer">system_performance_graph<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a> command reference (mentions the 1 minute average).</li><li><a href=https://github.com/PDP-10/tenex target=_blank rel="external nofollow noopener noreferrer">TENEX<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a> source code (load average code is in SCHED.MAC).</li><li><a href=https://tools.ietf.org/html/rfc546 target=_blank rel="external nofollow noopener noreferrer">RFC 546<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a> &ldquo;TENEX Load Averages for July 1973&rdquo; (explains measuring CPU demand).</li><li>Bobrow, D., et al. “TENEX: A Paged Time Sharing System for the
PDP-10,” Communications of the ACM, March 1972 (explains the load
average triplet).</li><li>Gunther, N. &ldquo;UNIX Load Average Part 1: How It Works&rdquo; <a href=http://www.teamquest.com/import/pdfs/whitepaper/ldavg1.pdf target=_blank rel="external nofollow noopener noreferrer">PDF<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a> (explains the exponential calculations).</li><li>Linus&rsquo;s email about <a href=http://www.linuxmisc.com/30-linux-announce/4543def681c7f27b.htm target=_blank rel="external nofollow noopener noreferrer">Linux 0.99 patchlevel 14<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a>.</li><li>The load average change email is on <a href=http://oldlinux.org/Linux.old/mail-archive/ target=_blank rel="external nofollow noopener noreferrer">oldlinux.org<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a> (in alan-old-funet-lists/kernel.1993.gz, and not in the linux directories, which I searched first).</li><li>The Linux kernel/sched.c source before and after the load average change: <a href="http://kernelhistory.sourcentral.org/linux-0.99.13/?f=/linux-0.99.13/S/449.html%23L332" target=_blank rel="external nofollow noopener noreferrer">0.99.13<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a>, <a href="http://kernelhistory.sourcentral.org/linux-0.99.14/?f=/linux-0.99.14/S/323.html%23L412" target=_blank rel="external nofollow noopener noreferrer">0.99.14<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a>.</li><li>Tarballs for Linux 0.99 releases are on <a href=https://www.kernel.org/pub/linux/kernel/Historic/v0.99/ target=_blank rel="external nofollow noopener noreferrer">kernel.org<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a>.</li><li>The current Linux load average code: <a href=https://github.com/torvalds/linux/blob/master/kernel/sched/loadavg.c target=_blank rel="external nofollow noopener noreferrer">loadavg.c<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a>, <a href=https://github.com/torvalds/linux/blob/master/include/linux/sched/loadavg.h target=_blank rel="external nofollow noopener noreferrer">loadavg.h<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a></li><li>The <a href=https://github.com/iovisor/bcc target=_blank rel="external nofollow noopener noreferrer">bcc<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a> analysis tools includes my <a href=http://www.brendangregg.com/blog/2016-01-20/ebpf-offcpu-flame-graph.html target=_blank rel="external nofollow noopener noreferrer">offcputime<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a>, used for tracing TASK_UNINTERRUPTIBLE.</li><li><a href=http://www.brendangregg.com/flamegraphs.html target=_blank rel="external nofollow noopener noreferrer">Flame Graphs<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a> were used for visualizing uninterruptible paths.</li></ul><p>感谢 Deirdre Straughan 的编辑。</p></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span title="更新于 2022-09-27 14:27:44">更新于 2022-09-27&nbsp;</span></div><div class=post-info-license><span><a rel="license external nofollow noopener noreferrer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span></div></div><div class=post-info-line><div class=post-info-md></div><div class=post-info-share><span><a href=javascript:void(0); title="分享到 Twitter" data-sharer=twitter data-url=/posts/2022/09/27/ data-title="【译】拨开 Linux 平均负载的谜团" data-hashtags=Linux><i class="fa-brands fa-twitter fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); title="分享到 Facebook" data-sharer=facebook data-url=/posts/2022/09/27/ data-hashtag=Linux><i class="fa-brands fa-facebook-square fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); title="分享到 微博" data-sharer=weibo data-url=/posts/2022/09/27/ data-title="【译】拨开 Linux 平均负载的谜团"><i class="fa-brands fa-weibo fa-fw" aria-hidden=true></i></a></span></div></div></div><div class=post-info-more><section class=post-tags><i class="fa-solid fa-tags fa-fw me-1" aria-hidden=true></i><a href=/tags/linux/ class=post-tag>Linux</a></section><section><span><a href=javascript:void(0); onclick=window.history.back()>返回</a></span>&nbsp;|&nbsp;<span><a href=/>主页</a></span></section></div><div class=post-nav><a href=/posts/2022/09/21/ class=post-nav-item rel=prev title="什么是 tar"><i class="fa-solid fa-angle-left fa-fw" aria-hidden=true></i>什么是 tar</a>
<a href=/posts/2022/10/09/ class=post-nav-item rel=next title="【译】 如何设计正确运行多进程程序的多核计算机">【译】 如何设计正确运行多进程程序的多核计算机<i class="fa-solid fa-angle-right fa-fw" aria-hidden=true></i></a></div></div><div class=post-reward><div class=comment></div><input type=checkbox class=reward-input name=reward id=fi-reward hidden>
<label class=reward-button for=fi-reward>赞赏</label><div class=reward-ways data-mode=static><div><img loading=lazy src=/alipay.jpg srcset="/alipay.jpg, /alipay.jpg 1.5x, /alipay.jpg 2x" sizes=auto data-title="孔俊 支付宝" data-alt="孔俊 支付宝" style="background:url(/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'><span>支付宝</span></div><div><img loading=lazy src=/wechatpay.png srcset="/wechatpay.png, /wechatpay.png 1.5x, /wechatpay.png 2x" sizes=auto data-title="孔俊 微信" data-alt="孔俊 微信" style="background:url(/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'><span>微信</span></div></div></div></article></main><footer class=footer><div class=footer-container><div class="footer-line powered">由 <a href=https://gohugo.io/ target=_blank rel="external nofollow noopener noreferrer" title="Hugo 0.110.0">Hugo</a> 强力驱动 | 主题 - <a href=https://github.com/hugo-fixit/FixIt target=_blank rel=external title="FixIt v0.2.18"><img class=fixit-icon src=/fixit.min.svg alt="FixIt logo">&nbsp;FixIt</a></div><div class="footer-line copyright" itemscope itemtype=http://schema.org/CreativeWork><i class="fa-regular fa-copyright fa-fw" aria-hidden=true></i>
<span itemprop=copyrightYear>2022 - 2023</span><span class=author itemprop=copyrightHolder>
<a href=/></a></span><span class="license footer-divider"><a rel="license external nofollow noopener noreferrer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span></div><div class="footer-line statistics"></div></div></footer></div><div class=widgets><div class="fixed-buttons animate__faster d-none"><div class="fixed-button back-to-top" role=button aria-label=回到顶部><i class="fa-solid fa-arrow-up fa-fw" aria-hidden=true></i><span class="variant-numeric d-none">0%</span></div></div><a href=https://github.com/kongjun18/blog title=查看博客源代码 target=_blank rel="external nofollow" class="github-corner left d-none-mobile"><svg viewBox="0 0 250 250" aria-hidden="true"><path d="M0 0 115 115h15l12 27L250 250V0z"/><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentcolor" style="transform-origin:130px 106px" class="octo-arm"/><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4l13.9-13.8C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8z" fill="currentcolor" class="octo-body"/></svg></a><div id=mask></div><noscript><div class=noscript-warning>FixIt 主题在启用 JavaScript 的情况下效果最佳。</div></noscript></div><link rel=stylesheet href=/lib/katex/katex.min.css><link rel=stylesheet href=/lib/cookieconsent/cookieconsent.min.css><script src=/lib/sharer/sharer.min.js async defer></script><script src=/lib/katex/katex.min.js defer></script><script src=/lib/katex/auto-render.min.js defer></script><script src=/lib/katex/copy-tex.min.js defer></script><script src=/lib/katex/mhchem.min.js defer></script><script src=/lib/cookieconsent/cookieconsent.min.js defer></script><script src=/lib/pangu/pangu.min.js defer></script><script>window.config={autoBookmark:!0,code:{copyTitle:"复制到剪贴板",editLockTitle:"锁定可编辑代码块",editUnLockTitle:"解锁可编辑代码块",editable:!0,maxShownLines:40},comment:{enable:!1},cookieconsent:{content:{dismiss:"同意",link:"了解更多",message:"本网站使用 Cookies 来改善您的浏览体验。"},enable:!0,palette:{button:{background:"#f0f0f0"},popup:{background:"#1aa3ff"}},theme:"edgeless"},math:{delimiters:[{display:!0,left:"$$",right:"$$"},{display:!0,left:"\\[",right:"\\]"},{display:!0,left:"\\begin{equation}",right:"\\end{equation}"},{display:!0,left:"\\begin{equation*}",right:"\\end{equation*}"},{display:!0,left:"\\begin{align}",right:"\\end{align}"},{display:!0,left:"\\begin{align*}",right:"\\end{align*}"},{display:!0,left:"\\begin{alignat}",right:"\\end{alignat}"},{display:!0,left:"\\begin{alignat*}",right:"\\end{alignat*}"},{display:!0,left:"\\begin{gather}",right:"\\end{gather}"},{display:!0,left:"\\begin{CD}",right:"\\end{CD}"},{display:!1,left:"$",right:"$"},{display:!1,left:"\\(",right:"\\)"}],strict:!1},pangu:{enable:!0,selector:"article"}}</script><script src=/js/theme.min.js defer></script></body></html>