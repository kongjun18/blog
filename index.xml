<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>孔俊的知识库</title><link>/</link><description>孔俊的知识库</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Mon, 12 Dec 2022 21:01:48 +0800</lastBuildDate><atom:link href="/index.xml" rel="self" type="application/rss+xml"/><item><title>致敬经典：K&amp;R allocator 内存分配器</title><link>/posts/2022/12/12/</link><pubDate>Mon, 12 Dec 2022 21:01:48 +0800</pubDate><author>作者</author><guid>/posts/2022/12/12/</guid><description><![CDATA[k&amp;R allocator 是Brain Kernighan和 Dennis Ritchie 的名著 The C Programming Language 第 8.7 节中介绍的一个简单 malloc 实现。因为该书被称为 K&amp;R C，这个 malloc 实现也被称为 K&amp;C allocator。 K&amp;R allocator 的实现非常简洁，Linux 内核基于 K&amp;R allocator 实现了用于嵌入式系统 slob allocator。见 slob: introduce the SLOB allocator，邮件摘要如下： SLOB is a traditional K&amp;R/UNIX allocator with a SLAB emulation layer, similar to the original Linux kmalloc allocator that SLAB replaced. It&#39;s signicantly smaller code and is more memory efficient. But like all similar allocators, it scales poorly and suffers from fragmentation more than]]></description></item><item><title>深入剖析 Go 语言运行时：IO 轮询器</title><link>/posts/2022/11/21/</link><pubDate>Mon, 21 Nov 2022 17:42:25 +0800</pubDate><author>作者</author><guid>/posts/2022/11/21/</guid><description><![CDATA[netpoller 概述 考虑一个基于 goroutine-per-connection 模型的 TCP echo server： import ( &#34;fmt&#34; &#34;io&#34; &#34;log&#34; &#34;net&#34; ) func worker(conn net.Conn) { defer conn.Close() b := make([]byte, 512) for { size, err := conn.Read(b) if err == io.EOF { break } if err != nil { log.Fatal(err) } size, err = conn.Write(b[0:size]) if err != nil { log.Fatal(err) } } } func main() { listner, err := net.Listen(&#34;tcp&#34;, &#34;127.0.0.1:8080&#34;) if err != nil { log.Fatal(err) } for { conn, err := listner.Accept() if err != nil { log.Fatal(err) } go worker(conn) } } 从用户侧看，系统该调用阻塞 goroutine，Go scheduler 调度其他 goroutine。问题在于，goroutine 复用在线程上，如果 IO 系统调用（如read(2]]></description></item><item><title>【译】内存屏障：软件黑客的硬件视角</title><link>/posts/2022/11/03/</link><pubDate>Thu, 03 Nov 2022 11:00:56 +0800</pubDate><author>作者</author><guid>/posts/2022/11/03/</guid><description>译者序 Memory Barriers: a Hardware View for Software Hackers 是并发编程专家 Paul E. McKenney 的经典论文，该论文同时收录在他的著作 Is Parallel Programming Hard, And, If So, What Can You Do About It? 附录 C Why Memory Barriers? 中。 本文全文翻译该论文。 为什么中了邪的 CPU 设计者要让可怜的一无所知的软件设计者受内存屏障（memory barrier）的伤害？ 简单地说，因为乱序内存引用可以带来更好的性能，所以需要用内存屏障在同步原语这类其正确操作依赖于排序的内存引用的东西中强制</description></item><item><title>【译】Go 语言数据竞争检测器</title><link>/posts/2022/10/25/</link><pubDate>Tue, 25 Oct 2022 09:43:35 +0800</pubDate><author>作者</author><guid>/posts/2022/10/25/</guid><description><![CDATA[简介 数据竞争是并发程序中最普遍和最难调试的 bug。当两个 goroutine 并发访问同一变量且至少一个访问是写时发生数据竞争。更多细节参考 The Go Memory Model。 译者注 The Go Memory Model 可以参考我的博客 【译】Go 语言内存模型：2022-06-06 版。 这有一个可以导致程序崩溃（crashes）和内存损坏（memory corruption）的数据竞争的例子： xian sxian sfunc main() { c := make(chan bool) m := make(map[string]string) go func() { m[&#34;1&#34;] = &#34;a&#34; //]]></description></item><item><title>【译】Go 语言内存模型：2022-06-06 版</title><link>/posts/2022/10/20/</link><pubDate>Thu, 20 Oct 2022 11:46:49 +0800</pubDate><author>作者</author><guid>/posts/2022/10/20/</guid><description>译者序 原文 The Go Memory Model 描述 Go 语言内存模型，这里的内存模型实际上是“内存一致性模型”（memory consistency model）。笔者修改了格式错误并翻译全文。 The Go Memory Model 在内存一致性模型层面，描述 Go 语言实现（Go implementation）提供的一致性保证，并进一步指出该保证对 Go 语言实现的限制；在工程实践层面，描述使用同步原语确保 goroutine 间可见性的方法，并进一步指出常见的错误同步手法。</description></item><item><title>【译】一种面向多核架构的无锁、缓存高效的共享环形缓冲区</title><link>/posts/2022/10/13/</link><pubDate>Thu, 13 Oct 2022 22:26:21 +0800</pubDate><author>作者</author><guid>/posts/2022/10/13/</guid><description>译者序 论文 A Lock-Free, Cache-Efficient Shared Ring Buffer for Multi-Core Architectures 介绍了一种专为多核架构设计、用于单生产者/单消费者模型的环形缓冲区，称为 MCRingBuffer。论文性能测试表明，其吞吐量数倍于 Lamport 提出的 BasicRingBuffer。 MCRingBuffer 将环形缓存区划分为多个块，块划分为多个槽。 论文基于基础的环形缓冲区，从以下两方面着手提高性能： 降低读共享控制变量的频率：维护私有变量，仅在缓冲区可能满/空时读取</description></item><item><title>【译】 如何设计正确运行多进程程序的多核计算机</title><link>/posts/2022/10/09/</link><pubDate>Sun, 09 Oct 2022 15:24:14 +0800</pubDate><author>作者</author><guid>/posts/2022/10/09/</guid><description>TL;DR SC(Sequential Consistency)：任何执行的结果看起来就像所有处理器都顺序执行，并且单个处理器按照程序指定次序执行。 每个处理器都是顺序的，不意味着整个多核系统是顺序一致的。 SC 是一个定义在内存访问上的偏序。 为了实现 SC，处理器需要满足两个条件： 处理器按照程序次序发起请求。发起请求包括进入内存模块的队列。 内存模块按照 FIFO 次序响应请求。 SC 虽然符合人类直觉，但限制了处理器</description></item><item><title>【译】拨开 Linux 平均负载的谜团</title><link>/posts/2022/09/27/</link><pubDate>Tue, 27 Sep 2022 14:27:44 +0800</pubDate><author>作者</author><guid>/posts/2022/09/27/</guid><description>平均负载（load averages）是一个很关键的指标——我所在的公司基于平均负载和其他指标，花费数百万去自动伸缩云实例——但在 Linux 上存在许多和平均负载相关的谜题。Linux 平均负载不仅追踪运行态（runnable）任务，也追踪处于不可中断休眠状态（uninterruptible sleep state）的任务。为什么？从没有人给我解释过。在这篇文章中，我将解决这个谜团，</description></item><item><title>什么是 tar</title><link>/posts/2022/09/21/</link><pubDate>Wed, 21 Sep 2022 17:42:25 +0800</pubDate><author>作者</author><guid>/posts/2022/09/21/</guid><description>tar 是 tape archive 的简称，即“磁带归档”，最早出现在 1979 年的第 UNIX v7。磁带上的数据存储为可能不相邻的变长数据块，浪费了大量块与块之间的空间。向磁盘、网络传输数据时，传输一大块的效率远高于多个小块，因此程序员使用 tar 将磁带上的数据打包在一起，物理上存储在连续的、固定大小的块上以提高性能。 tar 打包出来的文件称为为 tarball。一般会使用某种压缩算法压缩 tarball，压缩后的</description></item><item><title>Lua 语言简明教程</title><link>/posts/2022/01/02/</link><pubDate>Sun, 02 Jan 2022 15:31:31 +0800</pubDate><author>作者</author><guid>/posts/2022/01/02/</guid><description>Lua is a powerful, efficient, lightweight, embeddable scripting language. It supports procedural programming, object-oriented programming, functional programming, data-driven programming, and data description. Lua combines simple procedural syntax with powerful data description constructs based on associative arrays and extensible semantics. Lua is dynamically typed, runs by interpreting bytecode with a register-based virtual machine, and has automatic memory management with incremental garbage collection, making it ideal for configuration, scripting, and rapid prototyping. 类型 Lua 使用动态类型，未初始化的全局变量值默认为 nil（通过元表实现）。 nil nil 是一个类型，同时也是一个值，即 nil 类型的值就是 nil，表示空或无（空类型）。 全局变量未初始化时（空），值就是 nil。当把变量赋值为 nil 时，表示该变量无</description></item></channel></rss>