<!doctype html><html itemscope itemtype=http://schema.org/WebPage lang=zh-cn><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=2"><meta name=robots content="noodp"><title>深入剖析 Go 语言运行时：IO 轮询器 - 孔俊的知识库</title><meta name=author content><meta name=author-link content><meta name=description content="netpoller 概述 考虑一个基于 goroutine-per-connection 模型的 TCP echo server： import ( &#34;fmt&#34; &#34;io&#34; &#34;log&#34; &#34;net&#34; ) func worker(conn net.Conn) { defer conn.Close() b := make([]byte, 512) for { size, err := conn.Read(b) if err == io.EOF { break } if err != nil { log.Fatal(err) } size, err = conn.Write(b[0:size]) if err != nil { log.Fatal(err) } } } func main() { listner, err := net.Listen(&#34;tcp&#34;, &#34;127.0.0.1:8080&#34;) if err != nil { log.Fatal(err) } for { conn, err := listner.Accept() if err != nil { log.Fatal(err) } go worker(conn) } } 从用户侧看，系统该调用阻塞 goroutine，Go scheduler 调度其他 goroutine。问题在于，goroutine 复用在线程上，如果 IO 系统调用（如read(2"><meta name=keywords content="Go,Network,UNIX"><meta itemprop=name content="深入剖析 Go 语言运行时：IO 轮询器"><meta itemprop=description content="netpoller 概述 考虑一个基于 goroutine-per-connection 模型的 TCP echo server： import ( &#34;fmt&#34; &#34;io&#34; &#34;log&#34; &#34;net&#34; ) func worker(conn net.Conn) { defer conn.Close() b := make([]byte, 512) for { size, err := conn.Read(b) if err == io.EOF { break } if err != nil { log.Fatal(err) } size, err = conn.Write(b[0:size]) if err != nil { log.Fatal(err) } } } func main() { listner, err := net.Listen(&#34;tcp&#34;, &#34;127.0.0.1:8080&#34;) if err != nil { log.Fatal(err) } for { conn, err := listner.Accept() if err != nil { log.Fatal(err) } go worker(conn) } } 从用户侧看，系统该调用阻塞 goroutine，Go scheduler 调度其他 goroutine。问题在于，goroutine 复用在线程上，如果 IO 系统调用（如read(2"><meta itemprop=datePublished content="2022-11-21T17:42:25+08:00"><meta itemprop=dateModified content="2022-11-21T17:42:25+08:00"><meta itemprop=wordCount content="10865"><meta itemprop=image content="/posts/2022/11/21/images/featured-image.png"><meta itemprop=keywords content="Go,Network,UNIX,"><meta property="og:title" content="深入剖析 Go 语言运行时：IO 轮询器"><meta property="og:description" content="netpoller 概述 考虑一个基于 goroutine-per-connection 模型的 TCP echo server： import ( &#34;fmt&#34; &#34;io&#34; &#34;log&#34; &#34;net&#34; ) func worker(conn net.Conn) { defer conn.Close() b := make([]byte, 512) for { size, err := conn.Read(b) if err == io.EOF { break } if err != nil { log.Fatal(err) } size, err = conn.Write(b[0:size]) if err != nil { log.Fatal(err) } } } func main() { listner, err := net.Listen(&#34;tcp&#34;, &#34;127.0.0.1:8080&#34;) if err != nil { log.Fatal(err) } for { conn, err := listner.Accept() if err != nil { log.Fatal(err) } go worker(conn) } } 从用户侧看，系统该调用阻塞 goroutine，Go scheduler 调度其他 goroutine。问题在于，goroutine 复用在线程上，如果 IO 系统调用（如read(2"><meta property="og:type" content="article"><meta property="og:url" content="/posts/2022/11/21/"><meta property="og:image" content="/posts/2022/11/21/images/featured-image.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-11-21T17:42:25+08:00"><meta property="article:modified_time" content="2022-11-21T17:42:25+08:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="/posts/2022/11/21/images/featured-image.png"><meta name=twitter:title content="深入剖析 Go 语言运行时：IO 轮询器"><meta name=twitter:description content="netpoller 概述 考虑一个基于 goroutine-per-connection 模型的 TCP echo server： import ( &#34;fmt&#34; &#34;io&#34; &#34;log&#34; &#34;net&#34; ) func worker(conn net.Conn) { defer conn.Close() b := make([]byte, 512) for { size, err := conn.Read(b) if err == io.EOF { break } if err != nil { log.Fatal(err) } size, err = conn.Write(b[0:size]) if err != nil { log.Fatal(err) } } } func main() { listner, err := net.Listen(&#34;tcp&#34;, &#34;127.0.0.1:8080&#34;) if err != nil { log.Fatal(err) } for { conn, err := listner.Accept() if err != nil { log.Fatal(err) } go worker(conn) } } 从用户侧看，系统该调用阻塞 goroutine，Go scheduler 调度其他 goroutine。问题在于，goroutine 复用在线程上，如果 IO 系统调用（如read(2"><meta name=application-name content="FixIt"><meta name=apple-mobile-web-app-title content="FixIt"><meta name=theme-color data-light=#f8f8f8 data-dark=#252627 content="#f8f8f8"><meta name=msapplication-TileColor content="#da532c"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=canonical href=/posts/2022/11/21/><link rel=prev href=/posts/2022/11/03/><link rel=next href=/posts/2022/12/12/><link rel=stylesheet href=/css/style.min.css><link rel=stylesheet href=/lib/fontawesome-free/all.min.css><link rel=stylesheet href=/lib/animate/animate.min.css><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"深入剖析 Go 语言运行时：IO 轮询器","inLanguage":"zh-CN","mainEntityOfPage":{"@type":"WebPage","@id":"\/posts\/2022\/11\/21\/"},"image":[{"@type":"ImageObject","url":"\/posts\/2022\/11\/21\/images\/featured-image.png","width":1890,"height":780}],"genre":"posts","keywords":"Go, Network, UNIX","wordcount":10865,"url":"\/posts\/2022\/11\/21\/","datePublished":"2022-11-21T17:42:25+08:00","dateModified":"2022-11-21T17:42:25+08:00","publisher":{"@type":"Organization","name":""},"author":{"@type":"Person","name":"孔俊"},"description":""}</script></head><body data-header-desktop=sticky data-header-mobile=auto><script>(window.localStorage?.getItem("theme")?localStorage.getItem("theme")==="dark":"auto"==="auto"?window.matchMedia("(prefers-color-scheme: dark)").matches:"auto"==="dark")&&document.body.setAttribute("data-theme","dark")</script><div class=wrapper data-page-style=normal><header class="desktop animate__faster" id=header-desktop><div class=header-wrapper data-github-corner=left><div class=header-title><a href=/ title=孔俊的知识库><img loading=lazy src=/logo.svg srcset="/logo.svg, /logo.svg 1.5x, /logo.svg 2x" sizes=auto data-title=孔俊的知识库 data-alt=孔俊的知识库 class=logo style="background:url(/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'><span class=header-title-text>孔俊的知识库</span></a><span class=header-subtitle></span></div><nav><ul class=menu><li class=menu-item><a class=menu-link href=/posts/>文章</a></li><li class=menu-item><a class=menu-link href=/categories/>分类</a></li><li class=menu-item><a class=menu-link href=/tags/>标签</a></li><li class=menu-item><a class=menu-link href=/archives/>归档</a></li><li class=menu-item><a class=menu-link href=/about/>关于我</a></li><li class="menu-item delimiter"></li><li class="menu-item theme-switch" title=切换主题><i class="fa-solid fa-adjust fa-fw" aria-hidden=true></i></li></ul></nav></div></header><header class="mobile animate__faster" id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title=孔俊的知识库><img loading=lazy src=/logo.svg srcset="/logo.svg, /logo.svg 1.5x, /logo.svg 2x" sizes=auto data-title=/logo.svg data-alt=/logo.svg class=logo style="background:url(/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'><span class=header-title-text>孔俊的知识库</span></a><span class=header-subtitle></span></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><nav><ul class=menu id=menu-mobile><li class=menu-item><a class=menu-link href=/posts/>文章</a></li><li class=menu-item><a class=menu-link href=/categories/>分类</a></li><li class=menu-item><a class=menu-link href=/tags/>标签</a></li><li class=menu-item><a class=menu-link href=/archives/>归档</a></li><li class=menu-item><a class=menu-link href=/about/>关于我</a></li><li class="menu-item menu-system"><span class="menu-system-item theme-switch" title=切换主题><i class="fa-solid fa-adjust fa-fw" aria-hidden=true></i></span></li></ul></nav></div></header><main class=container><aside class=toc id=toc-auto><h2 class=toc-title>目录&nbsp;<i class="toc-icon fa-solid fa-angle-down fa-fw" aria-hidden=true></i></h2><div class=toc-content id=toc-content-auto></div></aside><aside class=aside-custom></aside><article class="page single"><div class=header><h1 class="single-title animate__animated animate__flipInX"><span title=转载 class=icon-repost><i class="fa-solid fa-share fa-fw" aria-hidden=true></i></span><span>深入剖析 Go 语言运行时：IO 轮询器</span></h1></div><div class=post-meta><div class=post-meta-line><span class=post-author><span class=author><i class="fa-solid fa-user-circle" aria-hidden=true></i>
孔俊</span></span>
<span class=post-category>收录于 <a href=/categories/go/><i class="fa-regular fa-folder fa-fw" aria-hidden=true></i> Go</a></span></div><div class=post-meta-line><span title="发布于 2022-11-21 17:42:25"><i class="fa-regular fa-calendar-alt fa-fw me-1" aria-hidden=true></i><time datetime=2022-11-21>2022-11-21</time></span>&nbsp;<span title="更新于 2022-11-21 17:42:25"><i class="fa-regular fa-edit fa-fw me-1" aria-hidden=true></i><time datetime=2022-11-21>2022-11-21</time></span>&nbsp;<span><i class="fa-solid fa-pencil-alt fa-fw me-1" aria-hidden=true></i>约 10865 字</span>&nbsp;<span><i class="fa-regular fa-clock fa-fw me-1" aria-hidden=true></i>预计阅读 22 分钟</span>&nbsp;</div></div><div class=featured-image><img loading=lazy src=/posts/2022/11/21/images/featured-image.png srcset="/posts/2022/11/21/images/featured-image.png, /posts/2022/11/21/images/featured-image.png 1.5x, /posts/2022/11/21/images/featured-image.png 2x" sizes=auto data-title=/posts/2022/11/21/images/featured-image.png data-alt=/posts/2022/11/21/images/featured-image.png style="background:url(/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'></div><div class="details toc" id=toc-static data-kept=false><div class="details-summary toc-title"><span>目录</span>
<span><i class="details-icon fa-solid fa-angle-right" aria-hidden=true></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><a href=#netpoller-概述>netpoller 概述</a></li><li><a href=#底层机制>底层机制</a><ul><li><a href=#非阻塞-io>非阻塞 IO</a></li><li><a href=#io-多路复用>IO 多路复用</a></li></ul></li><li><a href=#数据结构>数据结构</a><ul><li><a href=#polldesc>pollDesc</a></li><li><a href=#pollcache>pollCache</a></li></ul></li><li><a href=#netpoller-基础函数>netpoller 基础函数</a><ul><li><a href=#初始化轮询器>初始化轮询器</a></li><li><a href=#注册文件描述符>注册文件描述符</a></li><li><a href=#检测文件描述符是否由-poller-管理>检测文件描述符是否由 poller 管理</a></li><li><a href=#删除文件描述符>删除文件描述符</a></li><li><a href=#中断-netpoller>中断 netpoller</a></li><li><a href=#文件描述符状态>文件描述符状态</a></li></ul></li><li><a href=#goroutine-挂起与恢复>goroutine 挂起与恢复</a><ul><li><a href=#netpollblock>netpollblock</a></li><li><a href=#netpollunblock>netpollunblock</a></li></ul></li><li><a href=#轮询-io-事件>轮询 IO 事件</a></li><li><a href=#拦截阻塞-io>“拦截”阻塞 IO</a><ul><li><a href=#封装文件描述符>封装文件描述符</a></li><li><a href=#初始化文件描述符>初始化文件描述符</a></li><li><a href=#封装系统调用>封装系统调用</a></li></ul></li><li><a href=#实例>实例</a></li></ul></nav></div></div><div class=content id=content><h2 id=netpoller-概述>netpoller 概述</h2><p>考虑一个基于 goroutine-per-connection 模型的 TCP echo server：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>import</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=s>&#34;fmt&#34;</span>
</span></span><span class=line><span class=cl>    <span class=s>&#34;io&#34;</span>
</span></span><span class=line><span class=cl>    <span class=s>&#34;log&#34;</span>
</span></span><span class=line><span class=cl>    <span class=s>&#34;net&#34;</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>worker</span><span class=p>(</span><span class=nx>conn</span> <span class=nx>net</span><span class=p>.</span><span class=nx>Conn</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>defer</span> <span class=nx>conn</span><span class=p>.</span><span class=nf>Close</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=nx>b</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>([]</span><span class=kt>byte</span><span class=p>,</span> <span class=mi>512</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>size</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>conn</span><span class=p>.</span><span class=nf>Read</span><span class=p>(</span><span class=nx>b</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nx>err</span> <span class=o>==</span> <span class=nx>io</span><span class=p>.</span><span class=nx>EOF</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>break</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>log</span><span class=p>.</span><span class=nf>Fatal</span><span class=p>(</span><span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=nx>size</span><span class=p>,</span> <span class=nx>err</span> <span class=p>=</span> <span class=nx>conn</span><span class=p>.</span><span class=nf>Write</span><span class=p>(</span><span class=nx>b</span><span class=p>[</span><span class=mi>0</span><span class=p>:</span><span class=nx>size</span><span class=p>])</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>log</span><span class=p>.</span><span class=nf>Fatal</span><span class=p>(</span><span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>listner</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>net</span><span class=p>.</span><span class=nf>Listen</span><span class=p>(</span><span class=s>&#34;tcp&#34;</span><span class=p>,</span> <span class=s>&#34;127.0.0.1:8080&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>log</span><span class=p>.</span><span class=nf>Fatal</span><span class=p>(</span><span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>conn</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>listner</span><span class=p>.</span><span class=nf>Accept</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>log</span><span class=p>.</span><span class=nf>Fatal</span><span class=p>(</span><span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>go</span> <span class=nf>worker</span><span class=p>(</span><span class=nx>conn</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>从用户侧看，系统该调用阻塞 goroutine，Go scheduler 调度其他 goroutine。问题在于，goroutine 复用在线程上，如果 IO 系统调用（如<code>read(2)</code>/<code>write(2)</code>）阻塞，直接阻塞 goroutine 所在线程，Go scheduler 将没有机会调度 goroutine！</p><p><figure><img src=images/goroutine-and-thread.excalidraw.svg alt="Figure1: Goroutine and thread"><figcaption>Figure1: Goroutine and thread</figcaption></figure></p><p>为了实现 goroutine-per-connection 网络编程模型，必须提供“IO 系统调用阻塞 goroutine 而非 OS 线程”的抽象，这意味着必须“拦截” IO 系统调用对线程的阻塞。</p><p>Go runtime 通过非阻塞 IO 和 IO 多路复用机制实现了一个 IO 轮询器（netpoller），提供了“网络 IO 阻塞 goroutine”的抽象：</p><ul><li>尽量将文件描述符设置为非阻塞的，关联当前 goroutine 到该文件描述符，注册其上的 IO 事件到轮询器中。</li><li>IO 系统调用失败（返回<code>EAGAIN</code>）时，阻塞该 goroutine，切换到其他 goroutine。</li><li>在特定时机轮询 IO 事件，获取就绪的文件描述符，调度对应的 goroutine。</li></ul><h2 id=底层机制>底层机制</h2><h3 id=非阻塞-io>非阻塞 IO</h3><p>为了避免 IO 系统调用阻塞 OS 线程，必须使用非阻塞 IO。</p><p>非阻塞 IO 和阻塞 IO 的差别在于，非阻塞 IO 给了用户处理 IO 未就绪的机会：当文件描述符上不可进行 IO 操作时，非阻塞 IO 系统调用返回错误，而阻塞 IO 直接阻塞线程直到 IO 完成。</p><p><figure><img src=images/blocking-io-and-non-blocking-io.svg alt="Figure2: Blocking IO and non-blocking IO"><figcaption>Figure2: Blocking IO and non-blocking IO</figcaption></figure></p><p>非阻塞 IO 不等于高性能，对于非阻塞 IO 和阻塞 IO，从IO 未就绪到 IO 就绪并传输数据的时间都是相同的。如果直接如图 2 轮询文件描述符，非阻塞 IO 需要调用更多次系统调用，性能反而更差。</p><p>非阻塞 IO 高性能的关键在于避免等待 IO 就绪。非阻塞 IO 系统调用返回错误后，用户知道 IO 未就绪，去执行别的操作，IO 就绪后再接着执行先前的逻辑。</p><p><figure><img src=images/coroutines-with-nonblocking-io.excalidraw.svg alt="Figure 3: Cotouines with non-blocking IO"><figcaption>Figure 3: Cotouines with non-blocking IO</figcaption></figure></p><p>这是经典的协程模型，协程 1 调用非阻塞 IO 失败，于是主动放弃控制权，切换到协程 2，协程 2 执行其他逻辑，发现协程 1 等待的 IO 就绪后，再切换回协程 1。</p><p>Go runtime 提供的抽象是“IO 阻塞 goroutine，切换到其他 goroutine”，因此用户代码不需要“主动换出”，Go scheduler 会替用户调度 goroutine。</p><h3 id=io-多路复用>IO 多路复用</h3><p>非阻塞 IO 高性能的关键在于避免等待 IO 就绪，因此操作系统内核提供了 IO 多路复用机制，通知用户 IO 已就绪，避免用户忙等待 IO。也就是说，轮询 IO 是否就绪的责任从用户转移到了操作系统。</p><p>Linux 平台上一般使用 epoll 进行 IO 多路复用。<code>epoll_create(2)</code>创建轮询器（一个包含所有相关信息的文件描述符），<code>epoll_ctl(2)</code>向轮询器注册/删除文件描述符上的 IO 事件，<code>epoll_wait(2)</code>阻塞直到发生事件并返回待处理事件。</p><p>注意，epoll 只能处理 socket 和 pipe，不能处理磁盘文件。</p><p><figure><img src=images/epoll_wait-blocks-os-thread.excalidraw.svg alt="Figure 4: epoll_wait(2) blocks the OS thread"><figcaption>Figure 4: epoll_wait(2) blocks the OS thread</figcaption></figure></p><h2 id=数据结构>数据结构</h2><h3 id=polldesc>pollDesc</h3><p>Go runtime 定义了<code>pollDesc</code>描述用于网络轮询的文件描述符，其中包括 OS 原生文件描述符、锁、读写者 goroutine、定时器信息以及描述符状态<code>atomicInfo</code>。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// Network poller descriptor.
</span></span></span><span class=line><span class=cl><span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1>// No heap pointers.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>type</span> <span class=nx>pollDesc</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>_</span>    <span class=nx>sys</span><span class=p>.</span><span class=nx>NotInHeap</span>
</span></span><span class=line><span class=cl>    <span class=nx>link</span> <span class=o>*</span><span class=nx>pollDesc</span> <span class=c1>// in pollcache, protected by pollcache.lock
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>fd</span>   <span class=kt>uintptr</span>   <span class=c1>// constant for pollDesc usage lifetime
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=c1>// atomicInfo holds bits from closing, rd, and wd,
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// which are only ever written while holding the lock,
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// summarized for use by netpollcheckerr,
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// which cannot acquire the lock.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// After writing these fields under lock in a way that
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// might change the summary, code must call publishInfo
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// before releasing the lock.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// Code that changes fields and then calls netpollunblock
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// (while still holding the lock) must call publishInfo
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// before calling netpollunblock, because publishInfo is what
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// stops netpollblock from blocking anew
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// (by changing the result of netpollcheckerr).
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// atomicInfo also holds the eventErr bit,
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// recording whether a poll event on the fd got an error;
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// atomicInfo is the only source of truth for that bit.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>atomicInfo</span> <span class=nx>atomic</span><span class=p>.</span><span class=nx>Uint32</span> <span class=c1>// atomic pollInfo
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=c1>// rg, wg are accessed atomically and hold g pointers.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// (Using atomic.Uintptr here is similar to using guintptr elsewhere.)
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>rg</span> <span class=nx>atomic</span><span class=p>.</span><span class=nx>Uintptr</span> <span class=c1>// pdReady, pdWait, G waiting for read or pdNil
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>wg</span> <span class=nx>atomic</span><span class=p>.</span><span class=nx>Uintptr</span> <span class=c1>// pdReady, pdWait, G waiting for write or pdNil
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=nx>lock</span>    <span class=nx>mutex</span> <span class=c1>// protects the following fields
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>closing</span> <span class=kt>bool</span>
</span></span><span class=line><span class=cl>    <span class=nx>user</span>    <span class=kt>uint32</span>    <span class=c1>// user settable cookie
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>rseq</span>    <span class=kt>uintptr</span>   <span class=c1>// protects from stale read timers
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>rt</span>      <span class=nx>timer</span>     <span class=c1>// read deadline timer (set if rt.f != nil)
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>rd</span>      <span class=kt>int64</span>     <span class=c1>// read deadline (a nanotime in the future, -1 when expired)
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>wseq</span>    <span class=kt>uintptr</span>   <span class=c1>// protects from stale write timers
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>wt</span>      <span class=nx>timer</span>     <span class=c1>// write deadline timer
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>wd</span>      <span class=kt>int64</span>     <span class=c1>// write deadline (a nanotime in the future, -1 when expired)
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>self</span>    <span class=o>*</span><span class=nx>pollDesc</span> <span class=c1>// storage for indirect interface. See (*pollDesc).makeArg.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><p><code>link</code>是指向<code>pollDesc</code>的指针，所有<code>pollDesc</code>放到一个链表中管理。</p><p><code>fd</code>是<code>pollDesc</code>使用的 OS 原生文件描述符，在<code>pollDesc</code>的整个生命周期保持不变。</p><p><code>atomicInfo</code>维护<code>pollDesc</code>的轮询状态。</p><p><code>rg</code>/<code>wg</code>是该文件描述符上阻塞的 goroutine。</p><p><code>resq</code>以下的成员用于定时器处理 IO 超时。</p><p>后文会详细介绍<code>pollDesc</code>各字段。</p><h3 id=pollcache>pollCache</h3><p><code>pollCache</code>是一个单向链表，用于管理<code>pollDesc</code>的分配和释放。因为多个 goroutine 可能并发地注册 poller，所以需要互斥锁保护并发访问。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>pollCache</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>lock</span>  <span class=nx>mutex</span>
</span></span><span class=line><span class=cl>    <span class=nx>first</span> <span class=o>*</span><span class=nx>pollDesc</span>
</span></span><span class=line><span class=cl>    <span class=c1>// PollDesc objects must be type-stable,
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// because we can get ready notification from epoll/kqueue
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// after the descriptor is closed/reused.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// Stale notifications are detected using seq variable,
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// seq is incremented when deadlines are changed or descriptor is reused.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><p><code>(*pollCache).alloc()</code>从<code>pollCache</code>中分配一个<code>pollDesc</code>:</p><ol><li><p>若<code>pollCache</code>为空，分配大小为<code>pollBlockSize</code>（4K）的非 GC 内存（<code>pollDesc</code>）。</p></li><li><p>摘下链表头上的<code>pollDesc</code>，返回给用户。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>c</span> <span class=o>*</span><span class=nx>pollCache</span><span class=p>)</span> <span class=nf>alloc</span><span class=p>()</span> <span class=o>*</span><span class=nx>pollDesc</span> <span class=p>{</span>
</span></span><span class=line><span class=cl> <span class=nf>lock</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>c</span><span class=p>.</span><span class=nx>lock</span><span class=p>)</span>
</span></span><span class=line><span class=cl> <span class=c1>// 分配内存，创造 pollDesc
</span></span></span><span class=line><span class=cl><span class=c1></span> <span class=k>if</span> <span class=nx>c</span><span class=p>.</span><span class=nx>first</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>     <span class=kd>const</span> <span class=nx>pdSize</span> <span class=p>=</span> <span class=nx>unsafe</span><span class=p>.</span><span class=nf>Sizeof</span><span class=p>(</span><span class=nx>pollDesc</span><span class=p>{})</span>
</span></span><span class=line><span class=cl>     <span class=nx>n</span> <span class=o>:=</span> <span class=nx>pollBlockSize</span> <span class=o>/</span> <span class=nx>pdSize</span>
</span></span><span class=line><span class=cl>     <span class=k>if</span> <span class=nx>n</span> <span class=o>==</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>         <span class=nx>n</span> <span class=p>=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>     <span class=p>}</span>
</span></span><span class=line><span class=cl>     <span class=c1>// Must be in non-GC memory because can be referenced
</span></span></span><span class=line><span class=cl><span class=c1></span>     <span class=c1>// only from epoll/kqueue internals.
</span></span></span><span class=line><span class=cl><span class=c1></span>     <span class=nx>mem</span> <span class=o>:=</span> <span class=nf>persistentalloc</span><span class=p>(</span><span class=nx>n</span><span class=o>*</span><span class=nx>pdSize</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=o>&amp;</span><span class=nx>memstats</span><span class=p>.</span><span class=nx>other_sys</span><span class=p>)</span>
</span></span><span class=line><span class=cl>     <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=nb>uintptr</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=nx>n</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>         <span class=nx>pd</span> <span class=o>:=</span> <span class=p>(</span><span class=o>*</span><span class=nx>pollDesc</span><span class=p>)(</span><span class=nf>add</span><span class=p>(</span><span class=nx>mem</span><span class=p>,</span> <span class=nx>i</span><span class=o>*</span><span class=nx>pdSize</span><span class=p>))</span>
</span></span><span class=line><span class=cl>         <span class=nx>pd</span><span class=p>.</span><span class=nx>link</span> <span class=p>=</span> <span class=nx>c</span><span class=p>.</span><span class=nx>first</span>
</span></span><span class=line><span class=cl>         <span class=nx>c</span><span class=p>.</span><span class=nx>first</span> <span class=p>=</span> <span class=nx>pd</span>
</span></span><span class=line><span class=cl>     <span class=p>}</span>
</span></span><span class=line><span class=cl> <span class=p>}</span>
</span></span><span class=line><span class=cl> <span class=c1>// 摘下表头的 pollDesc 并返回
</span></span></span><span class=line><span class=cl><span class=c1></span> <span class=nx>pd</span> <span class=o>:=</span> <span class=nx>c</span><span class=p>.</span><span class=nx>first</span>
</span></span><span class=line><span class=cl> <span class=nx>c</span><span class=p>.</span><span class=nx>first</span> <span class=p>=</span> <span class=nx>pd</span><span class=p>.</span><span class=nx>link</span>
</span></span><span class=line><span class=cl> <span class=nf>lockInit</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>pd</span><span class=p>.</span><span class=nx>lock</span><span class=p>,</span> <span class=nx>lockRankPollDesc</span><span class=p>)</span> <span class=c1>// Go runtime 内部的锁实现了层级，见 runtime/lockrank.go
</span></span></span><span class=line><span class=cl><span class=c1></span> <span class=nf>unlock</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>c</span><span class=p>.</span><span class=nx>lock</span><span class=p>)</span>
</span></span><span class=line><span class=cl> <span class=k>return</span> <span class=nx>pd</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div></li></ol><pre tabindex=0><code>`(*pollCache).free()`回收`pollDesc`，将其添加到表头。
```go
func (c *pollCache) free(pd *pollDesc) {
    lock(&amp;c.lock)
    pd.link = c.first
    c.first = pd
    unlock(&amp;c.lock)
}
</code></pre><p>注意，<code>(*pollCache).alloc()</code>分配的<code>pollDesc</code>的<code>rg</code>/<code>wg</code>均为<code>pdNil</code>，<code>(*pollCache).free()</code>没有修改字段<code>rg</code>/<code>wg</code>。</p><p>分配和回收有以下两个断言：</p><ul><li><code>pollCache</code>中的<code>polLDesc</code>的<code>rg</code>/<code>wg</code>要么是<code>pdNil</code>，要么是<code>pdReady</code>。</li><li><code>(*pollCache).free()</code>回收的<code>polLDesc</code>的<code>rg</code>/<code>wg</code>要么是<code>pdNil</code>，要么是<code>pdReady</code>。</li></ul><h2 id=netpoller-基础函数>netpoller 基础函数</h2><p>由于不同平台上的 IO 多路复用接口不同，能力也各不相同（Linux 的 epoll 不支持 disk IO，但 FreeBSD 的 kqueue 支持），Go runtime 在 runtime/netpoll.go 中定义了以下平台无关的接口，通过<code>go:build</code>条件编译，调用到对应平台的实现。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// Integrated network poller (platform-independent part).
</span></span></span><span class=line><span class=cl><span class=c1>// A particular implementation (epoll/kqueue/port/AIX/Windows)
</span></span></span><span class=line><span class=cl><span class=c1>// must define the following functions:
</span></span></span><span class=line><span class=cl><span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1>// func netpollinit()
</span></span></span><span class=line><span class=cl><span class=c1>//     Initialize the poller. Only called once.
</span></span></span><span class=line><span class=cl><span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1>// func netpollopen(fd uintptr, pd *pollDesc) int32
</span></span></span><span class=line><span class=cl><span class=c1>//     Arm edge-triggered notifications for fd. The pd argument is to pass
</span></span></span><span class=line><span class=cl><span class=c1>//     back to netpollready when fd is ready. Return an errno value.
</span></span></span><span class=line><span class=cl><span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1>// func netpollclose(fd uintptr) int32
</span></span></span><span class=line><span class=cl><span class=c1>//     Disable notifications for fd. Return an errno value.
</span></span></span><span class=line><span class=cl><span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1>// func netpoll(delta int64) gList
</span></span></span><span class=line><span class=cl><span class=c1>//     Poll the network. If delta &lt; 0, block indefinitely. If delta == 0,
</span></span></span><span class=line><span class=cl><span class=c1>//     poll without blocking. If delta &gt; 0, block for up to delta nanoseconds.
</span></span></span><span class=line><span class=cl><span class=c1>//     Return a list of goroutines built by calling netpollready.
</span></span></span><span class=line><span class=cl><span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1>// func netpollBreak()
</span></span></span><span class=line><span class=cl><span class=c1>//     Wake up the network poller, assumed to be blocked in netpoll.
</span></span></span><span class=line><span class=cl><span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1>// func netpollIsPollDescriptor(fd uintptr) bool
</span></span></span><span class=line><span class=cl><span class=c1>//     Reports whether fd is a file descriptor used by the poller.
</span></span></span></code></pre></div><p>netpoller 提供了种种接口声明在内部包 internal/poll/fd_poll_runtime.go 中，实现在 runtime/netpoll.go 中，以<code>poll_runtime_</code>为前缀。因此，Go 语言运行时没有给用户提供任何 netpoller 接口。</p><h3 id=初始化轮询器>初始化轮询器</h3><p>互斥锁<code>netpollInitLock</code>保护<code>netpollInited</code>，<code>netpollInited</code>指示是否已初始化轮询器。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>var</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=nx>netpollInitLock</span> <span class=nx>mutex</span>
</span></span><span class=line><span class=cl>    <span class=nx>netpollInited</span>   <span class=nx>atomic</span><span class=p>.</span><span class=nx>Uint32</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nx>pollcache</span>      <span class=nx>pollCache</span>
</span></span><span class=line><span class=cl>    <span class=nx>netpollWaiters</span> <span class=nx>atomic</span><span class=p>.</span><span class=nx>Uint32</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span></code></pre></div><p><code>netpollGenericInit()</code>调用<code>netpollinit()</code>初始化 poller，<code>netpollGenericInit()</code>相当于<code>Once.Do()</code>。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>netpollGenericInit</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>netpollInited</span><span class=p>.</span><span class=nf>Load</span><span class=p>()</span> <span class=o>==</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>lockInit</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>netpollInitLock</span><span class=p>,</span> <span class=nx>lockRankNetpollInit</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=nf>lock</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>netpollInitLock</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nx>netpollInited</span><span class=p>.</span><span class=nf>Load</span><span class=p>()</span> <span class=o>==</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nf>netpollinit</span><span class=p>()</span>
</span></span><span class=line><span class=cl>            <span class=nx>netpollInited</span><span class=p>.</span><span class=nf>Store</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=nf>unlock</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>netpollInitLock</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Linux 上的<code>netpollinit()</code>做以下几件事：</p><ol><li>创建 edge-trigged 的 epoll 轮询器。</li><li>创建一个 pipe 用于打断 netpoller。</li><li>注册读端的读操作到 epoll 上，其<code>syscall.EpollEvent</code>的<code>data</code>字段是<code>netpollBreakRd</code>（pipe 的读端）。</li></ol><p>该 pipe 用于和 netpoller 通信：netpoller 监听 pipe 的读端，调用<code>netpollBreak()</code>向该 pipe 写入数据，netpoller 监听到发生 pipe 上的读事件，从而打断 netpoller。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// runtime/netpoll.go
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>netpollinit</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>var</span> <span class=nx>errno</span> <span class=kt>uintptr</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 创建 epoll 轮询器
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>epfd</span><span class=p>,</span> <span class=nx>errno</span> <span class=p>=</span> <span class=nx>syscall</span><span class=p>.</span><span class=nf>EpollCreate1</span><span class=p>(</span><span class=nx>syscall</span><span class=p>.</span><span class=nx>EPOLL_CLOEXEC</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>errno</span> <span class=o>!=</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nb>println</span><span class=p>(</span><span class=s>&#34;runtime: epollcreate failed with&#34;</span><span class=p>,</span> <span class=nx>errno</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=nf>throw</span><span class=p>(</span><span class=s>&#34;runtime: netpollinit failed&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 创建用于打断 poller 的 pipe
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>r</span><span class=p>,</span> <span class=nx>w</span><span class=p>,</span> <span class=nx>errpipe</span> <span class=o>:=</span> <span class=nf>nonblockingPipe</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>errpipe</span> <span class=o>!=</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nb>println</span><span class=p>(</span><span class=s>&#34;runtime: pipe failed with&#34;</span><span class=p>,</span> <span class=o>-</span><span class=nx>errpipe</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=nf>throw</span><span class=p>(</span><span class=s>&#34;runtime: pipe failed&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 注册 pipe 上的读事件到 poller
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>ev</span> <span class=o>:=</span> <span class=nx>syscall</span><span class=p>.</span><span class=nx>EpollEvent</span><span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>Events</span><span class=p>:</span> <span class=nx>syscall</span><span class=p>.</span><span class=nx>EPOLLIN</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=o>*</span><span class=p>(</span><span class=o>**</span><span class=kt>uintptr</span><span class=p>)(</span><span class=nx>unsafe</span><span class=p>.</span><span class=nf>Pointer</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>ev</span><span class=p>.</span><span class=nx>Data</span><span class=p>))</span> <span class=p>=</span> <span class=o>&amp;</span><span class=nx>netpollBreakRd</span>
</span></span><span class=line><span class=cl>    <span class=nx>errno</span> <span class=p>=</span> <span class=nx>syscall</span><span class=p>.</span><span class=nf>EpollCtl</span><span class=p>(</span><span class=nx>epfd</span><span class=p>,</span> <span class=nx>syscall</span><span class=p>.</span><span class=nx>EPOLL_CTL_ADD</span><span class=p>,</span> <span class=nx>r</span><span class=p>,</span> <span class=o>&amp;</span><span class=nx>ev</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>errno</span> <span class=o>!=</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nb>println</span><span class=p>(</span><span class=s>&#34;runtime: epollctl failed with&#34;</span><span class=p>,</span> <span class=nx>errno</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=nf>throw</span><span class=p>(</span><span class=s>&#34;runtime: epollctl failed&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nx>netpollBreakRd</span> <span class=p>=</span> <span class=nb>uintptr</span><span class=p>(</span><span class=nx>r</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>netpollBreakWr</span> <span class=p>=</span> <span class=nb>uintptr</span><span class=p>(</span><span class=nx>w</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Go runtime 中只有一个 epoll 轮询器，定义为全局变量。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// runtime/netpoll.go
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>var</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=nx>epfd</span> <span class=kt>int32</span> <span class=p>=</span> <span class=o>-</span><span class=mi>1</span> <span class=c1>// epoll descriptor
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>)</span>
</span></span></code></pre></div><h3 id=注册文件描述符>注册文件描述符</h3><p><code>netpollopen()</code>封装了<code>epoll_ctl(2)</code>，注册文件描述符上的读写事件到 netpoller 上，其中<code>epoll_event</code>的<code>data</code>字段设置为 epoll fd。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// runtime/netpoll.go
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>netpollopen</span><span class=p>(</span><span class=nx>fd</span> <span class=kt>uintptr</span><span class=p>,</span> <span class=nx>pd</span> <span class=o>*</span><span class=nx>pollDesc</span><span class=p>)</span> <span class=kt>uintptr</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>var</span> <span class=nx>ev</span> <span class=nx>syscall</span><span class=p>.</span><span class=nx>EpollEvent</span>
</span></span><span class=line><span class=cl>    <span class=nx>ev</span><span class=p>.</span><span class=nx>Events</span> <span class=p>=</span> <span class=nx>syscall</span><span class=p>.</span><span class=nx>EPOLLIN</span> <span class=p>|</span> <span class=nx>syscall</span><span class=p>.</span><span class=nx>EPOLLOUT</span> <span class=p>|</span> <span class=nx>syscall</span><span class=p>.</span><span class=nx>EPOLLRDHUP</span> <span class=p>|</span> <span class=nx>syscall</span><span class=p>.</span><span class=nx>EPOLLET</span>
</span></span><span class=line><span class=cl>    <span class=o>*</span><span class=p>(</span><span class=o>**</span><span class=nx>pollDesc</span><span class=p>)(</span><span class=nx>unsafe</span><span class=p>.</span><span class=nf>Pointer</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>ev</span><span class=p>.</span><span class=nx>Data</span><span class=p>))</span> <span class=p>=</span> <span class=nx>pd</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>syscall</span><span class=p>.</span><span class=nf>EpollCtl</span><span class=p>(</span><span class=nx>epfd</span><span class=p>,</span> <span class=nx>syscall</span><span class=p>.</span><span class=nx>EPOLL_CTL_ADD</span><span class=p>,</span> <span class=nb>int32</span><span class=p>(</span><span class=nx>fd</span><span class=p>),</span> <span class=o>&amp;</span><span class=nx>ev</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=检测文件描述符是否由-poller-管理>检测文件描述符是否由 poller 管理</h3><p><code>epoll_event</code>的<code>data</code>字段可以用于判断该描述符是否由 poller 管理，在 Go 1.9 中只用于测试。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// IsPollDescriptor reports whether fd is the descriptor being used by the poller.
</span></span></span><span class=line><span class=cl><span class=c1>// This is only used for testing.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>IsPollDescriptor</span><span class=p>(</span><span class=nx>fd</span> <span class=kt>uintptr</span><span class=p>)</span> <span class=kt>bool</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nf>runtime_isPollServerDescriptor</span><span class=p>(</span><span class=nx>fd</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=删除文件描述符>删除文件描述符</h3><p>从 poller 删除该描述符同理，直接调用<code>epoll_ctl(2)</code>即可。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// runtime/netpoll.go
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>netpollclose</span><span class=p>(</span><span class=nx>fd</span> <span class=kt>uintptr</span><span class=p>)</span> <span class=kt>uintptr</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>var</span> <span class=nx>ev</span> <span class=nx>syscall</span><span class=p>.</span><span class=nx>EpollEvent</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>syscall</span><span class=p>.</span><span class=nf>EpollCtl</span><span class=p>(</span><span class=nx>epfd</span><span class=p>,</span> <span class=nx>syscall</span><span class=p>.</span><span class=nx>EPOLL_CTL_DEL</span><span class=p>,</span> <span class=nb>int32</span><span class=p>(</span><span class=nx>fd</span><span class=p>),</span> <span class=o>&amp;</span><span class=nx>ev</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=中断-netpoller>中断 netpoller</h3><p>前面初始化轮询器时，把 pipe 的读端上的读事件注册到了 epoll 上，因此只要向该 pipe 写数据，就能触发 epoll，从而打断 netpoller。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// netpollBreak interrupts an epollwait.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>netpollBreak</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Failing to cas indicates there is an in-flight wakeup, so we&#39;re done here.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=p>!</span><span class=nx>netpollWakeSig</span><span class=p>.</span><span class=nf>CompareAndSwap</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kd>var</span> <span class=nx>b</span> <span class=kt>byte</span>
</span></span><span class=line><span class=cl>        <span class=nx>n</span> <span class=o>:=</span> <span class=nf>write</span><span class=p>(</span><span class=nx>netpollBreakWr</span><span class=p>,</span> <span class=nx>unsafe</span><span class=p>.</span><span class=nf>Pointer</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>b</span><span class=p>),</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nx>n</span> <span class=o>==</span> <span class=mi>1</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>break</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nx>n</span> <span class=o>==</span> <span class=o>-</span><span class=nx>_EINTR</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>continue</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nx>n</span> <span class=o>==</span> <span class=o>-</span><span class=nx>_EAGAIN</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=nb>println</span><span class=p>(</span><span class=s>&#34;runtime: netpollBreak write failed with&#34;</span><span class=p>,</span> <span class=o>-</span><span class=nx>n</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=nf>throw</span><span class=p>(</span><span class=s>&#34;runtime: netpollBreak write failed&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>在死循环中写 pipe 是因为 UNIX 上系统中断可被信号（signal）中断，中断的系统调用返回错误码<code>EINTR</code>，for 循环处理<code>write(2)</code>被中断的情况。</p><h3 id=文件描述符状态>文件描述符状态</h3><p><code>pollDesc</code>结构体的<code>atomicInfo</code>字段维护文件描述符<code>fd</code>的<strong>轮询状态</strong>，包括 IO 超时，描述符关闭等。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// runtime/netpoll.go
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>type</span> <span class=nx>pollDesc</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>fd</span>   <span class=kt>uintptr</span>   <span class=c1>// constant for pollDesc usage lifetime
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=c1>// atomicInfo holds bits from closing, rd, and wd,
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// which are only ever written while holding the lock,
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// summarized for use by netpollcheckerr,
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// which cannot acquire the lock.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// After writing these fields under lock in a way that
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// might change the summary, code must call publishInfo
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// before releasing the lock.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// Code that changes fields and then calls netpollunblock
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// (while still holding the lock) must call publishInfo
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// before calling netpollunblock, because publishInfo is what
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// stops netpollblock from blocking anew
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// (by changing the result of netpollcheckerr).
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// atomicInfo also holds the eventErr bit,
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// recording whether a poll event on the fd got an error;
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// atomicInfo is the only source of truth for that bit.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>atomicInfo</span> <span class=nx>atomic</span><span class=p>.</span><span class=nx>Uint32</span> <span class=c1>// atomic pollInfo
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>//...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><p><code>atomicInfo</code>维护的状态最终用于判断文件描述符是否出错。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// runtime/netpoll.go
</span></span></span><span class=line><span class=cl><span class=c1>// Error codes returned by runtime_pollReset and runtime_pollWait.
</span></span></span><span class=line><span class=cl><span class=c1>// These must match the values in internal/poll/fd_poll_runtime.go.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>const</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=nx>pollNoError</span>        <span class=p>=</span> <span class=mi>0</span> <span class=c1>// no error
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>pollErrClosing</span>     <span class=p>=</span> <span class=mi>1</span> <span class=c1>// descriptor is closed
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>pollErrTimeout</span>     <span class=p>=</span> <span class=mi>2</span> <span class=c1>// I/O timeout
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>pollErrNotPollable</span> <span class=p>=</span> <span class=mi>3</span> <span class=c1>// general error polling descriptor
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>)</span>
</span></span></code></pre></div><p><code>atomicInfo</code>被设置为私有变量，由<code>pushInfo()</code>更新，通过<code>netpollcheckerr()</code>判断是否出错。</p><p>会修改文件描述符状态的代码，必须在操作完成后调用<code>pushInfo()</code> 更新状态。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// runtime/netpoll.go
</span></span></span><span class=line><span class=cl><span class=c1>// publishInfo updates pd.atomicInfo (returned by pd.info)
</span></span></span><span class=line><span class=cl><span class=c1>// using the other values in pd.
</span></span></span><span class=line><span class=cl><span class=c1>// It must be called while holding pd.lock,
</span></span></span><span class=line><span class=cl><span class=c1>// and it must be called after changing anything
</span></span></span><span class=line><span class=cl><span class=c1>// that might affect the info bits.
</span></span></span><span class=line><span class=cl><span class=c1>// In practice this means after changing closing
</span></span></span><span class=line><span class=cl><span class=c1>// or changing rd or wd from &lt; 0 to &gt;= 0.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>pd</span> <span class=o>*</span><span class=nx>pollDesc</span><span class=p>)</span> <span class=nf>publishInfo</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>var</span> <span class=nx>info</span> <span class=kt>uint32</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>pd</span><span class=p>.</span><span class=nx>closing</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>info</span> <span class=o>|=</span> <span class=nx>pollClosing</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>pd</span><span class=p>.</span><span class=nx>rd</span> <span class=p>&lt;</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>info</span> <span class=o>|=</span> <span class=nx>pollExpiredReadDeadline</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>pd</span><span class=p>.</span><span class=nx>wd</span> <span class=p>&lt;</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>info</span> <span class=o>|=</span> <span class=nx>pollExpiredWriteDeadline</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Set all of x except the pollEventErr bit.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>x</span> <span class=o>:=</span> <span class=nx>pd</span><span class=p>.</span><span class=nx>atomicInfo</span><span class=p>.</span><span class=nf>Load</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>!</span><span class=nx>pd</span><span class=p>.</span><span class=nx>atomicInfo</span><span class=p>.</span><span class=nf>CompareAndSwap</span><span class=p>(</span><span class=nx>x</span><span class=p>,</span> <span class=p>(</span><span class=nx>x</span><span class=o>&amp;</span><span class=nx>pollEventErr</span><span class=p>)|</span><span class=nx>info</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>x</span> <span class=p>=</span> <span class=nx>pd</span><span class=p>.</span><span class=nx>atomicInfo</span><span class=p>.</span><span class=nf>Load</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p><code>netpollcheckerr()</code>通过位运算从<code>atomicInfo</code>中提取状态并返回错误。前面提到，<code>atomicInfo</code>维护的是文件描述符的轮询状态，而非文件描述符上系统调用的状态。也就是说，<code>netpollcheckerr()</code>不判断其上的系统调用是否成功，即使该描述符上的系统调用出错，<code>netpollcheckerr()</code>也返回<code>true</code>。</p><p>具体的系统调用的错误处理，应当交给 Go 语言封装系统调用的函数，而非 netpoller。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>netpollcheckerr</span><span class=p>(</span><span class=nx>pd</span> <span class=o>*</span><span class=nx>pollDesc</span><span class=p>,</span> <span class=nx>mode</span> <span class=kt>int32</span><span class=p>)</span> <span class=kt>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>info</span> <span class=o>:=</span> <span class=nx>pd</span><span class=p>.</span><span class=nf>info</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>info</span><span class=p>.</span><span class=nf>closing</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nx>pollErrClosing</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=nx>mode</span> <span class=o>==</span> <span class=sc>&#39;r&#39;</span> <span class=o>&amp;&amp;</span> <span class=nx>info</span><span class=p>.</span><span class=nf>expiredReadDeadline</span><span class=p>())</span> <span class=o>||</span> <span class=p>(</span><span class=nx>mode</span> <span class=o>==</span> <span class=sc>&#39;w&#39;</span> <span class=o>&amp;&amp;</span> <span class=nx>info</span><span class=p>.</span><span class=nf>expiredWriteDeadline</span><span class=p>())</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nx>pollErrTimeout</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Report an event scanning error only on a read event.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// An error on a write event will be captured in a subsequent
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// write call that is able to report a more specific error.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=nx>mode</span> <span class=o>==</span> <span class=sc>&#39;r&#39;</span> <span class=o>&amp;&amp;</span> <span class=nx>info</span><span class=p>.</span><span class=nf>eventErr</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nx>pollErrNotPollable</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>pollNoError</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=goroutine-挂起与恢复>goroutine 挂起与恢复</h2><p>每个<code>pollDesc</code>都关联了一个读者 goroutine、一个写者 goroutine，当该文件描述符不读写时挂起响应的读写者。</p><p><code>pollDesc</code>上读写者的挂起与恢复由一个有限状态机驱动，状态如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// runtime/netpoller.go
</span></span></span><span class=line><span class=cl><span class=c1>// pollDesc contains 2 binary semaphores, rg and wg, to park reader and writer
</span></span></span><span class=line><span class=cl><span class=c1>// goroutines respectively. The semaphore can be in the following states:
</span></span></span><span class=line><span class=cl><span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1>//    pdReady - io readiness notification is pending;
</span></span></span><span class=line><span class=cl><span class=c1>//              a goroutine consumes the notification by changing the state to pdNil.
</span></span></span><span class=line><span class=cl><span class=c1>//    pdWait - a goroutine prepares to park on the semaphore, but not yet parked;
</span></span></span><span class=line><span class=cl><span class=c1>//             the goroutine commits to park by changing the state to G pointer,
</span></span></span><span class=line><span class=cl><span class=c1>//             or, alternatively, concurrent io notification changes the state to pdReady,
</span></span></span><span class=line><span class=cl><span class=c1>//             or, alternatively, concurrent timeout/close changes the state to pdNil.
</span></span></span><span class=line><span class=cl><span class=c1>//    G pointer - the goroutine is blocked on the semaphore;
</span></span></span><span class=line><span class=cl><span class=c1>//                io notification or timeout/close changes the state to pdReady or pdNil respectively
</span></span></span><span class=line><span class=cl><span class=c1>//                and unparks the goroutine.
</span></span></span><span class=line><span class=cl><span class=c1>//    pdNil - none of the above.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>const</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=nx>pdNil</span>   <span class=kt>uintptr</span> <span class=p>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>    <span class=nx>pdReady</span> <span class=kt>uintptr</span> <span class=p>=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>    <span class=nx>pdWait</span>  <span class=kt>uintptr</span> <span class=p>=</span> <span class=mi>2</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span></code></pre></div><p><code>pidNil</code>是<code>rg</code>/<code>wg</code>的初始状态，其值为 0，相当于<code>Nil</code>。<code>pollDesc</code>上的 goroutine 已经阻塞（park）时，设置为该 goroutine 的指针。</p><p>状态转换图如下。</p><p><figure><img src=images/netpoller-polldesc-goroutine-fsm.excalidraw.svg alt="Figure 5: The FSM or goroutine"><figcaption>Figure 5: The FSM or goroutine</figcaption></figure></p><h3 id=netpollblock>netpollblock</h3><p><code>netpollblock(pd *pollDesc, mode int32, waitio bool)</code><strong>试图阻塞</strong>文件<code>pd</code>上的读写者，返回真值指示 IO 是否就绪。参数<code>mode</code>指示对文件的操作模式（读/写/读写），<code>waitio</code>判断是否由于等待 IO 而阻塞 goroutine。</p><p><code>netpollblock()</code>接收的<code>pollDesc</code>上的 goroutine 一定处于<code>pdReady</code>（已<code>netpollunblock()</code>）或<code>pdNil</code>(文件初始状态)。</p><ul><li><p><code>pdReady</code>状态：该状态由<code>netpollunblock()</code>函数设置，表示一次 IO 就绪。<code>netpollblock()</code>消耗一次 IO 就绪通告，将状态从<code>pdReady</code>转换到<code>pdNil</code>。</p></li><li><p><code>pdNil</code>状态：该状态是<code>pollDesc</code>上 goroutine 默认状态，转换为<code>pdWait</code>。</p></li><li><p><code>pdWait</code>状态：该状态表示 goroutine 将要阻塞但还未阻塞，<code>netpollblock()</code>调用<code>gopark()</code>阻塞该 goroutine。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// returns true if IO is ready, or false if timed out or closed
</span></span></span><span class=line><span class=cl><span class=c1>// waitio - wait only for completed IO, ignore errors
</span></span></span><span class=line><span class=cl><span class=c1>// Concurrent calls to netpollblock in the same mode are forbidden, as pollDesc
</span></span></span><span class=line><span class=cl><span class=c1>// can hold only a single waiting goroutine for each mode.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>netpollblock</span><span class=p>(</span><span class=nx>pd</span> <span class=o>*</span><span class=nx>pollDesc</span><span class=p>,</span> <span class=nx>mode</span> <span class=kt>int32</span><span class=p>,</span> <span class=nx>waitio</span> <span class=kt>bool</span><span class=p>)</span> <span class=kt>bool</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>gpp</span> <span class=o>:=</span> <span class=o>&amp;</span><span class=nx>pd</span><span class=p>.</span><span class=nx>rg</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=nx>mode</span> <span class=o>==</span> <span class=sc>&#39;w&#39;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=nx>gpp</span> <span class=p>=</span> <span class=o>&amp;</span><span class=nx>pd</span><span class=p>.</span><span class=nx>wg</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// set the gpp semaphore to pdWait
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>for</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=c1>// Consume notification if already ready.
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=k>if</span> <span class=nx>gpp</span><span class=p>.</span><span class=nf>CompareAndSwap</span><span class=p>(</span><span class=nx>pdReady</span><span class=p>,</span> <span class=nx>pdNil</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>          <span class=k>return</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl>      <span class=p>}</span>
</span></span><span class=line><span class=cl>      <span class=k>if</span> <span class=nx>gpp</span><span class=p>.</span><span class=nf>CompareAndSwap</span><span class=p>(</span><span class=nx>pdNil</span><span class=p>,</span> <span class=nx>pdWait</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>          <span class=k>break</span>
</span></span><span class=line><span class=cl>      <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      <span class=c1>// Double check that this isn&#39;t corrupt; otherwise we&#39;d loop
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=c1>// forever.
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=k>if</span> <span class=nx>v</span> <span class=o>:=</span> <span class=nx>gpp</span><span class=p>.</span><span class=nf>Load</span><span class=p>();</span> <span class=nx>v</span> <span class=o>!=</span> <span class=nx>pdReady</span> <span class=o>&amp;&amp;</span> <span class=nx>v</span> <span class=o>!=</span> <span class=nx>pdNil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>          <span class=nf>throw</span><span class=p>(</span><span class=s>&#34;runtime: double wait&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// need to recheck error states after setting gpp to pdWait
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// this is necessary because runtime_pollUnblock/runtime_pollSetDeadline/deadlineimpl
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// do the opposite: store to closing/rd/wd, publishInfo, load of rg/wg
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>if</span> <span class=nx>waitio</span> <span class=o>||</span> <span class=nf>netpollcheckerr</span><span class=p>(</span><span class=nx>pd</span><span class=p>,</span> <span class=nx>mode</span><span class=p>)</span> <span class=o>==</span> <span class=nx>pollNoError</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=nf>gopark</span><span class=p>(</span><span class=nx>netpollblockcommit</span><span class=p>,</span> <span class=nx>unsafe</span><span class=p>.</span><span class=nf>Pointer</span><span class=p>(</span><span class=nx>gpp</span><span class=p>),</span> <span class=nx>waitReasonIOWait</span><span class=p>,</span> <span class=nx>traceEvGoBlockNet</span><span class=p>,</span> <span class=mi>5</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=c1>// be careful to not lose concurrent pdReady notification
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=nx>old</span> <span class=o>:=</span> <span class=nx>gpp</span><span class=p>.</span><span class=nf>Swap</span><span class=p>(</span><span class=nx>pdNil</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=nx>old</span> <span class=p>&gt;</span> <span class=nx>pdWait</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=nf>throw</span><span class=p>(</span><span class=s>&#34;runtime: corrupted polldesc&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nx>old</span> <span class=o>==</span> <span class=nx>pdReady</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div></li></ul><p><code>gopark()</code>是 Go scheduler 中负责阻塞 goroutine 的函数，原型如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// Puts the current goroutine into a waiting state and calls unlockf on the
</span></span></span><span class=line><span class=cl><span class=c1>// system stack.
</span></span></span><span class=line><span class=cl><span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1>// If unlockf returns false, the goroutine is resumed.
</span></span></span><span class=line><span class=cl><span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1>// unlockf must not access this G&#39;s stack, as it may be moved between
</span></span></span><span class=line><span class=cl><span class=c1>// the call to gopark and the call to unlockf.
</span></span></span><span class=line><span class=cl><span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1>// Note that because unlockf is called after putting the G into a waiting
</span></span></span><span class=line><span class=cl><span class=c1>// state, the G may have already been readied by the time unlockf is called
</span></span></span><span class=line><span class=cl><span class=c1>// unless there is external synchronization preventing the G from being
</span></span></span><span class=line><span class=cl><span class=c1>// readied. If unlockf returns false, it must guarantee that the G cannot be
</span></span></span><span class=line><span class=cl><span class=c1>// externally readied.
</span></span></span><span class=line><span class=cl><span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1>// Reason explains why the goroutine has been parked. It is displayed in stack
</span></span></span><span class=line><span class=cl><span class=c1>// traces and heap dumps. Reasons should be unique and descriptive. Do not
</span></span></span><span class=line><span class=cl><span class=c1>// re-use reasons, add new ones.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>gopark</span><span class=p>(</span><span class=nx>unlockf</span> <span class=kd>func</span><span class=p>(</span><span class=o>*</span><span class=nx>g</span><span class=p>,</span> <span class=nx>unsafe</span><span class=p>.</span><span class=nx>Pointer</span><span class=p>)</span> <span class=kt>bool</span><span class=p>,</span> <span class=nx>lock</span> <span class=nx>unsafe</span><span class=p>.</span><span class=nx>Pointer</span><span class=p>,</span> <span class=nx>reason</span> <span class=nx>waitReason</span><span class=p>,</span> <span class=nx>traceEv</span> <span class=kt>byte</span><span class=p>,</span> <span class=nx>traceskip</span> <span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
</span></span></code></pre></div><p>简单地说，这里的<code>gopark()</code>阻塞 goroutine <code>gpp</code>，调用回调函数<code>netpollblockcommit()</code>，并将该 goroutine 阻塞的原因设置为<code>waitReasonIOWait</code>。</p><p><code>netpollblockcommit()</code>做两件事：</p><ol><li>将<code>pollDesc</code>中的<code>rg</code>或<code>wg</code>设置为指向该 goroutine 的指针。</li><li>递增<code>netpollWaiters</code>原子变量。</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>netpollblockcommit</span><span class=p>(</span><span class=nx>gp</span> <span class=o>*</span><span class=nx>g</span><span class=p>,</span> <span class=nx>gpp</span> <span class=nx>unsafe</span><span class=p>.</span><span class=nx>Pointer</span><span class=p>)</span> <span class=kt>bool</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>r</span> <span class=o>:=</span> <span class=nx>atomic</span><span class=p>.</span><span class=nf>Casuintptr</span><span class=p>((</span><span class=o>*</span><span class=kt>uintptr</span><span class=p>)(</span><span class=nx>gpp</span><span class=p>),</span> <span class=nx>pdWait</span><span class=p>,</span> <span class=nb>uintptr</span><span class=p>(</span><span class=nx>unsafe</span><span class=p>.</span><span class=nf>Pointer</span><span class=p>(</span><span class=nx>gp</span><span class=p>)))</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>r</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// Bump the count of goroutines waiting for the poller.
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// The scheduler uses this to decide whether to block
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// waiting for the poller if there is nothing else to do.
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nx>netpollWaiters</span><span class=p>.</span><span class=nf>Add</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>r</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>原子变量<code>netpollWaiters</code>用于避免不必要的 epoll 阻塞。没有 goroutine 等待 netpoller 唤醒时，不轮询 IO 事件。<code>findRunnable()</code>展示了这一优化。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// runtime/proc.go
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>findRunnable</span><span class=p>()</span> <span class=p>(</span><span class=nx>gp</span> <span class=o>*</span><span class=nx>g</span><span class=p>,</span> <span class=nx>inheritTime</span><span class=p>,</span> <span class=nx>tryWakeP</span> <span class=kt>bool</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=c1>// Poll network.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// This netpoll is only an optimization before we resort to stealing.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// We can safely skip it if there are no waiters or a thread is blocked
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// in netpoll already. If there is any kind of logical race with that
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// blocked thread (e.g. it has already returned from netpoll, but does
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// not set lastpoll yet), this thread will do blocking netpoll below
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// anyway.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=nf>netpollinited</span><span class=p>()</span> <span class=o>&amp;&amp;</span> <span class=nx>netpollWaiters</span><span class=p>.</span><span class=nf>Load</span><span class=p>()</span> <span class=p>&gt;</span> <span class=mi>0</span> <span class=o>&amp;&amp;</span> <span class=nx>sched</span><span class=p>.</span><span class=nx>lastpoll</span><span class=p>.</span><span class=nf>Load</span><span class=p>()</span> <span class=o>!=</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nx>list</span> <span class=o>:=</span> <span class=nf>netpoll</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span> <span class=p>!</span><span class=nx>list</span><span class=p>.</span><span class=nf>empty</span><span class=p>()</span> <span class=p>{</span> <span class=c1>// non-blocking
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=nx>gp</span> <span class=o>:=</span> <span class=nx>list</span><span class=p>.</span><span class=nf>pop</span><span class=p>()</span>
</span></span><span class=line><span class=cl>            <span class=nf>injectglist</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>list</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=nf>casgstatus</span><span class=p>(</span><span class=nx>gp</span><span class=p>,</span> <span class=nx>_Gwaiting</span><span class=p>,</span> <span class=nx>_Grunnable</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=nx>trace</span><span class=p>.</span><span class=nx>enabled</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=nf>traceGoUnpark</span><span class=p>(</span><span class=nx>gp</span><span class=p>,</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=nx>gp</span><span class=p>,</span> <span class=kc>false</span><span class=p>,</span> <span class=kc>false</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><h3 id=netpollunblock>netpollunblock</h3><p><code>netpollunblock(pd *pollDesc, mode int32, ioready bool)</code>是<code>netpollbock()</code>的逆操作，修改对应 goroutine 的状态，并返回可运行的 goroutine 的指针。</p><p><code>netpollunblock()</code>可以接收全部四种 goroutine 状态的<code>pollDesc</code>。</p><ul><li><code>pdNil</code>：该状态表示初始状态。若<code>ioready</code>为真，则切换到<code>pdReady</code>，返回<code>nil</code>；否则，不修改状态，直接返回<code>nil</code>。<code>ioready</code>为真，说明其上 IO 就绪，因此 netpoller 恢复其上的 goroutine；<code>ioready</code>为假，说明该<code>netpollunblock()</code>因 IO 超时或取消 IO 而被调用。</li><li><code>pdReady</code>：该状态表示 IO 就绪。goroutine 未阻塞，不需要恢复该 goroutine，因此直接返回<code>nil</code>。</li><li><code>pdWait</code>：该状态表示 goroutine 即将被阻塞，还未被阻塞。因此根据<code>ioready</code>切换到<code>pdNil</code>或<code>pdReady</code>状态并返回<code>nil</code>（ <code>pdNil</code>）。</li><li>goroutine 指针：该 goroutine 阻塞后由<code>netpollblockcommit()</code>设置。根据<code>ioready</code>切换到<code>pdNil</code>或<code>pdReady</code>，返回该 goroutine 指针。</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>netpollunblock</span><span class=p>(</span><span class=nx>pd</span> <span class=o>*</span><span class=nx>pollDesc</span><span class=p>,</span> <span class=nx>mode</span> <span class=kt>int32</span><span class=p>,</span> <span class=nx>ioready</span> <span class=kt>bool</span><span class=p>)</span> <span class=o>*</span><span class=nx>g</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>gpp</span> <span class=o>:=</span> <span class=o>&amp;</span><span class=nx>pd</span><span class=p>.</span><span class=nx>rg</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>mode</span> <span class=o>==</span> <span class=sc>&#39;w&#39;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>gpp</span> <span class=p>=</span> <span class=o>&amp;</span><span class=nx>pd</span><span class=p>.</span><span class=nx>wg</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>old</span> <span class=o>:=</span> <span class=nx>gpp</span><span class=p>.</span><span class=nf>Load</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nx>old</span> <span class=o>==</span> <span class=nx>pdReady</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nx>old</span> <span class=o>==</span> <span class=nx>pdNil</span> <span class=o>&amp;&amp;</span> <span class=p>!</span><span class=nx>ioready</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=c1>// Only set pdReady for ioready. runtime_pollWait
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=c1>// will check for timeout/cancel before waiting.
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=k>return</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=kd>var</span> <span class=nx>new</span> <span class=kt>uintptr</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nx>ioready</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>new</span> <span class=p>=</span> <span class=nx>pdReady</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nx>gpp</span><span class=p>.</span><span class=nf>CompareAndSwap</span><span class=p>(</span><span class=nx>old</span><span class=p>,</span> <span class=nx>new</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=nx>old</span> <span class=o>==</span> <span class=nx>pdWait</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=nx>old</span> <span class=p>=</span> <span class=nx>pdNil</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=c1>// 注意，pdNil 的只为 0，相当于 Nil。
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=k>return</span> <span class=p>(</span><span class=o>*</span><span class=nx>g</span><span class=p>)(</span><span class=nx>unsafe</span><span class=p>.</span><span class=nf>Pointer</span><span class=p>(</span><span class=nx>old</span><span class=p>))</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p><code>netpollunblock()</code>只修改状态并返回 goroutine 指针，恢复 goroutine 的任务交给<code>netpollgoready()</code>。</p><p><code>netpollgoready()</code>是<code>netpollblockcommit()</code>的逆操作，完成以下两件事：</p><ol><li><p>递减<code>netpollWaiters</code></p></li><li><p>恢复 goroutine</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>netpollgoready</span><span class=p>(</span><span class=nx>gp</span> <span class=o>*</span><span class=nx>g</span><span class=p>,</span> <span class=nx>traceskip</span> <span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl> <span class=nx>netpollWaiters</span><span class=p>.</span><span class=nf>Add</span><span class=p>(</span><span class=o>-</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl> <span class=nf>goready</span><span class=p>(</span><span class=nx>gp</span><span class=p>,</span> <span class=nx>traceskip</span><span class=o>+</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div></li></ol><h2 id=轮询-io-事件>轮询 IO 事件</h2><p>所有文件描述符都注册到一个 epoll 轮询器上，因此<code>netpoll()</code>轮询整个系统中的 IO 事件：</p><ol><li>根据参数<code>delay</code>设置 epoll 超时时间；</li><li>调用<code>epoll_wait()</code>轮询 IO 事件；</li><li>处理 IO 事件：<ol><li>通过<code>netpollBreakRd</code>打断<code>netpoll()</code>；</li><li>epoll 错误，调用<code>(*pollDesc).setEventErr()</code>设置轮询错误；</li><li>IO 就绪，调用<code>netpollgoready()</code>恢复该文件描述符上阻塞的 goroutine。
<code>netpoll()</code>中的<code>syscall.EpollEvent</code>数组长度为 128，因此一次最多监听到 128 个事件。</li></ol></li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// netpoll checks for ready network connections.
</span></span></span><span class=line><span class=cl><span class=c1>// Returns list of goroutines that become runnable.
</span></span></span><span class=line><span class=cl><span class=c1>// delay &lt; 0: blocks indefinitely
</span></span></span><span class=line><span class=cl><span class=c1>// delay == 0: does not block, just polls
</span></span></span><span class=line><span class=cl><span class=c1>// delay &gt; 0: block for up to that many nanoseconds
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>netpoll</span><span class=p>(</span><span class=nx>delay</span> <span class=kt>int64</span><span class=p>)</span> <span class=nx>gList</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>epfd</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nx>gList</span><span class=p>{}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=kd>var</span> <span class=nx>waitms</span> <span class=kt>int32</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>delay</span> <span class=p>&lt;</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>waitms</span> <span class=p>=</span> <span class=o>-</span><span class=mi>1</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>else</span> <span class=k>if</span> <span class=nx>delay</span> <span class=o>==</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>waitms</span> <span class=p>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>else</span> <span class=k>if</span> <span class=nx>delay</span> <span class=p>&lt;</span> <span class=mf>1e6</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>waitms</span> <span class=p>=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>else</span> <span class=k>if</span> <span class=nx>delay</span> <span class=p>&lt;</span> <span class=mf>1e15</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>waitms</span> <span class=p>=</span> <span class=nb>int32</span><span class=p>(</span><span class=nx>delay</span> <span class=o>/</span> <span class=mf>1e6</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// An arbitrary cap on how long to wait for a timer.
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// 1e9 ms == ~11.5 days.
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nx>waitms</span> <span class=p>=</span> <span class=mf>1e9</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=kd>var</span> <span class=nx>events</span> <span class=p>[</span><span class=mi>128</span><span class=p>]</span><span class=nx>syscall</span><span class=p>.</span><span class=nx>EpollEvent</span>
</span></span><span class=line><span class=cl><span class=nx>retry</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=nx>n</span><span class=p>,</span> <span class=nx>errno</span> <span class=o>:=</span> <span class=nx>syscall</span><span class=p>.</span><span class=nf>EpollWait</span><span class=p>(</span><span class=nx>epfd</span><span class=p>,</span> <span class=nx>events</span><span class=p>[:],</span> <span class=nb>int32</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=nx>events</span><span class=p>)),</span> <span class=nx>waitms</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>errno</span> <span class=o>!=</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nx>errno</span> <span class=o>!=</span> <span class=nx>_EINTR</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nb>println</span><span class=p>(</span><span class=s>&#34;runtime: epollwait on fd&#34;</span><span class=p>,</span> <span class=nx>epfd</span><span class=p>,</span> <span class=s>&#34;failed with&#34;</span><span class=p>,</span> <span class=nx>errno</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=nf>throw</span><span class=p>(</span><span class=s>&#34;runtime: netpoll failed&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=c1>// If a timed sleep was interrupted, just return to
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// recalculate how long we should sleep now.
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>if</span> <span class=nx>waitms</span> <span class=p>&gt;</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=nx>gList</span><span class=p>{}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>goto</span> <span class=nx>retry</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=kd>var</span> <span class=nx>toRun</span> <span class=nx>gList</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=nb>int32</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=nx>n</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>ev</span> <span class=o>:=</span> <span class=nx>events</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nx>ev</span><span class=p>.</span><span class=nx>Events</span> <span class=o>==</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>continue</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=o>*</span><span class=p>(</span><span class=o>**</span><span class=kt>uintptr</span><span class=p>)(</span><span class=nx>unsafe</span><span class=p>.</span><span class=nf>Pointer</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>ev</span><span class=p>.</span><span class=nx>Data</span><span class=p>))</span> <span class=o>==</span> <span class=o>&amp;</span><span class=nx>netpollBreakRd</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=nx>ev</span><span class=p>.</span><span class=nx>Events</span> <span class=o>!=</span> <span class=nx>syscall</span><span class=p>.</span><span class=nx>EPOLLIN</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=nb>println</span><span class=p>(</span><span class=s>&#34;runtime: netpoll: break fd ready for&#34;</span><span class=p>,</span> <span class=nx>ev</span><span class=p>.</span><span class=nx>Events</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=nf>throw</span><span class=p>(</span><span class=s>&#34;runtime: netpoll: break fd ready for something unexpected&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=nx>delay</span> <span class=o>!=</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=c1>// netpollBreak could be picked up by a
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=c1>// nonblocking poll. Only read the byte
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=c1>// if blocking.
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=kd>var</span> <span class=nx>tmp</span> <span class=p>[</span><span class=mi>16</span><span class=p>]</span><span class=kt>byte</span>
</span></span><span class=line><span class=cl>                <span class=nf>read</span><span class=p>(</span><span class=nb>int32</span><span class=p>(</span><span class=nx>netpollBreakRd</span><span class=p>),</span> <span class=nf>noescape</span><span class=p>(</span><span class=nx>unsafe</span><span class=p>.</span><span class=nf>Pointer</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>tmp</span><span class=p>[</span><span class=mi>0</span><span class=p>])),</span> <span class=nb>int32</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=nx>tmp</span><span class=p>)))</span>
</span></span><span class=line><span class=cl>                <span class=nx>netpollWakeSig</span><span class=p>.</span><span class=nf>Store</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=k>continue</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=kd>var</span> <span class=nx>mode</span> <span class=kt>int32</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nx>ev</span><span class=p>.</span><span class=nx>Events</span><span class=o>&amp;</span><span class=p>(</span><span class=nx>syscall</span><span class=p>.</span><span class=nx>EPOLLIN</span><span class=p>|</span><span class=nx>syscall</span><span class=p>.</span><span class=nx>EPOLLRDHUP</span><span class=p>|</span><span class=nx>syscall</span><span class=p>.</span><span class=nx>EPOLLHUP</span><span class=p>|</span><span class=nx>syscall</span><span class=p>.</span><span class=nx>EPOLLERR</span><span class=p>)</span> <span class=o>!=</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>mode</span> <span class=o>+=</span> <span class=sc>&#39;r&#39;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nx>ev</span><span class=p>.</span><span class=nx>Events</span><span class=o>&amp;</span><span class=p>(</span><span class=nx>syscall</span><span class=p>.</span><span class=nx>EPOLLOUT</span><span class=p>|</span><span class=nx>syscall</span><span class=p>.</span><span class=nx>EPOLLHUP</span><span class=p>|</span><span class=nx>syscall</span><span class=p>.</span><span class=nx>EPOLLERR</span><span class=p>)</span> <span class=o>!=</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>mode</span> <span class=o>+=</span> <span class=sc>&#39;w&#39;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nx>mode</span> <span class=o>!=</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>pd</span> <span class=o>:=</span> <span class=o>*</span><span class=p>(</span><span class=o>**</span><span class=nx>pollDesc</span><span class=p>)(</span><span class=nx>unsafe</span><span class=p>.</span><span class=nf>Pointer</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>ev</span><span class=p>.</span><span class=nx>Data</span><span class=p>))</span>
</span></span><span class=line><span class=cl>            <span class=nx>pd</span><span class=p>.</span><span class=nf>setEventErr</span><span class=p>(</span><span class=nx>ev</span><span class=p>.</span><span class=nx>Events</span> <span class=o>==</span> <span class=nx>syscall</span><span class=p>.</span><span class=nx>EPOLLERR</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=nf>netpollready</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>toRun</span><span class=p>,</span> <span class=nx>pd</span><span class=p>,</span> <span class=nx>mode</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>toRun</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Go runtime 没有单独使用一个线程轮询 IO 事件，而是由特定操作触发 netpoller。触发网络轮询的事件包括：</p><ul><li>goroutine 调度</li><li>垃圾回收的某些阶段：Drain、MarkDone、MarkTermination、StartTheWorld。</li><li>sysmon goroutine</li></ul><p>调用关系如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nf>schedule</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=o>-</span><span class=p>&gt;</span> <span class=nf>findRunnable</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=o>-</span><span class=p>&gt;</span> <span class=nf>netpoll</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>gcStart</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=o>-</span><span class=p>&gt;</span> <span class=nf>startTheWorldWithSema</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=o>-</span><span class=p>&gt;</span> <span class=nf>netpoll</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=nf>gcDrain</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=o>-</span><span class=p>&gt;</span> <span class=nf>pollWork</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=nf>gcMarkDone</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=o>-</span><span class=p>&gt;</span> <span class=nf>startTheWorldWithSema</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=o>-</span><span class=p>&gt;</span> <span class=nf>netpoll</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=nf>gcMarkTermination</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=o>-</span><span class=p>&gt;</span> <span class=nf>startTheWorldWithSema</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=o>-</span><span class=p>&gt;</span> <span class=nf>netpoll</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=nf>startTheWorld</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=o>-</span><span class=p>&gt;</span> <span class=nf>startTheWorldWithSema</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=o>-</span><span class=p>&gt;</span> <span class=nf>netpoll</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>sysmon</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=o>-</span><span class=p>&gt;</span> <span class=nf>netpoll</span><span class=p>()</span>
</span></span></code></pre></div><h2 id=拦截阻塞-io>“拦截”阻塞 IO</h2><p>显然，goroutine 在非阻塞 IO 未就绪时被挂起，为了“拦截”阻塞，必须将 IO 系统调用都封装成非阻塞的。</p><h3 id=封装文件描述符>封装文件描述符</h3><p>Go runtime 在 internal/poll/fd_unix.go 定义了 UNIX 上的文件描述符。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// FD is a file descriptor. The net and os packages use this type as a
</span></span></span><span class=line><span class=cl><span class=c1>// field of a larger type representing a network connection or OS file.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>type</span> <span class=nx>FD</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Lock sysfd and serialize access to Read and Write methods.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>fdmu</span> <span class=nx>fdMutex</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// System file descriptor. Immutable until Close.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>Sysfd</span> <span class=kt>int</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// I/O poller.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>pd</span> <span class=nx>pollDesc</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Writev cache.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>iovecs</span> <span class=o>*</span><span class=p>[]</span><span class=nx>syscall</span><span class=p>.</span><span class=nx>Iovec</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Semaphore signaled when file is closed.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>csema</span> <span class=kt>uint32</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Non-zero if this file has been set to blocking mode.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>isBlocking</span> <span class=kt>uint32</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Whether this is a streaming descriptor, as opposed to a
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// packet-based descriptor like a UDP socket. Immutable.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>IsStream</span> <span class=kt>bool</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Whether a zero byte read indicates EOF. This is false for a
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// message based socket connection.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>ZeroReadIsEOF</span> <span class=kt>bool</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Whether this is a file rather than a network socket.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>isFile</span> <span class=kt>bool</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>结构体<code>FD</code>包含系统原生文件描述符<code>Sysfd</code>和 I/O poller<code>pd</code>，<code>Sysfd</code>用于执行系统调用，<code>pd</code>用于轮询该文件。</p><p>Go 语言的文件在底层都是 internal/poll/fd_unix.go 中定义的<code>poll.FD</code>。
<code>os.File</code>定义于 os/types.go，其中内嵌了<code>*file</code>，<code>file</code>是特定 OS 上的文件类型，通过<code>go:build</code>条件编译调用到特定平台上的实现。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// File represents an open file descriptor.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>type</span> <span class=nx>File</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=o>*</span><span class=nx>file</span> <span class=c1>// os specific
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><p>Linux 平台的<code>file</code>定义在 os/file_unix.go，其中包含<code>poll.FD</code>。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// file is the real representation of *File.
</span></span></span><span class=line><span class=cl><span class=c1>// The extra level of indirection ensures that no clients of os
</span></span></span><span class=line><span class=cl><span class=c1>// can overwrite this data, which could cause the finalizer
</span></span></span><span class=line><span class=cl><span class=c1>// to close the wrong file descriptor.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>type</span> <span class=nx>file</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>pfd</span>         <span class=nx>poll</span><span class=p>.</span><span class=nx>FD</span>
</span></span><span class=line><span class=cl>    <span class=nx>name</span>        <span class=kt>string</span>
</span></span><span class=line><span class=cl>    <span class=nx>dirinfo</span>     <span class=o>*</span><span class=nx>dirInfo</span> <span class=c1>// nil unless directory being read
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>nonblock</span>    <span class=kt>bool</span>     <span class=c1>// whether we set nonblocking mode
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>stdoutOrErr</span> <span class=kt>bool</span>     <span class=c1>// whether this is stdout or stderr
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>appendMode</span>  <span class=kt>bool</span>     <span class=c1>// whether file is opened for appending
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><p>再看<code>net</code>包的<code>socket()</code>，返回的文件描述符是<code>*netFD</code>。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// socket returns a network file descriptor that is ready for
</span></span></span><span class=line><span class=cl><span class=c1>// asynchronous I/O using the network poller.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>socket</span><span class=p>(</span><span class=nx>ctx</span> <span class=nx>context</span><span class=p>.</span><span class=nx>Context</span><span class=p>,</span> <span class=nx>net</span> <span class=kt>string</span><span class=p>,</span> <span class=nx>family</span><span class=p>,</span> <span class=nx>sotype</span><span class=p>,</span> <span class=nx>proto</span> <span class=kt>int</span><span class=p>,</span> <span class=nx>ipv6only</span> <span class=kt>bool</span><span class=p>,</span> <span class=nx>laddr</span><span class=p>,</span> <span class=nx>raddr</span> <span class=nx>sockaddr</span><span class=p>,</span> <span class=nx>ctrlCtxFn</span> <span class=kd>func</span><span class=p>(</span><span class=nx>context</span><span class=p>.</span><span class=nx>Context</span><span class=p>,</span> <span class=kt>string</span><span class=p>,</span> <span class=kt>string</span><span class=p>,</span> <span class=nx>syscall</span><span class=p>.</span><span class=nx>RawConn</span><span class=p>)</span> <span class=kt>error</span><span class=p>)</span> <span class=p>(</span><span class=nx>fd</span> <span class=o>*</span><span class=nx>netFD</span><span class=p>,</span> <span class=nx>err</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><p><code>netFD</code>定义在 net/fd_posix.go：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// Network file descriptor.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>type</span> <span class=nx>netFD</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>pfd</span> <span class=nx>poll</span><span class=p>.</span><span class=nx>FD</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// immutable until Close
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>family</span>      <span class=kt>int</span>
</span></span><span class=line><span class=cl>    <span class=nx>sotype</span>      <span class=kt>int</span>
</span></span><span class=line><span class=cl>    <span class=nx>isConnected</span> <span class=kt>bool</span> <span class=c1>// handshake completed or use of association with peer
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>net</span>         <span class=kt>string</span>
</span></span><span class=line><span class=cl>    <span class=nx>laddr</span>       <span class=nx>Addr</span>
</span></span><span class=line><span class=cl>    <span class=nx>raddr</span>       <span class=nx>Addr</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>其中同样包含<code>poll.FD</code>。</p><p>不同平台的 IO 多路复用能力不同，FreeBSD 的 kqueue 支持磁盘文件，Linux 的 epoll 不支持磁盘文件。</p><h3 id=初始化文件描述符>初始化文件描述符</h3><p>创建文件描述符时设置为非阻塞 IO，并注册到 poller 上。</p><p>Go 语言的网络 IO 是非阻塞的，创建 socket 时设置。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// net/sock_posix.go
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>socket</span><span class=p>(</span><span class=nx>ctx</span> <span class=nx>context</span><span class=p>.</span><span class=nx>Context</span><span class=p>,</span> <span class=nx>net</span> <span class=kt>string</span><span class=p>,</span> <span class=nx>family</span><span class=p>,</span> <span class=nx>sotype</span><span class=p>,</span> <span class=nx>proto</span> <span class=kt>int</span><span class=p>,</span> <span class=nx>ipv6only</span> <span class=kt>bool</span><span class=p>,</span> <span class=nx>laddr</span><span class=p>,</span> <span class=nx>raddr</span> <span class=nx>sockaddr</span><span class=p>,</span> <span class=nx>ctrlCtxFn</span> <span class=kd>func</span><span class=p>(</span><span class=nx>context</span><span class=p>.</span><span class=nx>Context</span><span class=p>,</span> <span class=kt>string</span><span class=p>,</span> <span class=kt>string</span><span class=p>,</span> <span class=nx>syscall</span><span class=p>.</span><span class=nx>RawConn</span><span class=p>)</span> <span class=kt>error</span><span class=p>)</span> <span class=p>(</span><span class=nx>fd</span> <span class=o>*</span><span class=nx>netFD</span><span class=p>,</span> <span class=nx>err</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// sysSocket() 创建非阻塞 socket
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>s</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nf>sysSocket</span><span class=p>(</span><span class=nx>family</span><span class=p>,</span> <span class=nx>sotype</span><span class=p>,</span> <span class=nx>proto</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=kc>nil</span><span class=p>,</span> <span class=nx>err</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=nx>laddr</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=o>&amp;&amp;</span> <span class=nx>raddr</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>switch</span> <span class=nx>sotype</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>case</span> <span class=nx>syscall</span><span class=p>.</span><span class=nx>SOCK_STREAM</span><span class=p>,</span> <span class=nx>syscall</span><span class=p>.</span><span class=nx>SOCK_SEQPACKET</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>fd</span><span class=p>.</span><span class=nf>listenStream</span><span class=p>(</span><span class=nx>ctx</span><span class=p>,</span> <span class=nx>laddr</span><span class=p>,</span> <span class=nf>listenerBacklog</span><span class=p>(),</span> <span class=nx>ctrlCtxFn</span><span class=p>);</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=nx>fd</span><span class=p>.</span><span class=nf>Close</span><span class=p>()</span>
</span></span><span class=line><span class=cl>                <span class=k>return</span> <span class=kc>nil</span><span class=p>,</span> <span class=nx>err</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=nx>fd</span><span class=p>,</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl>        <span class=k>case</span> <span class=nx>syscall</span><span class=p>.</span><span class=nx>SOCK_DGRAM</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>fd</span><span class=p>.</span><span class=nf>listenDatagram</span><span class=p>(</span><span class=nx>ctx</span><span class=p>,</span> <span class=nx>laddr</span><span class=p>,</span> <span class=nx>ctrlCtxFn</span><span class=p>);</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=nx>fd</span><span class=p>.</span><span class=nf>Close</span><span class=p>()</span>
</span></span><span class=line><span class=cl>                <span class=k>return</span> <span class=kc>nil</span><span class=p>,</span> <span class=nx>err</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=nx>fd</span><span class=p>,</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>fd</span><span class=p>.</span><span class=nf>dial</span><span class=p>(</span><span class=nx>ctx</span><span class=p>,</span> <span class=nx>laddr</span><span class=p>,</span> <span class=nx>raddr</span><span class=p>,</span> <span class=nx>ctrlCtxFn</span><span class=p>);</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>fd</span><span class=p>.</span><span class=nf>Close</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=kc>nil</span><span class=p>,</span> <span class=nx>err</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>fd</span><span class=p>,</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p><code>sysSocket()</code>创建非阻塞 socket。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// net/sock_cloexec.go
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=c1>// Wrapper around the socket system call that marks the returned file
</span></span></span><span class=line><span class=cl><span class=c1>// descriptor as nonblocking and close-on-exec.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>sysSocket</span><span class=p>(</span><span class=nx>family</span><span class=p>,</span> <span class=nx>sotype</span><span class=p>,</span> <span class=nx>proto</span> <span class=kt>int</span><span class=p>)</span> <span class=p>(</span><span class=kt>int</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>s</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nf>socketFunc</span><span class=p>(</span><span class=nx>family</span><span class=p>,</span> <span class=nx>sotype</span><span class=p>|</span><span class=nx>syscall</span><span class=p>.</span><span class=nx>SOCK_NONBLOCK</span><span class=p>|</span><span class=nx>syscall</span><span class=p>.</span><span class=nx>SOCK_CLOEXEC</span><span class=p>,</span> <span class=nx>proto</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=o>-</span><span class=mi>1</span><span class=p>,</span> <span class=nx>os</span><span class=p>.</span><span class=nf>NewSyscallError</span><span class=p>(</span><span class=s>&#34;socket&#34;</span><span class=p>,</span> <span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>s</span><span class=p>,</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>后续<code>fd.listenStream(...)</code>、<code>fd.listenDatagram(...)</code>和<code>fd.Dial(...)</code>将该<code>netFD</code>注册到 netpoller。</p><p><code>os.File</code>也同样试图创建非阻塞的文件描述符，但因为不同平台的 IO 多路复用能力不同，FreeBSD 的 kqueue 支持磁盘 IO，但 Linux epoll 只支持 socket 和 pipe，所以创建<code>os.File</code>时需要判断文件是否可轮询。在可轮询的平台上（FreeBSD），<code>os.File</code>也是非阻塞的，被注册到 netpoller 上；在不可轮询的平台上（Linux），<code>os.File</code>是阻塞的，会阻塞线程。</p><p><code>(*os.File).Create()</code>创建描述符并初始化<code>poll.FD</code>的调用链如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nf>Create</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=o>-</span><span class=p>&gt;</span> <span class=nf>OpenFile</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=o>-</span><span class=p>&gt;</span> <span class=nf>openFileNonlog</span><span class=p>()</span>
</span></span><span class=line><span class=cl>            <span class=o>-</span><span class=p>&gt;</span> <span class=nf>newFile</span><span class=p>()</span> <span class=err>根据平台设置非阻塞</span><span class=o>/</span><span class=err>阻塞</span> <span class=nx>IO</span><span class=err>，初始化</span> <span class=nx>poll</span><span class=p>.</span><span class=nx>FD</span><span class=err>（阻塞则为空值），（非阻塞）并注册到</span> <span class=nx>netpoller</span><span class=err>。</span>
</span></span></code></pre></div><h3 id=封装系统调用>封装系统调用</h3><p>Go 文件描述符的本质是<code>poll.FD</code>，自然其上的各种读写操作最终也归结于<code>poll.FD</code>上的读写操作。</p><p>以网络 IO 为例，查看 socket 上<code>Write()</code>的实现。socket 实际上是一个<code>*netFD</code>，<code>(*netFD).Write()</code>的实现如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// net/fd_unix.go
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>fd</span> <span class=o>*</span><span class=nx>netFD</span><span class=p>)</span> <span class=nf>Write</span><span class=p>(</span><span class=nx>p</span> <span class=p>[]</span><span class=kt>byte</span><span class=p>)</span> <span class=p>(</span><span class=nx>nn</span> <span class=kt>int</span><span class=p>,</span> <span class=nx>err</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>nn</span><span class=p>,</span> <span class=nx>err</span> <span class=p>=</span> <span class=nx>fd</span><span class=p>.</span><span class=nx>pfd</span><span class=p>.</span><span class=nf>Write</span><span class=p>(</span><span class=nx>p</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>runtime</span><span class=p>.</span><span class=nf>KeepAlive</span><span class=p>(</span><span class=nx>fd</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>nn</span><span class=p>,</span> <span class=nf>wrapSyscallError</span><span class=p>(</span><span class=nx>writeSyscallName</span><span class=p>,</span> <span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>查看<code>(*os.File).Write()</code>的实现，<code>(*os.File).Write()</code>包装了<code>(*os.File).write()</code>。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// os/file.go
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>f</span> <span class=o>*</span><span class=nx>File</span><span class=p>)</span> <span class=nf>Write</span><span class=p>(</span><span class=nx>b</span> <span class=p>[]</span><span class=kt>byte</span><span class=p>)</span> <span class=p>(</span><span class=nx>n</span> <span class=kt>int</span><span class=p>,</span> <span class=nx>err</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>f</span><span class=p>.</span><span class=nf>checkValid</span><span class=p>(</span><span class=s>&#34;write&#34;</span><span class=p>);</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=mi>0</span><span class=p>,</span> <span class=nx>err</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nx>n</span><span class=p>,</span> <span class=nx>e</span> <span class=o>:=</span> <span class=nx>f</span><span class=p>.</span><span class=nf>write</span><span class=p>(</span><span class=nx>b</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>n</span> <span class=p>&lt;</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>n</span> <span class=p>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>n</span> <span class=o>!=</span> <span class=nb>len</span><span class=p>(</span><span class=nx>b</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>err</span> <span class=p>=</span> <span class=nx>io</span><span class=p>.</span><span class=nx>ErrShortWrite</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>epipecheck</span><span class=p>(</span><span class=nx>f</span><span class=p>,</span> <span class=nx>e</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>e</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>err</span> <span class=p>=</span> <span class=nx>f</span><span class=p>.</span><span class=nf>wrapErr</span><span class=p>(</span><span class=s>&#34;write&#34;</span><span class=p>,</span> <span class=nx>e</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>n</span><span class=p>,</span> <span class=nx>err</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p><code>(*os.File).Write()</code>是平台无关的接口，<code>(*os.File).write()</code>是特定 OS 上的实现，Linux 的实现在 os/file_posix.go 中。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// os/file_posix.go
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>f</span> <span class=o>*</span><span class=nx>File</span><span class=p>)</span> <span class=nf>write</span><span class=p>(</span><span class=nx>b</span> <span class=p>[]</span><span class=kt>byte</span><span class=p>)</span> <span class=p>(</span><span class=nx>n</span> <span class=kt>int</span><span class=p>,</span> <span class=nx>err</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>n</span><span class=p>,</span> <span class=nx>err</span> <span class=p>=</span> <span class=nx>f</span><span class=p>.</span><span class=nx>pfd</span><span class=p>.</span><span class=nf>Write</span><span class=p>(</span><span class=nx>b</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>runtime</span><span class=p>.</span><span class=nf>KeepAlive</span><span class=p>(</span><span class=nx>f</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>n</span><span class=p>,</span> <span class=nx>err</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>可见，不论是磁盘文件还是网络 IO，最终都归结于<code>poll.FD</code>上的读写。
<code>(*poll.FD).Write()</code>定义如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// internal/poll/fd_unix.go
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>fd</span> <span class=o>*</span><span class=nx>FD</span><span class=p>)</span> <span class=nf>Write</span><span class=p>(</span><span class=nx>p</span> <span class=p>[]</span><span class=kt>byte</span><span class=p>)</span> <span class=p>(</span><span class=kt>int</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>fd</span><span class=p>.</span><span class=nf>writeLock</span><span class=p>();</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=mi>0</span><span class=p>,</span> <span class=nx>err</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>defer</span> <span class=nx>fd</span><span class=p>.</span><span class=nf>writeUnlock</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>fd</span><span class=p>.</span><span class=nx>pd</span><span class=p>.</span><span class=nf>prepareWrite</span><span class=p>(</span><span class=nx>fd</span><span class=p>.</span><span class=nx>isFile</span><span class=p>);</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=mi>0</span><span class=p>,</span> <span class=nx>err</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=kd>var</span> <span class=nx>nn</span> <span class=kt>int</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>max</span> <span class=o>:=</span> <span class=nb>len</span><span class=p>(</span><span class=nx>p</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nx>fd</span><span class=p>.</span><span class=nx>IsStream</span> <span class=o>&amp;&amp;</span> <span class=nx>max</span><span class=o>-</span><span class=nx>nn</span> <span class=p>&gt;</span> <span class=nx>maxRW</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>max</span> <span class=p>=</span> <span class=nx>nn</span> <span class=o>+</span> <span class=nx>maxRW</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=nx>n</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nf>ignoringEINTRIO</span><span class=p>(</span><span class=nx>syscall</span><span class=p>.</span><span class=nx>Write</span><span class=p>,</span> <span class=nx>fd</span><span class=p>.</span><span class=nx>Sysfd</span><span class=p>,</span> <span class=nx>p</span><span class=p>[</span><span class=nx>nn</span><span class=p>:</span><span class=nx>max</span><span class=p>])</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nx>n</span> <span class=p>&gt;</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>nn</span> <span class=o>+=</span> <span class=nx>n</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nx>nn</span> <span class=o>==</span> <span class=nb>len</span><span class=p>(</span><span class=nx>p</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=nx>nn</span><span class=p>,</span> <span class=nx>err</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nx>err</span> <span class=o>==</span> <span class=nx>syscall</span><span class=p>.</span><span class=nx>EAGAIN</span> <span class=o>&amp;&amp;</span> <span class=nx>fd</span><span class=p>.</span><span class=nx>pd</span><span class=p>.</span><span class=nf>pollable</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=nx>err</span> <span class=p>=</span> <span class=nx>fd</span><span class=p>.</span><span class=nx>pd</span><span class=p>.</span><span class=nf>waitWrite</span><span class=p>(</span><span class=nx>fd</span><span class=p>.</span><span class=nx>isFile</span><span class=p>);</span> <span class=nx>err</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=k>continue</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=nx>nn</span><span class=p>,</span> <span class=nx>err</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nx>n</span> <span class=o>==</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=nx>nn</span><span class=p>,</span> <span class=nx>io</span><span class=p>.</span><span class=nx>ErrUnexpectedEOF</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p><code>(*poll.FD).Write()</code>做了两件事：</p><ol><li>调用<code>(*poll.FD).prepareWrite()</code>注册此描述符到 netpoller；</li><li>在循环中调用<code>syscall.Write</code>，可轮询（非阻塞 IO）文件描述符未就绪则调用<code>(*poll.FD).waitWrite()</code>等待（阻塞 goroutine）。</li></ol><p>对于可轮询的文件描述符，<code>(*poll.FD).prepareWrite()</code>调用，<code>runtime_pollReset()</code>重置<code>pollDesc</code>的读写者为<code>pdNil</code>。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// internal/poll/fd_poll_runtime.go
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>pd</span> <span class=o>*</span><span class=nx>pollDesc</span><span class=p>)</span> <span class=nf>prepareWrite</span><span class=p>(</span><span class=nx>isFile</span> <span class=kt>bool</span><span class=p>)</span> <span class=kt>error</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>pd</span><span class=p>.</span><span class=nf>prepare</span><span class=p>(</span><span class=sc>&#39;w&#39;</span><span class=p>,</span> <span class=nx>isFile</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>pd</span> <span class=o>*</span><span class=nx>pollDesc</span><span class=p>)</span> <span class=nf>prepare</span><span class=p>(</span><span class=nx>mode</span> <span class=kt>int</span><span class=p>,</span> <span class=nx>isFile</span> <span class=kt>bool</span><span class=p>)</span> <span class=kt>error</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>pd</span><span class=p>.</span><span class=nx>runtimeCtx</span> <span class=o>==</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nx>res</span> <span class=o>:=</span> <span class=nf>runtime_pollReset</span><span class=p>(</span><span class=nx>pd</span><span class=p>.</span><span class=nx>runtimeCtx</span><span class=p>,</span> <span class=nx>mode</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nf>convertErr</span><span class=p>(</span><span class=nx>res</span><span class=p>,</span> <span class=nx>isFile</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>internal/poll/fd_poll_runtime.go 中形如<code>runtime_XXXXXX()</code>的函数只有函数原型，没有函数体。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// internal/poll/fd_poll_runtime.go
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>runtime_pollServerInit</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>runtime_pollOpen</span><span class=p>(</span><span class=nx>fd</span> <span class=kt>uintptr</span><span class=p>)</span> <span class=p>(</span><span class=kt>uintptr</span><span class=p>,</span> <span class=kt>int</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>runtime_pollClose</span><span class=p>(</span><span class=nx>ctx</span> <span class=kt>uintptr</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>runtime_pollWait</span><span class=p>(</span><span class=nx>ctx</span> <span class=kt>uintptr</span><span class=p>,</span> <span class=nx>mode</span> <span class=kt>int</span><span class=p>)</span> <span class=kt>int</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>runtime_pollWaitCanceled</span><span class=p>(</span><span class=nx>ctx</span> <span class=kt>uintptr</span><span class=p>,</span> <span class=nx>mode</span> <span class=kt>int</span><span class=p>)</span> <span class=kt>int</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>runtime_pollReset</span><span class=p>(</span><span class=nx>ctx</span> <span class=kt>uintptr</span><span class=p>,</span> <span class=nx>mode</span> <span class=kt>int</span><span class=p>)</span> <span class=kt>int</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>runtime_pollSetDeadline</span><span class=p>(</span><span class=nx>ctx</span> <span class=kt>uintptr</span><span class=p>,</span> <span class=nx>d</span> <span class=kt>int64</span><span class=p>,</span> <span class=nx>mode</span> <span class=kt>int</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>runtime_pollUnblock</span><span class=p>(</span><span class=nx>ctx</span> <span class=kt>uintptr</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>runtime_isPollServerDescriptor</span><span class=p>(</span><span class=nx>fd</span> <span class=kt>uintptr</span><span class=p>)</span> <span class=kt>bool</span>
</span></span></code></pre></div><p>这是因为这些函数都实现在 runtime/netpoll.go 中，符号名为<code>poll_runtime_XXXXXX()</code>，通过<code>go:linkname</code>将其导出到 internal/poll/fd_poll_runtime.go 中，包含以下函数：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>poll_runtime_isPollServerDescriptor</span><span class=p>(</span><span class=nx>fd</span> <span class=kt>uintptr</span><span class=p>)</span> <span class=kt>bool</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>poll_runtime_pollOpen</span><span class=p>(</span><span class=nx>fd</span> <span class=kt>uintptr</span><span class=p>)</span> <span class=p>(</span><span class=o>*</span><span class=nx>pollDesc</span><span class=p>,</span> <span class=kt>int</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>poll_runtime_pollClose</span><span class=p>(</span><span class=nx>pd</span> <span class=o>*</span><span class=nx>pollDesc</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>poll_runtime_pollReset</span><span class=p>(</span><span class=nx>pd</span> <span class=o>*</span><span class=nx>pollDesc</span><span class=p>,</span> <span class=nx>mode</span> <span class=kt>int</span><span class=p>)</span> <span class=kt>int</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>poll_runtime_pollWait</span><span class=p>(</span><span class=nx>pd</span> <span class=o>*</span><span class=nx>pollDesc</span><span class=p>,</span> <span class=nx>mode</span> <span class=kt>int</span><span class=p>)</span> <span class=kt>int</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>poll_runtime_pollSetDeadline</span><span class=p>(</span><span class=nx>pd</span> <span class=o>*</span><span class=nx>pollDesc</span><span class=p>,</span> <span class=nx>d</span> <span class=kt>int64</span><span class=p>,</span> <span class=nx>mode</span> <span class=kt>int</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>poll_runtime_pollUnblock</span><span class=p>(</span><span class=nx>pd</span> <span class=o>*</span><span class=nx>pollDesc</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>poll_runtime_pollServerInit</span><span class=p>()</span>
</span></span></code></pre></div><p><code>go:linkname &lt;source> &lt;target></code>的作用是指示编译器在链接时使用符号名<code>&lt;source></code>替代<code>&lt;target></code>。</p><p><code>(*pollFD).Write()</code>中的<code>fd.pd.waitWrite(fd.isFile)</code>实际上实在调用<code>poll_runtime_polLWait()</code>。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// internal/poll/fd_poll_runtime.go
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>pd</span> <span class=o>*</span><span class=nx>pollDesc</span><span class=p>)</span> <span class=nf>waitWrite</span><span class=p>(</span><span class=nx>isFile</span> <span class=kt>bool</span><span class=p>)</span> <span class=kt>error</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>pd</span><span class=p>.</span><span class=nf>wait</span><span class=p>(</span><span class=sc>&#39;w&#39;</span><span class=p>,</span> <span class=nx>isFile</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>pd</span> <span class=o>*</span><span class=nx>pollDesc</span><span class=p>)</span> <span class=nf>wait</span><span class=p>(</span><span class=nx>mode</span> <span class=kt>int</span><span class=p>,</span> <span class=nx>isFile</span> <span class=kt>bool</span><span class=p>)</span> <span class=kt>error</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>pd</span><span class=p>.</span><span class=nx>runtimeCtx</span> <span class=o>==</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nx>errors</span><span class=p>.</span><span class=nf>New</span><span class=p>(</span><span class=s>&#34;waiting for unsupported file type&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nx>res</span> <span class=o>:=</span> <span class=nf>runtime_pollWait</span><span class=p>(</span><span class=nx>pd</span><span class=p>.</span><span class=nx>runtimeCtx</span><span class=p>,</span> <span class=nx>mode</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nf>convertErr</span><span class=p>(</span><span class=nx>res</span><span class=p>,</span> <span class=nx>isFile</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p><code>runtime_pollWait()</code>实际上是定义在 runtime/netpoll.go 中的<code>poll_runtime_pollWait()</code>。</p><p><code>//go:linkname poll_runtime_pollWait internal/poll.runtime_pollWait</code>指示编译器使用<code>poll_runtime_polLWait</code>作为符号<code>internal/poll.runtime_pollWait</code>。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// poll_runtime_pollWait, which is internal/poll.runtime_pollWait,
</span></span></span><span class=line><span class=cl><span class=c1>// waits for a descriptor to be ready for reading or writing,
</span></span></span><span class=line><span class=cl><span class=c1>// according to mode, which is &#39;r&#39; or &#39;w&#39;.
</span></span></span><span class=line><span class=cl><span class=c1>// This returns an error code; the codes are defined above.
</span></span></span><span class=line><span class=cl><span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1>//go:linkname poll_runtime_pollWait internal/poll.runtime_pollWait
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>poll_runtime_pollWait</span><span class=p>(</span><span class=nx>pd</span> <span class=o>*</span><span class=nx>pollDesc</span><span class=p>,</span> <span class=nx>mode</span> <span class=kt>int</span><span class=p>)</span> <span class=kt>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>errcode</span> <span class=o>:=</span> <span class=nf>netpollcheckerr</span><span class=p>(</span><span class=nx>pd</span><span class=p>,</span> <span class=nb>int32</span><span class=p>(</span><span class=nx>mode</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>errcode</span> <span class=o>!=</span> <span class=nx>pollNoError</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nx>errcode</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=c1>// As for now only Solaris, illumos, and AIX use level-triggered IO.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=nx>GOOS</span> <span class=o>==</span> <span class=s>&#34;solaris&#34;</span> <span class=o>||</span> <span class=nx>GOOS</span> <span class=o>==</span> <span class=s>&#34;illumos&#34;</span> <span class=o>||</span> <span class=nx>GOOS</span> <span class=o>==</span> <span class=s>&#34;aix&#34;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>netpollarm</span><span class=p>(</span><span class=nx>pd</span><span class=p>,</span> <span class=nx>mode</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>!</span><span class=nf>netpollblock</span><span class=p>(</span><span class=nx>pd</span><span class=p>,</span> <span class=nb>int32</span><span class=p>(</span><span class=nx>mode</span><span class=p>),</span> <span class=kc>false</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>errcode</span> <span class=p>=</span> <span class=nf>netpollcheckerr</span><span class=p>(</span><span class=nx>pd</span><span class=p>,</span> <span class=nb>int32</span><span class=p>(</span><span class=nx>mode</span><span class=p>))</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nx>errcode</span> <span class=o>!=</span> <span class=nx>pollNoError</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=nx>errcode</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=c1>// Can happen if timeout has fired and unblocked us,
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// but before we had a chance to run, timeout has been reset.
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// Pretend it has not happened and retry.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>pollNoError</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p><code>for</code>循环是唤醒 goroutine 的关键。假设<code>netpollblock()</code>阻塞 goroutine，<code>netpoll()</code>唤醒该 goroutine，该 goroutine 退出<code>netpollblock()</code>返回<code>true</code>，跳出<code>for</code>循环。</p><p>除了<code>netpoll()</code>以 IO notificaiton 唤醒 goroutine，还可以通过关闭文件描述符（对应错误<code>pollErrClosing</code>）、IO 超时（对应错误<code>pollErrTimeout</code>）跳出循环并返回错误。</p><p><code>pollErrClosing</code>错误对应文件描述符被关闭，撤销还未就绪的 IO，调用链如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=p>(</span><span class=o>*</span><span class=nx>poll</span><span class=p>.</span><span class=nx>FD</span><span class=p>).</span><span class=nf>Close</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=o>-</span><span class=p>&gt;</span> <span class=p>(</span><span class=o>*</span><span class=nx>poll</span><span class=p>.</span><span class=nx>FD</span><span class=p>).</span><span class=nf>evit</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=o>-</span><span class=p>&gt;</span> <span class=p>(</span><span class=o>*</span><span class=nx>poll</span><span class=p>.</span><span class=nx>FD</span><span class=p>).</span><span class=nf>runtime_pollUnblock</span><span class=p>()</span>
</span></span><span class=line><span class=cl>            <span class=o>-</span><span class=p>&gt;</span> <span class=p>(</span><span class=o>*</span><span class=nx>pollDesc</span><span class=p>).</span><span class=nf>pushInfo</span><span class=p>()</span> <span class=err>设置</span> <span class=nx>pollClosing</span> <span class=err>错误</span>
</span></span><span class=line><span class=cl>            <span class=o>-</span><span class=p>&gt;</span> <span class=p>(</span><span class=o>*</span><span class=nx>pollDesc</span><span class=p>).</span><span class=nf>netpollunblock</span><span class=p>()</span> <span class=err>修改</span> <span class=nx>rg</span><span class=o>/</span><span class=nx>wg</span> <span class=err>状态</span>
</span></span><span class=line><span class=cl>            <span class=o>-</span><span class=p>&gt;</span> <span class=p>(</span><span class=o>*</span><span class=nx>pollDesc</span><span class=p>).</span><span class=nf>netpollgoready</span><span class=p>()</span> <span class=err>恢复该</span> <span class=nx>goroutine</span>
</span></span></code></pre></div><p>对应 goroutine 从<code>netpollblock()</code>退出后，<code>netpollcheckerr()</code>返回错误，从<code>for</code>循环跳出，向上传播错误。</p><p><code>pollErrTimeout</code>同理，但有一个定时器，定时器超时调用回调函数，回调函数中执行类似<code>pollErrClosing</code>的操作。</p><h2 id=实例>实例</h2><p>剖析了 netpoller 源代码，再回过头看 TCP echo server：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>import</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=s>&#34;fmt&#34;</span>
</span></span><span class=line><span class=cl>    <span class=s>&#34;io&#34;</span>
</span></span><span class=line><span class=cl>    <span class=s>&#34;log&#34;</span>
</span></span><span class=line><span class=cl>    <span class=s>&#34;net&#34;</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>worker</span><span class=p>(</span><span class=nx>conn</span> <span class=nx>net</span><span class=p>.</span><span class=nx>Conn</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>defer</span> <span class=nx>conn</span><span class=p>.</span><span class=nf>Close</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=nx>b</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>([]</span><span class=kt>byte</span><span class=p>,</span> <span class=mi>512</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>size</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>conn</span><span class=p>.</span><span class=nf>Read</span><span class=p>(</span><span class=nx>b</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nx>err</span> <span class=o>==</span> <span class=nx>io</span><span class=p>.</span><span class=nx>EOF</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>break</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>log</span><span class=p>.</span><span class=nf>Fatal</span><span class=p>(</span><span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=nx>size</span><span class=p>,</span> <span class=nx>err</span> <span class=p>=</span> <span class=nx>conn</span><span class=p>.</span><span class=nf>Write</span><span class=p>(</span><span class=nx>b</span><span class=p>[</span><span class=mi>0</span><span class=p>:</span><span class=nx>size</span><span class=p>])</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>log</span><span class=p>.</span><span class=nf>Fatal</span><span class=p>(</span><span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>listner</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>net</span><span class=p>.</span><span class=nf>Listen</span><span class=p>(</span><span class=s>&#34;tcp&#34;</span><span class=p>,</span> <span class=s>&#34;127.0.0.1:8080&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>log</span><span class=p>.</span><span class=nf>Fatal</span><span class=p>(</span><span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>conn</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>listner</span><span class=p>.</span><span class=nf>Accept</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>log</span><span class=p>.</span><span class=nf>Fatal</span><span class=p>(</span><span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>go</span> <span class=nf>worker</span><span class=p>(</span><span class=nx>conn</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p><code>conn.Read()</code>读取 socket，在 Go runtime 层面发生了什么？</p><ol><li><p><code>conn.Read(b)</code>尝试读取 socket 上的数据，<code>(net.Conn).Read()</code>最底层是<code>(*internal/poll.FD).Read()</code>；</p></li><li><p>IO 就绪则系统调用<code>read(2)</code>阻塞线程，直到完成数据传输后返回；</p></li><li><p>IO 未就绪则系统调用<code>read(2)</code>返回<code>EAGAIN</code>，调用<code>(*internal/poll.FD).waitRead()</code>阻塞（<code>gopark()</code>该 goroutine；
调用链为：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=p>(</span><span class=o>*</span><span class=nx>internal</span><span class=o>/</span><span class=nx>poll</span><span class=p>.</span><span class=nx>FD</span><span class=p>).</span><span class=nf>Read</span><span class=p>()</span>
</span></span><span class=line><span class=cl> <span class=o>-</span><span class=p>&gt;</span> <span class=p>(</span><span class=o>*</span><span class=nx>internal</span><span class=o>/</span><span class=nx>poll</span><span class=p>.</span><span class=nx>pollDesc</span><span class=p>).</span><span class=nf>waitRead</span><span class=p>()</span>
</span></span><span class=line><span class=cl>     <span class=o>-</span><span class=p>&gt;</span> <span class=p>(</span><span class=o>*</span><span class=nx>internal</span><span class=o>/</span><span class=nx>poll</span><span class=p>.</span><span class=nx>pollDesc</span><span class=p>).</span><span class=nf>wait</span><span class=p>()</span>
</span></span><span class=line><span class=cl>         <span class=o>-</span><span class=p>&gt;</span> <span class=nx>internal</span><span class=o>/</span><span class=nx>poll</span><span class=p>.</span><span class=nf>runtime_pollWait</span><span class=p>()</span>
</span></span><span class=line><span class=cl>             <span class=o>-</span><span class=p>&gt;</span> <span class=nx>runtime</span><span class=p>.</span><span class=nf>netpollblock</span><span class=p>()</span>
</span></span><span class=line><span class=cl>                 <span class=o>-</span><span class=p>&gt;</span> <span class=nx>runtime</span><span class=p>.</span><span class=nf>gopark</span><span class=p>()</span>
</span></span></code></pre></div></li><li><p>Go runtime 在适当的时机（GC、调度 goroutine 以及 sysmon goroutine）轮询（<code>netpoll()</code>） IO 事件，发现该 socket 上发生读事件<code>EOLLIN</code>，设置该文件描述符的<code>rg</code>为<code>pdReady</code>，恢复（<code>netpollgoready()</code>）该 goroutine。</p></li><li><p><code>work</code> goroutine 恢复执行，退出<code>runtime.netpollblock()</code>，退出<code>internal/poll.runtime_pollWait()</code>，返回底层系统调用<code>read(2)</code>的返回值，<code>conn.Read(b)</code>退出。</p></li></ol></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span title="更新于 2022-11-21 17:42:25">更新于 2022-11-21&nbsp;</span></div><div class=post-info-license><span>All rights reserved</span></div></div><div class=post-info-line><div class=post-info-md></div><div class=post-info-share><span><a href=javascript:void(0); title="分享到 Twitter" data-sharer=twitter data-url=/posts/2022/11/21/ data-title="深入剖析 Go 语言运行时：IO 轮询器" data-hashtags=Go,Network,UNIX><i class="fa-brands fa-twitter fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); title="分享到 Facebook" data-sharer=facebook data-url=/posts/2022/11/21/ data-hashtag=Go><i class="fa-brands fa-facebook-square fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); title="分享到 微博" data-sharer=weibo data-url=/posts/2022/11/21/ data-title="深入剖析 Go 语言运行时：IO 轮询器"><i class="fa-brands fa-weibo fa-fw" aria-hidden=true></i></a></span></div></div></div><div class=post-info-more><section class=post-tags><i class="fa-solid fa-tags fa-fw me-1" aria-hidden=true></i><a href=/tags/go/ class=post-tag>Go</a><a href=/tags/network/ class=post-tag>Network</a><a href=/tags/unix/ class=post-tag>UNIX</a></section><section><span><a href=javascript:void(0); onclick=window.history.back()>返回</a></span>&nbsp;|&nbsp;<span><a href=/>主页</a></span></section></div><div class=post-nav><a href=/posts/2022/11/03/ class=post-nav-item rel=prev title=【译】内存屏障：软件黑客的硬件视角><i class="fa-solid fa-angle-left fa-fw" aria-hidden=true></i>【译】内存屏障：软件黑客的硬件视角</a>
<a href=/posts/2022/12/12/ class=post-nav-item rel=next title="致敬经典：K&R allocator 内存分配器">致敬经典：K&R allocator 内存分配器<i class="fa-solid fa-angle-right fa-fw" aria-hidden=true></i></a></div></div><div class=post-reward><div class=comment></div><input type=checkbox class=reward-input name=reward id=fi-reward hidden>
<label class=reward-button for=fi-reward>赞赏</label><div class=reward-ways data-mode=static><div><img loading=lazy src=/alipay.jpg srcset="/alipay.jpg, /alipay.jpg 1.5x, /alipay.jpg 2x" sizes=auto data-title="孔俊 支付宝" data-alt="孔俊 支付宝" style="background:url(/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'><span>支付宝</span></div><div><img loading=lazy src=/wechatpay.png srcset="/wechatpay.png, /wechatpay.png 1.5x, /wechatpay.png 2x" sizes=auto data-title="孔俊 微信" data-alt="孔俊 微信" style="background:url(/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'><span>微信</span></div></div></div><div id=comments><div id=giscus><script src=https://giscus.app/client.js data-repo=kongjun18/kongjun18.github.io data-repo-id=R_kgDOICeqmQ data-category=Announcements data-category-id=DIC_kwDOICeqmc4CVeTb data-mapping=pathname data-strict=0 data-theme=preferred_color_scheme data-reactions-enabled=1 data-emit-metadata=0 data-input-position=top data-lang=zh-CN data-loading=lazy crossorigin=anonymous async defer></script></div><noscript>Please enable JavaScript to view the comments powered by <a href=https://giscus.app/ rel="external nofollow noopener noreferrer">giscus</a>.</noscript></div></article></main><footer class=footer><div class=footer-container><div class="footer-line powered">由 <a href=https://gohugo.io/ target=_blank rel="external nofollow noopener noreferrer" title="Hugo 0.110.0">Hugo</a> 强力驱动 | 主题 - <a href=https://github.com/hugo-fixit/FixIt target=_blank rel=external title="FixIt v0.2.18"><img class=fixit-icon src=/fixit.min.svg alt="FixIt logo">&nbsp;FixIt</a></div><div class="footer-line copyright" itemscope itemtype=http://schema.org/CreativeWork><i class="fa-regular fa-copyright fa-fw" aria-hidden=true></i>
<span itemprop=copyrightYear>2022 - 2023</span><span class=author itemprop=copyrightHolder>
<a href=/></a></span><span class="license footer-divider"><a rel="license external nofollow noopener noreferrer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span></div><div class="footer-line statistics"></div></div></footer></div><div class=widgets><div class="fixed-buttons animate__faster d-none"><div class="fixed-button back-to-top" role=button aria-label=回到顶部><i class="fa-solid fa-arrow-up fa-fw" aria-hidden=true></i><span class="variant-numeric d-none">0%</span></div><div class="fixed-button view-comments d-none" role=button aria-label=查看评论><i class="fa-solid fa-comment fa-fw" aria-hidden=true></i></div></div><a href=https://github.com/kongjun18/blog title=查看博客源代码 target=_blank rel="external nofollow" class="github-corner left d-none-mobile"><svg viewBox="0 0 250 250" aria-hidden="true"><path d="M0 0 115 115h15l12 27L250 250V0z"/><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentcolor" style="transform-origin:130px 106px" class="octo-arm"/><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4l13.9-13.8C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8z" fill="currentcolor" class="octo-body"/></svg></a><div id=mask></div><noscript><div class=noscript-warning>FixIt 主题在启用 JavaScript 的情况下效果最佳。</div></noscript></div><link rel=stylesheet href=/lib/cookieconsent/cookieconsent.min.css><script src=/lib/sharer/sharer.min.js async defer></script><script src=/lib/cookieconsent/cookieconsent.min.js defer></script><script src=/lib/pangu/pangu.min.js defer></script><script>window.config={autoBookmark:!0,code:{copyTitle:"复制到剪贴板",editLockTitle:"锁定可编辑代码块",editUnLockTitle:"解锁可编辑代码块",editable:!0,maxShownLines:40},comment:{enable:!0,expired:!1,giscus:{darkTheme:"dark_dimmed",lightTheme:"light"}},cookieconsent:{content:{dismiss:"同意",link:"了解更多",message:"本网站使用 Cookies 来改善您的浏览体验。"},enable:!0,palette:{button:{background:"#f0f0f0"},popup:{background:"#1aa3ff"}},theme:"edgeless"},pangu:{enable:!0,selector:"article"}}</script><script src=/js/theme.min.js defer></script></body></html>