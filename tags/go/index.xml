<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>Go - 标签 - 孔俊的知识库</title><link>/tags/go/</link><description>Go - 标签 - 孔俊的知识库</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Mon, 21 Nov 2022 17:42:25 +0800</lastBuildDate><atom:link href="/tags/go/" rel="self" type="application/rss+xml"/><item><title>深入剖析 Go 语言运行时：IO 轮询器</title><link>/posts/2022/11/21/</link><pubDate>Mon, 21 Nov 2022 17:42:25 +0800</pubDate><author>作者</author><guid>/posts/2022/11/21/</guid><description><![CDATA[netpoller 概述 考虑一个基于 goroutine-per-connection 模型的 TCP echo server： import ( &#34;fmt&#34; &#34;io&#34; &#34;log&#34; &#34;net&#34; ) func worker(conn net.Conn) { defer conn.Close() b := make([]byte, 512) for { size, err := conn.Read(b) if err == io.EOF { break } if err != nil { log.Fatal(err) } size, err = conn.Write(b[0:size]) if err != nil { log.Fatal(err) } } } func main() { listner, err := net.Listen(&#34;tcp&#34;, &#34;127.0.0.1:8080&#34;) if err != nil { log.Fatal(err) } for { conn, err := listner.Accept() if err != nil { log.Fatal(err) } go worker(conn) } } 从用户侧看，系统该调用阻塞 goroutine，Go scheduler 调度其他 goroutine。问题在于，goroutine 复用在线程上，如果 IO 系统调用（如read(2]]></description></item><item><title>【译】Go 语言数据竞争检测器</title><link>/posts/2022/10/25/</link><pubDate>Tue, 25 Oct 2022 09:43:35 +0800</pubDate><author>作者</author><guid>/posts/2022/10/25/</guid><description><![CDATA[简介 数据竞争是并发程序中最普遍和最难调试的 bug。当两个 goroutine 并发访问同一变量且至少一个访问是写时发生数据竞争。更多细节参考 The Go Memory Model。 译者注 The Go Memory Model 可以参考我的博客 【译】Go 语言内存模型：2022-06-06 版。 这有一个可以导致程序崩溃（crashes）和内存损坏（memory corruption）的数据竞争的例子： xian sxian sfunc main() { c := make(chan bool) m := make(map[string]string) go func() { m[&#34;1&#34;] = &#34;a&#34; //]]></description></item><item><title>【译】Go 语言内存模型：2022-06-06 版</title><link>/posts/2022/10/20/</link><pubDate>Thu, 20 Oct 2022 11:46:49 +0800</pubDate><author>作者</author><guid>/posts/2022/10/20/</guid><description>译者序 原文 The Go Memory Model 描述 Go 语言内存模型，这里的内存模型实际上是“内存一致性模型”（memory consistency model）。笔者修改了格式错误并翻译全文。 The Go Memory Model 在内存一致性模型层面，描述 Go 语言实现（Go implementation）提供的一致性保证，并进一步指出该保证对 Go 语言实现的限制；在工程实践层面，描述使用同步原语确保 goroutine 间可见性的方法，并进一步指出常见的错误同步手法。</description></item></channel></rss>