<!doctype html><html itemscope itemtype=http://schema.org/WebPage lang=zh-cn><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=2"><meta name=robots content="noodp"><title>【译】Go 语言内存模型：2022-06-06 版 - 孔俊的知识库</title><meta name=author content><meta name=author-link content><meta name=description content="译者序 原文 The Go Memory Model 描述 Go 语言内存模型，这里的内存模型实际上是“内存一致性模型”（memory consistency model）。笔者修改了格式错误并翻译全文。 The Go Memory Model 在内存一致性模型层面，描述 Go 语言实现（Go implementation）提供的一致性保证，并进一步指出该保证对 Go 语言实现的限制；在工程实践层面，描述使用同步原语确保 goroutine 间可见性的方法，并进一步指出常见的错误同步手法。"><meta name=keywords content="Memory Model,Go,Computer Architecture,Concurrency"><meta itemprop=name content="【译】Go 语言内存模型：2022-06-06 版"><meta itemprop=description content="译者序 原文 The Go Memory Model 描述 Go 语言内存模型，这里的内存模型实际上是“内存一致性模型”（memory consistency model）。笔者修改了格式错误并翻译全文。 The Go Memory Model 在内存一致性模型层面，描述 Go 语言实现（Go implementation）提供的一致性保证，并进一步指出该保证对 Go 语言实现的限制；在工程实践层面，描述使用同步原语确保 goroutine 间可见性的方法，并进一步指出常见的错误同步手法。"><meta itemprop=datePublished content="2022-10-20T11:46:49+08:00"><meta itemprop=dateModified content="2022-10-20T11:46:49+08:00"><meta itemprop=wordCount content="8687"><meta itemprop=image content="/posts/2022/10/20/images/featured-image.png"><meta itemprop=keywords content="Go,Memory Model,Concurrency,"><meta property="og:title" content="【译】Go 语言内存模型：2022-06-06 版"><meta property="og:description" content="译者序 原文 The Go Memory Model 描述 Go 语言内存模型，这里的内存模型实际上是“内存一致性模型”（memory consistency model）。笔者修改了格式错误并翻译全文。 The Go Memory Model 在内存一致性模型层面，描述 Go 语言实现（Go implementation）提供的一致性保证，并进一步指出该保证对 Go 语言实现的限制；在工程实践层面，描述使用同步原语确保 goroutine 间可见性的方法，并进一步指出常见的错误同步手法。"><meta property="og:type" content="article"><meta property="og:url" content="/posts/2022/10/20/"><meta property="og:image" content="/posts/2022/10/20/images/featured-image.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-10-20T11:46:49+08:00"><meta property="article:modified_time" content="2022-10-20T11:46:49+08:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="/posts/2022/10/20/images/featured-image.png"><meta name=twitter:title content="【译】Go 语言内存模型：2022-06-06 版"><meta name=twitter:description content="译者序 原文 The Go Memory Model 描述 Go 语言内存模型，这里的内存模型实际上是“内存一致性模型”（memory consistency model）。笔者修改了格式错误并翻译全文。 The Go Memory Model 在内存一致性模型层面，描述 Go 语言实现（Go implementation）提供的一致性保证，并进一步指出该保证对 Go 语言实现的限制；在工程实践层面，描述使用同步原语确保 goroutine 间可见性的方法，并进一步指出常见的错误同步手法。"><meta name=application-name content="FixIt"><meta name=apple-mobile-web-app-title content="FixIt"><meta name=theme-color data-light=#f8f8f8 data-dark=#252627 content="#f8f8f8"><meta name=msapplication-TileColor content="#da532c"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=canonical href=/posts/2022/10/20/><link rel=prev href=/posts/2022/10/13/><link rel=next href=/posts/2022/10/25/><link rel=stylesheet href=/css/style.min.css><link rel=stylesheet href=/lib/fontawesome-free/all.min.css><link rel=stylesheet href=/lib/animate/animate.min.css><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"【译】Go 语言内存模型：2022-06-06 版","inLanguage":"zh-CN","mainEntityOfPage":{"@type":"WebPage","@id":"\/posts\/2022\/10\/20\/"},"image":[{"@type":"ImageObject","url":"\/posts\/2022\/10\/20\/images\/featured-image.png","width":1890,"height":781}],"genre":"posts","keywords":"Go, Memory Model, Concurrency","wordcount":8687,"url":"\/posts\/2022\/10\/20\/","datePublished":"2022-10-20T11:46:49+08:00","dateModified":"2022-10-20T11:46:49+08:00","publisher":{"@type":"Organization","name":""},"author":{"@type":"Person","name":"孔俊"},"description":""}</script></head><body data-header-desktop=sticky data-header-mobile=auto><script>(window.localStorage?.getItem("theme")?localStorage.getItem("theme")==="dark":"auto"==="auto"?window.matchMedia("(prefers-color-scheme: dark)").matches:"auto"==="dark")&&document.body.setAttribute("data-theme","dark")</script><div class=wrapper data-page-style=normal><header class="desktop animate__faster" id=header-desktop><div class=header-wrapper data-github-corner=left><div class=header-title><a href=/ title=孔俊的知识库><img loading=lazy src=/logo.svg srcset="/logo.svg, /logo.svg 1.5x, /logo.svg 2x" sizes=auto data-title=孔俊的知识库 data-alt=孔俊的知识库 class=logo style="background:url(/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'><span class=header-title-text>孔俊的知识库</span></a><span class=header-subtitle></span></div><nav><ul class=menu><li class=menu-item><a class=menu-link href=/posts/>文章</a></li><li class=menu-item><a class=menu-link href=/categories/>分类</a></li><li class=menu-item><a class=menu-link href=/tags/>标签</a></li><li class=menu-item><a class=menu-link href=/archives/>归档</a></li><li class=menu-item><a class=menu-link href=/about/>关于我</a></li><li class="menu-item delimiter"></li><li class="menu-item theme-switch" title=切换主题><i class="fa-solid fa-adjust fa-fw" aria-hidden=true></i></li></ul></nav></div></header><header class="mobile animate__faster" id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title=孔俊的知识库><img loading=lazy src=/logo.svg srcset="/logo.svg, /logo.svg 1.5x, /logo.svg 2x" sizes=auto data-title=/logo.svg data-alt=/logo.svg class=logo style="background:url(/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'><span class=header-title-text>孔俊的知识库</span></a><span class=header-subtitle></span></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><nav><ul class=menu id=menu-mobile><li class=menu-item><a class=menu-link href=/posts/>文章</a></li><li class=menu-item><a class=menu-link href=/categories/>分类</a></li><li class=menu-item><a class=menu-link href=/tags/>标签</a></li><li class=menu-item><a class=menu-link href=/archives/>归档</a></li><li class=menu-item><a class=menu-link href=/about/>关于我</a></li><li class="menu-item menu-system"><span class="menu-system-item theme-switch" title=切换主题><i class="fa-solid fa-adjust fa-fw" aria-hidden=true></i></span></li></ul></nav></div></header><main class=container><aside class=toc id=toc-auto><h2 class=toc-title>目录&nbsp;<i class="toc-icon fa-solid fa-angle-down fa-fw" aria-hidden=true></i></h2><div class=toc-content id=toc-content-auto></div></aside><aside class=aside-custom></aside><article class="page single"><div class=header><h1 class="single-title animate__animated animate__flipInX"><span title=转载 class=icon-repost><i class="fa-solid fa-share fa-fw" aria-hidden=true></i></span><span>【译】Go 语言内存模型：2022-06-06 版</span></h1><p class="single-subtitle animate__animated animate__fadeIn">The Go Memory Model: Version of June 6, 2022</p></div><div class=post-meta><div class=post-meta-line><span class=post-author><span class=author><i class="fa-solid fa-user-circle" aria-hidden=true></i>
孔俊</span></span>
<span class=post-category>收录于 <a href=/categories/go/><i class="fa-regular fa-folder fa-fw" aria-hidden=true></i> Go</a></span></div><div class=post-meta-line><span title="发布于 2022-10-20 11:46:49"><i class="fa-regular fa-calendar-alt fa-fw me-1" aria-hidden=true></i><time datetime=2022-10-20>2022-10-20</time></span>&nbsp;<span title="更新于 2022-10-20 11:46:49"><i class="fa-regular fa-edit fa-fw me-1" aria-hidden=true></i><time datetime=2022-10-20>2022-10-20</time></span>&nbsp;<span><i class="fa-solid fa-pencil-alt fa-fw me-1" aria-hidden=true></i>约 8687 字</span>&nbsp;<span><i class="fa-regular fa-clock fa-fw me-1" aria-hidden=true></i>预计阅读 18 分钟</span>&nbsp;</div></div><div class=featured-image><img loading=lazy src=/posts/2022/10/20/images/featured-image.png srcset="/posts/2022/10/20/images/featured-image.png, /posts/2022/10/20/images/featured-image.png 1.5x, /posts/2022/10/20/images/featured-image.png 2x" sizes=auto data-title=/posts/2022/10/20/images/featured-image.png data-alt=/posts/2022/10/20/images/featured-image.png style="background:url(/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'></div><div class="details toc" id=toc-static data-kept=false><div class="details-summary toc-title"><span>目录</span>
<span><i class="details-icon fa-solid fa-angle-right" aria-hidden=true></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><a href=#译者序>译者序</a></li><li><a href=#tldr>TL;DR</a></li><li><a href=#简介>简介</a><ul><li><a href=#建议>建议</a></li></ul></li><li><a href=#非正式概述>非正式概述</a></li><li><a href=#内存模型>内存模型</a></li><li><a href=#对包含数据竞争的程序的实现限制>对包含数据竞争的程序的实现限制</a></li><li><a href=#同步>同步</a><ul><li><a href=#初始化>初始化</a></li><li><a href=#创建-goroutine>创建 goroutine</a></li><li><a href=#销毁-goroutine>销毁 goroutine</a></li><li><a href=#channel-通信>channel 通信</a></li><li><a href=#锁>锁</a></li><li><a href=#once>Once</a></li><li><a href=#原子值>原子值</a></li><li><a href=#finalizer>Finalizer</a></li><li><a href=#其他机制>其他机制</a></li></ul></li><li><a href=#错误的同步>错误的同步</a></li><li><a href=#错误的编译>错误的编译</a></li><li><a href=#结论>结论</a></li></ul></nav></div></div><div class=content id=content><h2 id=译者序>译者序</h2><p>原文 <a href=https://go.dev/ref/mem target=_blank rel="external nofollow noopener noreferrer"><em>The Go Memory Model</em><i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a> 描述 Go 语言内存模型，这里的内存模型实际上是“内存一致性模型”（memory consistency model）。笔者修改了格式错误并翻译全文。</p><p><a href=https://go.dev/ref/mem target=_blank rel="external nofollow noopener noreferrer"><em>The Go Memory Model</em><i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a> 在内存一致性模型层面，描述 Go 语言实现（Go implementation）提供的一致性保证，并进一步指出该保证对 Go 语言实现的限制；在工程实践层面，描述使用同步原语确保 goroutine 间可见性的方法，并进一步指出常见的错误同步手法。</p><p>Go 语言内存模型在语言层面，保证无数据竞争程序(data-race-free program)符合顺序一致模型（sequential consistency model），通过 channel 和<code>sync</code>包中的同步原语（synchronizing primitive)提供内存一致性保证。</p><p>处理器层面上，不同处理器的不同的内存一致性模型，例如 x86 的 TSO(Total Store Order)。语言层面的内存一致模型是建立在处理器之上的抽象，使程序员可以忽略处理器的差异，依赖语言提供的内存一致性模型编程。Go 语言为无数据竞争程序提供顺序一致模型的保证，程序员只要确保自己编写的程序没有数据竞争，就可以认为“不论是什么处理器，程序执行都是顺序一致的”。</p><p>处理器顺序一致模型可以参考 <a href=http://lamport.azurewebsites.net/ target=_blank rel="external nofollow noopener noreferrer">lamport<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a> 的著名论文 <a href=http://lamport.azurewebsites.net/pubs/multi.pdf target=_blank rel="external nofollow noopener noreferrer"><em>How to Make a Multiprocessor Computer That Correctly Executes Multiprocess Programs</em><i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a> 和我的博客 <a href=https://www.kongjun18.me/posts/how-to-make-a-multiprocessor-computer-that-correctly-executes-multiprocess-programs target=_blank rel="external nofollow noopener noreferrer">【译】 如何设计正确运行多进程程序的多核计算机<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a>。</p><p>注意，要区分同步线程执行次序的“同步原语”和保证内存操作可见性的“同步”。前者的目的是限制线程的执行次序，比如使用条件变量让线程 A 等待线程 B 完成某操作；后者的目的是保证内存位置上内存操作的可见性，比如线程 A 可以观察到线程 B 对内存位置 <em>x</em> 的写，但不保证线程 A 和 B 的执行次序。</p><p>一般来说，编程语言提供的同步原语（互斥锁、读写锁等）实现通过处理器提供的内存屏障（memory barrier）指令等机制保证了内存操作的可见性，即<strong>编程语言提供的同步原语附带内存一致性保证</strong>。Go 程序员使用<code>sync</code>包提供的互斥锁等同步原语和语言内置的 channel 等保证内存可见性。C++ 内存模型不仅提供了符合程序员视角的顺序一致模型，还提供了更宽松的内存一致性模型以便聪明程序员用脑力换算力。原文建议：别太聪明，直接使用<code>sync</code>包提供的同步原语！</p><h2 id=tldr>TL;DR</h2><ul><li><p>无数据竞争程序的执行符合顺序一致模型。</p></li><li><p>goroutine 内的内存操作满足 sequenced before 关系。</p></li><li><p>goroutine 间的同步操作满足 synchronized before 关系。</p></li><li><p>happens before 和 sequenced before 关系是偏序。</p></li><li><p>happens before 关系定义为 synchronized before 和 sequenced before 的传递闭包。</p></li><li><p>读操作 <em>r</em> 读取到的值 <em>W(r)</em> 一定是最近一次 happens before <em>r</em> 的写操作 <em>w</em> 的值。</p></li><li><p>不满足 happens before 关系，即使读到了写 <em>w</em> 的值，也不能保证能读到更早的写 <em>w&rsquo;</em> 的值。</p></li><li><p>读小于或等于一个字的数据一定能读到其他 goroutine 最后写入的值。</p></li><li><p>goroutine 的退出不同步于任何事件。</p></li><li><p>读、原子读、获取 mutex、channel 接收是 read-like 操作。</p></li><li><p>写、原子写、释放 mutex、channel 发送和 channel 关闭是 write-like 操作。</p></li><li><p>compare-and-swap 同时是 read-like 和 write-like 的。</p></li></ul><p><figure><img src=images/happens-before-relationship.png alt=happens-before-relationship><figcaption>happens-before-relationship</figcaption></figure></p><h2 id=简介>简介</h2><p>Go 语言内存模型指定何种条件下保证一个 goroutine 对某变量的读操作可以观察到其他 goroutine 写此变量的值。</p><h3 id=建议>建议</h3><p>修改多个 goroutine 同时访问的数据的程序必须序列化（serialize）这些访问。</p><p>为了序列化访问，使用 channel 操作或其他同步原语，例如<code>sync</code>和<code>sync/atomic</code>包中的那些。</p><p>如果你必须阅读此文档来理解你程序的行为，你就聪明过头了。</p><p>别太聪明。</p><h2 id=非正式概述>非正式概述</h2><p>Go 以与其他语言几乎相同的方式处理其内存模型，旨在保持语义简单、可理解和有用。 本节给出了给出一般概述，对于大多数程序员来说应该足够了。 下一节将更正式地描述内存模型。</p><p><em>数据竞争</em>（<em>data race</em>）定义为对一个内存地址的写操作和其他对该内存地址的读写操作并发进行，除非所有涉及的访问都是<code>sync/atomic</code>包提供的原子数据访问。就像之前提到的，强烈建议程序员使用合适的同步手段避免数据竞争。没有数据竞争时，Go 程序看起来就像所有 goroutine 被复用在一个多处理器上。这一性质有时称为 DRF-SC：无数据竞争的程序顺序一致执行。</p><p>虽然程序员应当编写无数据竞争的程序，但仍然有对 Go 实现可以如何响应数据竞争的限制。实现可能总是报告数据竞争并终止程序。否则，单字大小或小于单字大小的内存读取必须观察到实际写入到该位置的（可能由一个并发执行的 goroutine）、仍未被覆盖的值。这些实现约束让 Go 更像 Java 或 JavaScript，这些语言中大部分竞争不会有严重后果；更不像 C 和 C++，这些语言中存在数据竞争的程序完全是未定义的，编译器可以做任何事。Go 的方式旨在让错误的程序更加可靠和更易于调试的同时，仍然坚持数据竞争是错误，工具应该诊断并报告它们。</p><h2 id=内存模型>内存模型</h2><p>以下 Go 语言内存模型的正式定义紧跟 Hans-J. Boehm 和 Sarita V. Adve 在 PLDI 2008 发表的 <a href=https://www.hpl.hp.com/techreports/2008/HPL-2008-56.pdf target=_blank rel="external nofollow noopener noreferrer"><em>Foundations of the C++ Concurrency Memory Model</em><i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a> 中的定义。无数据竞争程序及对无数据竞争程序的顺序一致模型的定义和这篇论文中的相同。</p><p>内存模型描述程序执行的要求，程序执行由 goroutine 执行组成，goroutine 执行由内存操作组成。</p><p>一个<em>内存操作</em>（<em>memory operation</em>）建模为以下四点：</p><ul><li><p>内存操作的类型，指明它是普通的数据读取，普通的数据写入，或者<em>同步操作</em>（<em>synchronizing operation</em>）例如原子数据访问、互斥锁操作或 channel 操作；</p></li><li><p>内存操作在程序中的位置；</p></li><li><p>内存位置或访问的变量，和</p></li><li><p>内存操作读或写的值。</p></li></ul><p>一些内存操作是 <em>read-like</em> 的，包括读、原子读、获取 mutex、channel 接收。其他内存操作是 <em>write-like</em> 的，包括写、原子写、释放 mutex、channel 发送和 channel 关闭。另一些，例如原子的 compare-and-swap 同时是 read-like 和 write-like 的。</p><p>goroutine 执行（goroutine execution）建模为单个 goroutine 执行的内存操作集合。</p><p><strong>要求 1</strong>: 给定从内存读取或写入的值，每个 goroutine 内的内存操作必须对应该 goroutine 的一次正确的顺序执行。执行必须和 <em>sequenced before</em> 关系一致。sequenced before 关系是<a href=https://go.dev/ref/spec target=_blank rel="external nofollow noopener noreferrer">Go 语言规范<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a>为控制流结构和<a href=https://go.dev/ref/spec#Order_of_evaluation target=_blank rel="external nofollow noopener noreferrer">语句的执行次序<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a>定义的一个偏序。</p><p>Go <em>程序执行</em>（<em>program execution</em>）建模为 goroutine 执行的集合，映射 M 指定 read-like 操作读取的 write-like 操作。（同一程序的多个执行可以有不同的程序执行）。</p><blockquote><p><strong>译者注</strong></p><p>同一程序的多个执行可以有不同的程序执行（Multiple executions of the same program can have different program executions.）的实例是多 goroutine 程序，Go scheduler 每次执行调度 goroutine 的结果未必相同，第一次可能 goroutine 1 先运行，第二次执行可能 goroutine 1 后运行。</p></blockquote><p><strong>要求 2</strong>：对于一个给定的程序执行，映射 M 当仅限于同步操作时，必须可以通过某种和序列（sequencing）一致的同步操作的隐式全序和这些操作读取、写入的值解释。</p><p><em>synchronized before</em> 关系是源自 W 的同步内存操作上的偏序。如果一个同步 read-like 内存操作 <em>r</em> 观察（observes）到一个同步 write-like 内存操作 <em>w</em>（也就是说，如果 <em>W(r)</em> = <em>w</em>），那么 <em>w</em> <em>synchronized before</em> <em>r</em>。非正式地，synchronized before 关系是前面提到的隐含的全序的一个子集，仅限于 <em>W</em> 直接观察到的信息。</p><blockquote><p><strong>译者注</strong></p><p>这里的意思应该是，当 M 是一个同步操作时，程序执行的结果可以通过一个符合顺序一致模型的执行次序解释。</p></blockquote><p><strong>要求 3</strong>: 对一个平凡的（非同步的）在内存位置 <em>x</em> 上的数据读取 <em>r</em>，<em>W(r)</em> 必须是对 <em>r</em> <em>可见的</em>（<em>visible</em>）写 <em>w</em>，这里的可见意味着同时满足以下两点：</p><ol><li><p><em>w</em> happens before <em>r</em>。</p></li><li><p><em>w</em> 不 happen before 任何其他 happens before r 的向 <em>x</em> 的写 <em>w&rsquo;</em>。</p></li></ol><blockquote><p><strong>译者注</strong></p><p>这个 <em>W(r)</em> 读到的是最近一次 happens before <em>r</em> 的 <em>w</em> 的结果。</p></blockquote><p>内存位置 <em>x</em> 上的<em>读-写数据竞争</em>（<em>read-write data race</em>）包含一个 <em>x</em> 上的 read-like 内存操作 <em>r</em> 和一个 <em>x</em> 上的 write-like 内存操作 <em>w</em>，其中至少一个是非同步（的non-synchronizing），这样的读写会乱序 happens before（也就是说，既不 <em>r</em> happens before <em>w</em>，也不 <em>w</em> happens before <em>r</em>）。</p><p>内存位置 <em>x</em> 上的<em>写-写数据竞争</em>（<em>write-write data race</em>）包含两个 <em>x</em> 上的 write-like 内存操作 <em>w</em> 和 <em>w&rsquo;</em>，其中至少一个是非同步的，这样的写写操作会乱序 happens before。</p><p>注意，如果内存位置 <em>x</em> 上没有读-写或写-写数据竞争，那么所有 <em>x</em> 上的读 <em>r</em> 只有一个可能的 <em>W(r)</em>：这个唯一的、按 happens before 次序立刻先于它的 <em>w</em>。</p><p>更一般地说，可以证明任何无数据竞争的 Go 程序（这意味着它没有具有读写数据竞争的程序执行）的执行结果，只能由一些顺序一致的、交错的 goroutine 执行解释 。（证明与上面引用的 Boehm 和 Adve 论文的第 7 节相同。）这个性质称为 DRF-SC。</p><p>正式定义的目的是匹配其他语言（包括 C、C++、Java、JavaScript、Rust 和 Swift）为无竞争程序提供的 DRF-SC 保证。</p><p>某些 Go 语言操作（例如 goroutine 创建和内存分配）充当同步操作。 这些操作对 synchronized-before 偏序的的影响记录在下面的“同步“一节中。 各个包负责为其己的操作提供类似的文档。</p><h2 id=对包含数据竞争的程序的实现限制>对包含数据竞争的程序的实现限制</h2><p>前面的章节给了无数据的竞争程序执行的定义。这一节非正式地描述实现必须为存在竞争的程序提供的语义。</p><p>首先，任何实现都可以检测数据竞争，报告竞争和停止程序的执行。实现使用 ThreadSanitizer（使用“<code>go build -race</code>”访问）做这件事。</p><p>否则，一个不大于一个机器字的内存位置 <em>x</em> 上的读 <em>r</em> 必须观察到一些写 <em>w</em>，使得 <em>r</em> 不 happens before <em>w</em>，且没有一个写 <em>w&rsquo;</em> 使得 <em>w</em> happens before <em>w&rsquo;</em> 且 <em>w&rsquo;</em> happens before <em>r</em>。</p><blockquote><p><strong>译者注</strong></p><p>上面的讲法，简单地说就是：小于一个机器字的 <em>W(r)</em> 读到的是最近一次 happens before <em>r</em> 的 <em>w</em> 的结果。</p></blockquote><p>此外，不允许观察到非因果的和凭空产生的写。</p><p>鼓励大于一个机器字的内存位置上的读观察到单个允许的写 <em>w</em>，但不要求满足机器字大小内存位置上的语义。出于性能原因，实现可以视更大的操作为一系列不限定次序的独立的机器字大小的操作。这意味着多机器字大小数据结构上的竞争可以导致和单一写不一致的值。当值依赖于内部的 (pointer, length) 或 (pointer, type) 对的一致性时，就像大部分 Go 实现中的 interface、map、slice 和 string 一样，这些竞争会反过来导致任意的内存损坏（memory corruption）。</p><p>错误的同步的例子在下面的”错误的同步“一节。</p><p>实现的限制的例子在下面的”错误的编译“一节。</p><h2 id=同步>同步</h2><h3 id=初始化>初始化</h3><p>程序初始化运行在单独的 goroutine 中，但是这个线程可以创建其他并发运行的 goroutine。</p><p><em>如果一个包 p 导入包 q，q 的 <code>init</code>函数的完成 happens before 任何 p 的函数的开始。</em></p><p><em>所有<code>init</code>函数的完成 synchronized before 函数<code>main.main</code>的开始。</em></p><h3 id=创建-goroutine>创建 goroutine</h3><p><em>启动一个新协程的<code>go</code>语句 synchronized before 该协程执行的开始</em>。</p><p>例如，在这个程序中：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>var</span> <span class=nx>a</span> <span class=kt>string</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>f</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=nx>a</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>hello</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>a</span> <span class=p>=</span> <span class=s>&#34;hello, world&#34;</span>
</span></span><span class=line><span class=cl>    <span class=k>go</span> <span class=nf>f</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>调用<code>hello</code>将在未来的某个点（可能在<code>hello</code>返回后）打印<code>"hello, world"</code>。</p><blockquote><p><strong>译者注</strong></p><p><code>a = "hello, world"</code> sequenced before <code>go f()</code></p><p><code>go f()</code> synchronized before <code>f()</code></p></blockquote><h3 id=销毁-goroutine>销毁 goroutine</h3><p>goroutine 的退出不 synchronized before 程序的任何事件。比如，在这个程序：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>var</span> <span class=nx>a</span> <span class=kt>string</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>hello</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>go</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span> <span class=nx>a</span> <span class=p>=</span> <span class=s>&#34;hello&#34;</span> <span class=p>}()</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=nx>a</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>没有任何同步事件跟随在对<code>a</code>赋值后，所以不保证它可以被其他任何 goroutine 观察到。事实上，激进的编译器可以删除这整个<code>go</code>语句。</p><blockquote><p><strong>译者注</strong></p><p>Go 内存模型规定”goroutine 的退出不 synchronized before 程序的任何事件“，这里创建的 gouroutine 的任何操作不被任何其他 goroutine 观察到是<strong>合法的</strong>。因此编译器可以认为这个<code>go</code>语句不产生任何影响，是多余的，直接删掉。</p></blockquote><p>如果一个 goroutine 的副作用必须被另一个 goroutine 观察到，请使用锁或 channel 通信之类的同步机制建立一个相对次序（relative ordering）。</p><h3 id=channel-通信>channel 通信</h3><p>channel 通信是 goroutine 间通信的主要同步方法。一个 channel 上的每个发送都匹配该 channel 上对应的接收（通常在不同 goroutine 上）。</p><p><em>给定 channel 上的发送操作 synchronized before 该 channel 上接收操作的完成。</em></p><p>这个程序：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>var</span> <span class=nx>c</span> <span class=p>=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kt>int</span><span class=p>,</span> <span class=mi>10</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=nx>a</span> <span class=kt>string</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>f</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>a</span> <span class=p>=</span> <span class=s>&#34;hello, world&#34;</span>
</span></span><span class=line><span class=cl>    <span class=nx>c</span> <span class=o>&lt;-</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>go</span> <span class=nf>f</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=o>&lt;-</span><span class=nx>c</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=nx>a</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>保证打印<code>"hello, world"</code>。对<code>a</code>的写 sequenced before <code>c</code>上的发送，<code>c</code>上的发送 synchronized before <code>c</code>上对应的接收完成，接收操作的完成 sequenced before 调用<code>print</code>。</p><p><em>给定 channel 的关闭 synchronized before 因 channel 关闭而返回空值的接收</em>。</p><p>在之前的例子中，用<code>close(c)</code>替代<code>c &lt;- 0</code>得到确保同样行为的程序。</p><p><em>给定 unbuffered channel 上的接收 synchronized before 对应 channel 上发送操作的完成</em>。</p><p>这个程序（和上面的一样，但是交换了发送和接收语句，并使用 unbufferd channel）：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>var</span> <span class=nx>c</span> <span class=p>=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kt>int</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=nx>a</span> <span class=kt>string</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>f</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>a</span> <span class=p>=</span> <span class=s>&#34;hello, world&#34;</span>
</span></span><span class=line><span class=cl>    <span class=o>&lt;-</span><span class=nx>c</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>go</span> <span class=nf>f</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=nx>c</span> <span class=o>&lt;-</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=nx>a</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>也保证打印<code>"hello, world"</code>。对<code>a</code>的写 sequenced before <code>c</code>上的接收，<code>c</code>上的接收 synchronized before <code>c</code>上对应发送的完成，<code>c</code>上对应发送的完成 sequenced before <code>print</code>。</p><p>如果 channel 是有缓冲的（例如<code>c = make(chan int, 1)</code>），那就不能保证这个程序打印<code>"hello, world"</code>。（它可能打印空字符串，崩溃或做别的什么事。）</p><blockquote><p><strong>译者注</strong></p><p><code>c</code>上的第一次接收 synchronized before 其上第 1+1=2 次发送，因此程序中 <code>&lt;- c</code>和<code>c &lt;- 0</code>不构成 synchronized before 关系，不能保证<code>print(a)</code>观察到<code>a = "hello, world"</code>。</p></blockquote><p><em>容量为 C 的 channel 上的第 k 次接收 synchronized before 其上第 k+C 次发送的完成</em>。</p><p>这个规则泛化了前面有关 bufferd channel 的规则。它允许使用 bufferd channel 建模计数信号量：channel 中的元素数量对应活跃使用的数量，channel 的容量对应最大并发使用量，发送数据相当于获取信号量，接收数据相当于释放信号量。 这是限制并发的常用手法。</p><p>这个程序为工作列表的每一项启动一个 goroutine，但是 goroutine 使用<code>limit</code> channel 协调，确保任意时刻最多只有 3 个运行的工作。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>var</span> <span class=nx>limit</span> <span class=p>=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kt>int</span><span class=p>,</span> <span class=mi>3</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>w</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>work</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>go</span> <span class=kd>func</span><span class=p>(</span><span class=nx>w</span> <span class=kd>func</span><span class=p>())</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>limit</span> <span class=o>&lt;-</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>            <span class=nf>w</span><span class=p>()</span>
</span></span><span class=line><span class=cl>            <span class=o>&lt;-</span><span class=nx>limit</span>
</span></span><span class=line><span class=cl>        <span class=p>}(</span><span class=nx>w</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>select</span><span class=p>{}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=锁>锁</h3><p><code>sync</code>包实现了<code>sync.Mutex</code>和<code>sync.RWMutex</code>两种锁数据类型。</p><p><em>对于任意<code>sync.Mutex</code>或<code>sync.RWMutex</code>变量<code>l</code>和 n &lt; m，第 n 次调用<code>l.Unlock()</code> synchronized before 第 m 次调用<code>l.Lock()</code>返回。</em></p><blockquote><p><strong>译者注</strong></p><p>注意！这里是 n &lt; m，意味着第 N 次 unlock 和第 N 次 lock 不构造 synchronized before 关系。下面的程序就是例子。</p></blockquote><p>这个程序：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>var</span> <span class=nx>l</span> <span class=nx>sync</span><span class=p>.</span><span class=nx>Mutex</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=nx>a</span> <span class=kt>string</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>f</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>a</span> <span class=p>=</span> <span class=s>&#34;hello, world&#34;</span>
</span></span><span class=line><span class=cl>    <span class=nx>l</span><span class=p>.</span><span class=nf>Unlock</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>l</span><span class=p>.</span><span class=nf>Lock</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=k>go</span> <span class=nf>f</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=nx>l</span><span class=p>.</span><span class=nf>Lock</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=nx>a</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>保证打印<code>"print, world"</code>。第一次调用<code>l.Unlock()</code>（在<code>f</code>中） synchronized before 第二次调用<code>l.Lock()</code>（在<code>main()</code>中）的返回，它 sequenced before <code>print</code>。</p><p><em>对于任何<code>sync.RWMutex</code>变量<code>l</code>上的<code>l.RLock</code>调用，都存在一个 n，使得第 n 次调用<code>l.Unlock</code> synchronized before <code>l.RLock</code>的返回，并且匹配的<code>l.RUnlock</code>调用 synchronized before 第 n+1 次<code>l.Lock</code>调用返回。</em></p><p><em>对<code>l.TryLock</code>（或<code>l.TryRLock</code>）的成功调用等价于调用<code>l.Lock</code>（或<code>l.RLock</code>）。不成功的调用完全没有同步效果</em>。就内存模型而言，可以认为<code>l.TryLock</code>（或<code>l.TryRlock</code>）即使在互斥锁<code>l</code>被解锁时也能够返回 false。</p><blockquote><p><strong>译者注</strong></p><p>原文没有详细解释“就内存模型而言，可以认为<code>l.TryLock</code>（或<code>l.TryRlock</code>）即使在互斥锁<code>l</code>被解锁时也能够返回 false。”</p><p>我认为这样讲是因为，<code>l.Lock</code>（或<code>l.RLock</code>）执行成功也未必会有同步效果（见上面 unlock 和 lock 的规则），如果<code>l.Lock</code>（或<code>l.RLock</code>)执行成功但没有同步效果，等价于对应的<code>l.TryLock</code>（或(<code>l.TryRLock</code>)没有同步效果，相当于<code>l.TryLock</code>（或<code>l.TryRLock</code>）调用失败的情形。</p></blockquote><h3 id=once>Once</h3><p><code>sync</code>包通过<code>Once</code>类型提供了一种多 goroutine 情形下安全的初始化机制。多个线程可以为特定<code>f</code>执行<code>once.Do(f)</code>，但只有一个会运行<code>f()</code>，其他的调用阻塞直到<code>f()</code>返回。</p><blockquote><p><strong>译者注</strong></p><p>这里和下文的线程都指 goroutine。</p></blockquote><p><em><code>once.Do(f)</code>中单个<code>f()</code>调用的完成 synchronized before 任何<code>once.Do(f)</code>调用。</em></p><p>在这个程序中：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>var</span> <span class=nx>a</span> <span class=kt>string</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=nx>once</span> <span class=nx>sync</span><span class=p>.</span><span class=nx>Once</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>setup</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>a</span> <span class=p>=</span> <span class=s>&#34;hello, world&#34;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>doprint</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>once</span><span class=p>.</span><span class=nf>Do</span><span class=p>(</span><span class=nx>setup</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=nx>a</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>twoprint</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>go</span> <span class=nf>doprint</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=k>go</span> <span class=nf>doprint</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>调用<code>twoprint</code>只会调用<code>setup</code>一次。<code>setup</code>函数将在调用<code>print</code>前完成。结果是<code>"hello, world"</code>被打印两次。</p><h3 id=原子值>原子值</h3><p><code>sync/atomic</code>包中的 API 统称为“原子操作”，可用于同步不同 goroutine 的执行。如果原子操作 <em>A</em> 的副作用被原子操作 <em>B</em> 观察到，那么 <em>A</em> synchronized before <em>B</em>。程序中执行的所有原子操作看起来就像以某种顺序一致次序执行。</p><p>前面的定义和 C++ 顺序一致的原子类型以及 Java <code>volatile</code>遍历有相同语义。</p><blockquote><p><strong>译者注</strong></p><p>这里的同步不是指锁等同步原语协调不同线程的执行次序，而是指可见性，不能混为一谈。</p><p>锁等同步原语已经实现了这种可见性上的同步，详见上面的同步规则。</p></blockquote><h3 id=finalizer>Finalizer</h3><p><code>runtime</code>包提供一个<code>SetFinalizer</code>函数，添加一个当特定对象不可达后被调用的 finalizer。调用<code>SetFinalizer(x, f)</code>synchronized before 调用<code>f(x)</code>。</p><blockquote><p><strong>译者注</strong></p><p>Finalizer 即对象不可从程序访问后调用的回调函数，对象不可从程序访问意味着该对象该被垃圾回收器回收了。</p></blockquote><h3 id=其他机制>其他机制</h3><p><code>sync</code>包提供了额外的同步抽象，包括 <a href=https://go.dev/pkg/sync/#Cond target=_blank rel="external nofollow noopener noreferrer">condition variables<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a>, <a href=https://go.dev/pkg/sync/#Map target=_blank rel="external nofollow noopener noreferrer">lock-free maps<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a>, <a href=https://go.dev/pkg/sync/#Pool target=_blank rel="external nofollow noopener noreferrer">allocation pools<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a> 和 <a href=https://go.dev/pkg/sync/#WaitGroup target=_blank rel="external nofollow noopener noreferrer">wait groups<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a>。它们的文档指定了它们对同步所做的保证。</p><p>其他提供了同步抽象的包应该也记录了它们所做的保证。</p><h2 id=错误的同步>错误的同步</h2><p>带数据竞争的程序是错误的，可以表现出非顺序一致的执行。特别要注意读 <em>r</em> 可以观察到任何和 <em>r</em> 并发的写 <em>w</em> 写入的值。即使发生这种情况，也不意味发生在 <em>r</em> 之后的读可以观察到发生在 <em>w</em> 之前的写。</p><blockquote><p><strong>译者注</strong></p><p>满足 happens before 关系才可以保证 <em>r</em> 观察到 happens before 关系上最近的 <em>w</em>。</p></blockquote><p>在这个程序中：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>var</span> <span class=nx>a</span><span class=p>,</span> <span class=nx>b</span> <span class=kt>int</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>f</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>a</span> <span class=p>=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>    <span class=nx>b</span> <span class=p>=</span> <span class=mi>2</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>g</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=nx>b</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=nx>a</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>go</span> <span class=nf>f</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=nf>g</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>可能会发生<code>g</code>先打印<code>2</code>后打印<code>0</code>的情况。</p><p>这一事实让一些常见手法失效。</p><p>双重检查锁（double-checked locking）是一种避免同步开销的尝试。 例如，twoprint 程序可能被错误地写为：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>var</span> <span class=nx>a</span> <span class=kt>string</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=nx>done</span> <span class=kt>bool</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>setup</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>a</span> <span class=p>=</span> <span class=s>&#34;hello, world&#34;</span>
</span></span><span class=line><span class=cl>    <span class=nx>done</span> <span class=p>=</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>doprint</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>!</span><span class=nx>done</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>once</span><span class=p>.</span><span class=nf>Do</span><span class=p>(</span><span class=nx>setup</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=nx>a</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>twoprint</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>go</span> <span class=nf>doprint</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=k>go</span> <span class=nf>doprint</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>但是这里不能保证在<code>doprint</code>中观察到写入<code>done</code>隐含观察到写入<code>a</code>。这个版本（错误地）打印一个空字符串而非<code>"hello, world"</code>。</p><p>另一个错误手法是忙等待（busy waiting）一个值，例如：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>var</span> <span class=nx>a</span> <span class=kt>string</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=nx>done</span> <span class=kt>bool</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>setup</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>a</span> <span class=p>=</span> <span class=s>&#34;hello, world&#34;</span>
</span></span><span class=line><span class=cl>    <span class=nx>done</span> <span class=p>=</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>go</span> <span class=nf>setup</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>!</span><span class=nx>done</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=nx>a</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>和之前一样，无法保证在<code>main</code>中观察到写入<code>done</code>隐含观察到写入<code>a</code>，所以这个程序也可以打印一个空白字符串。更糟糕的是，无法保证写入<code>done</code>被<code>main</code>观察到，因为两个线程间没有同步事件。不保证<code>main</code>中的<code>loop</code>可以结束。</p><p>关于这个主题还有一个更难以察觉的变形，例如这个程序：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>T</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>msg</span> <span class=kt>string</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=nx>g</span> <span class=o>*</span><span class=nx>T</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>setup</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>t</span> <span class=o>:=</span> <span class=nb>new</span><span class=p>(</span><span class=nx>T</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>t</span><span class=p>.</span><span class=nx>msg</span> <span class=p>=</span> <span class=s>&#34;hello, world&#34;</span>
</span></span><span class=line><span class=cl>    <span class=nx>g</span> <span class=p>=</span> <span class=nx>t</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>go</span> <span class=nf>setup</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>g</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=nx>g</span><span class=p>.</span><span class=nx>msg</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>即使<code>main</code>观察到<code>g != nil</code>并且退出循环，也不能保证它会观察到<code>g.msg</code>的初始值。</p><p>在所有这些例子中，解决办法是相同的：使用显式的同步机制。</p><h2 id=错误的编译>错误的编译</h2><p>Go 内存模型对编译器优化的限制和对 Go 程序的限制一样多。一些单线程中靠谱的优化放到所有 Go 程序中是不可靠的。尤其是编译器不得引入原程序中不存在的写操作，不得让单个读操作观察到多个值，以及不得允许单个写操作写多个值。</p><p>以下所有例子假设<code>*p</code>和<code>*q</code>指向可被多个 goroutine 访问的内存位置。</p><p>不得给无竞争程序引入数据竞争意味着不得将可能出现在条件语句中的写操作移到条件语句之外。例如，编译器不得反转此程序中的条件：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=o>*</span><span class=nx>p</span> <span class=p>=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=nx>cond</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=o>*</span><span class=nx>p</span> <span class=p>=</span> <span class=mi>2</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>也就是说，编译器不能将程序改写成这个：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=o>*</span><span class=nx>p</span> <span class=p>=</span> <span class=mi>2</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>!</span><span class=nx>cond</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=o>*</span><span class=nx>p</span> <span class=p>=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>如果<code>cond</code>为 false 并且另一 goroutine 正在读<code>*p</code>，那么在原始程序中，其他 goroutine 只能观察所有<code>*p</code>的旧值和<code>1</code>。在重写的程序中，其他 goroutine 可以观察到<code>2</code>，这在原始程序中是不可能的。</p><p>不引入数据竞争也意味着不能假设循环会终止。例如，编译器通常不得将对<code>*p</code>或<code>*q</code>的访问移动到此程序中的循环之前：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>n</span> <span class=o>:=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=nx>e</span> <span class=o>:=</span> <span class=nx>list</span><span class=p>;</span> <span class=nx>e</span> <span class=o>!=</span> <span class=kc>nil</span><span class=p>;</span> <span class=nx>e</span> <span class=p>=</span> <span class=nx>e</span><span class=p>.</span><span class=nx>next</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>n</span><span class=o>++</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=nx>i</span> <span class=o>:=</span> <span class=o>*</span><span class=nx>p</span>
</span></span><span class=line><span class=cl><span class=o>*</span><span class=nx>q</span> <span class=p>=</span> <span class=mi>1</span>
</span></span></code></pre></div><p>如果<code>list</code>指向一个循环链表，那么原始程序将不会访问<code>*p</code>和<code>*q</code>但是重写的程序会。（如果编译器可以证明<code>*p</code>不会 panic，那么前移<code>*p</code>是安全的；前移<code>*q</code>还需要编译器证明没有其他 goroutine 可以访问<code>*q</code>。）</p><p>不引入数据竞争也意味着不得假设被调用的函数总能返回或和同步操作无关。例如，编译器不得将此程序中访问<code>*p</code>和<code>*q</code>移动到函数调用之前（至少在不直接了解 <code>f</code>的准确行为的情况下）：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nf>f</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=nx>i</span> <span class=o>:=</span> <span class=o>*</span><span class=nx>p</span>
</span></span><span class=line><span class=cl><span class=o>*</span><span class=nx>q</span> <span class=p>=</span> <span class=mi>1</span>
</span></span></code></pre></div><p>如果调用永不返回，那么原始程序将永远不会访问<code>*p</code>和<code>*q</code>，但重写的程序会。 如果调用包含同步操作，那么原始程序可以在访问<code>*p</code>和 <code>*q</code>之前建立 happens before 关系，但重写的程序不会。</p><p>不允许单个写操作写入多个值也意味着，在写入局部变量之前不得使用该局部变量作为临时存储。 例如，编译器不得在此程序中使用<code>*p</code>作为临时存储：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=o>*</span><span class=nx>p</span> <span class=p>=</span> <span class=nx>i</span> <span class=o>+</span> <span class=o>*</span><span class=nx>p</span><span class=o>/</span><span class=mi>2</span>
</span></span></code></pre></div><p>也就是说，编译器不能将程序改写成这个：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=o>*</span><span class=nx>p</span> <span class=o>/=</span> <span class=mi>2</span>
</span></span><span class=line><span class=cl><span class=o>*</span><span class=nx>p</span> <span class=o>+=</span> <span class=nx>i</span>
</span></span></code></pre></div><p>如果<code>i</code>和<code>*p</code>一开始等于 2，原始代码执行<code>*p = 3</code>，所以竞争的线程只能从<code>*p</code>读取到 2 或 3。重写的代码先执行<code>*p = 1</code>后执行<code>p =3</code>，让竞争线程可能读取到 1。</p><p>注意，所有这些优化在 C/C++ 编译器中都是允许的：和 C/C++ 编译器共用后端的 Go 编译器必须小心地禁用对 Go 无效的优化。</p><p>注意，禁止引入数据竞争不适用于编译器可以证明在目标平台上竞争不影响正确执行的情形。例如，在几乎所有 CPU 上，都可以重写</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>n</span> <span class=o>:=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=nx>m</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>n</span> <span class=o>+=</span> <span class=o>*</span><span class=nx>shared</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>为：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>n</span> <span class=o>:=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl><span class=nx>local</span> <span class=o>:=</span> <span class=o>*</span><span class=nx>shared</span>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=nx>m</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>n</span> <span class=o>+=</span> <span class=nx>local</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>前提是可以证明<code>*shared</code>在访问时不会出错，因为潜在添加的读取不会影响任何现有的并发读取或写入。 另一方面，这种重写在源到源的翻译器中是无效的。</p><blockquote><p><strong>译者注</strong></p><p>禁止引入数据竞争是为了确保多线程程序的正确执行（程序执行的副作用和原始程序的相同），如果引入了数据竞争但不影响多线程程序的执行，那么提高性能却引入数据竞争的编译器优化是合理的。</p><p>在这个改写中，程序在 for 语句之前读取一次<code>*shared</code>，循环中不再读取。从 Go 语言内存模型的视角看，原始程序中对<code>*shared</code>的访问没有任何同步操作，不保证循环中能观察到其他 goroutine 的修改。因此循环中<code>*shared</code>只观察到 for 语句开始时的值是合法的。</p><p>从处理器内存一致性模型的角度看，绝大多数现代处理器（例如 AMD64、ARM）都允许 store-load reroder。因此不保证循环中能观察到其他线程对<code>*shared</code>的修改。</p><p>在这些允许 store-load reorder 的处理器上，编译器的改写是合理的。但在不允许 store-load reorder 的处理器上，循环中一定能观察到其他线程对<code>*shared</code>的修改，改写不等价，因此原文说“基本上在所有 CPU 上，都可以重写”、“这种重写在源到源的翻译器中是无效的”。</p></blockquote><h2 id=结论>结论</h2><p>编写无数据竞争程序的 Go 程序员可以依赖这些程序的顺序一致执行，就像在几乎所有其他现代编程语言中一样。</p><p>当涉及到带有竞争的程序时，程序员和编译器都应该记住这个建议：别太聪明。</p></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span title="更新于 2022-10-20 11:46:49">更新于 2022-10-20&nbsp;</span></div><div class=post-info-license><span><a rel="license external nofollow noopener noreferrer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span></div></div><div class=post-info-line><div class=post-info-md></div><div class=post-info-share><span><a href=javascript:void(0); title="分享到 Twitter" data-sharer=twitter data-url=/posts/2022/10/20/ data-title="【译】Go 语言内存模型：2022-06-06 版" data-hashtags="Go,Memory Model,Concurrency"><i class="fa-brands fa-twitter fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); title="分享到 Facebook" data-sharer=facebook data-url=/posts/2022/10/20/ data-hashtag=Go><i class="fa-brands fa-facebook-square fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); title="分享到 微博" data-sharer=weibo data-url=/posts/2022/10/20/ data-title="【译】Go 语言内存模型：2022-06-06 版"><i class="fa-brands fa-weibo fa-fw" aria-hidden=true></i></a></span></div></div></div><div class=post-info-more><section class=post-tags><i class="fa-solid fa-tags fa-fw me-1" aria-hidden=true></i><a href=/tags/go/ class=post-tag>Go</a><a href=/tags/memory-model/ class=post-tag>Memory Model</a><a href=/tags/concurrency/ class=post-tag>Concurrency</a></section><section><span><a href=javascript:void(0); onclick=window.history.back()>返回</a></span>&nbsp;|&nbsp;<span><a href=/>主页</a></span></section></div><div class=post-nav><a href=/posts/2022/10/13/ class=post-nav-item rel=prev title=【译】一种面向多核架构的无锁、缓存高效的共享环形缓冲区><i class="fa-solid fa-angle-left fa-fw" aria-hidden=true></i>【译】一种面向多核架构的无锁、缓存高效的共享环形缓冲区</a>
<a href=/posts/2022/10/25/ class=post-nav-item rel=next title="【译】Go 语言数据竞争检测器">【译】Go 语言数据竞争检测器<i class="fa-solid fa-angle-right fa-fw" aria-hidden=true></i></a></div></div><div class=post-reward><div class=comment></div><input type=checkbox class=reward-input name=reward id=fi-reward hidden>
<label class=reward-button for=fi-reward>赞赏</label><div class=reward-ways data-mode=static><div><img loading=lazy src=/alipay.jpg srcset="/alipay.jpg, /alipay.jpg 1.5x, /alipay.jpg 2x" sizes=auto data-title="孔俊 支付宝" data-alt="孔俊 支付宝" style="background:url(/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'><span>支付宝</span></div><div><img loading=lazy src=/wechatpay.png srcset="/wechatpay.png, /wechatpay.png 1.5x, /wechatpay.png 2x" sizes=auto data-title="孔俊 微信" data-alt="孔俊 微信" style="background:url(/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'><span>微信</span></div></div></div><div id=comments><div id=giscus><script src=https://giscus.app/client.js data-repo=kongjun18/kongjun18.github.io data-repo-id=R_kgDOICeqmQ data-category=Announcements data-category-id=DIC_kwDOICeqmc4CVeTb data-mapping=pathname data-strict=0 data-theme=preferred_color_scheme data-reactions-enabled=1 data-emit-metadata=0 data-input-position=top data-lang=zh-CN data-loading=lazy crossorigin=anonymous async defer></script></div><noscript>Please enable JavaScript to view the comments powered by <a href=https://giscus.app/ rel="external nofollow noopener noreferrer">giscus</a>.</noscript></div></article></main><footer class=footer><div class=footer-container><div class="footer-line powered">由 <a href=https://gohugo.io/ target=_blank rel="external nofollow noopener noreferrer" title="Hugo 0.110.0">Hugo</a> 强力驱动 | 主题 - <a href=https://github.com/hugo-fixit/FixIt target=_blank rel=external title="FixIt v0.2.18"><img class=fixit-icon src=/fixit.min.svg alt="FixIt logo">&nbsp;FixIt</a></div><div class="footer-line copyright" itemscope itemtype=http://schema.org/CreativeWork><i class="fa-regular fa-copyright fa-fw" aria-hidden=true></i>
<span itemprop=copyrightYear>2022 - 2023</span><span class=author itemprop=copyrightHolder>
<a href=/></a></span><span class="license footer-divider"><a rel="license external nofollow noopener noreferrer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span></div><div class="footer-line statistics"></div></div></footer></div><div class=widgets><div class="fixed-buttons animate__faster d-none"><div class="fixed-button back-to-top" role=button aria-label=回到顶部><i class="fa-solid fa-arrow-up fa-fw" aria-hidden=true></i><span class="variant-numeric d-none">0%</span></div><div class="fixed-button view-comments d-none" role=button aria-label=查看评论><i class="fa-solid fa-comment fa-fw" aria-hidden=true></i></div></div><a href=https://github.com/kongjun18/blog title=查看博客源代码 target=_blank rel="external nofollow" class="github-corner left d-none-mobile"><svg viewBox="0 0 250 250" aria-hidden="true"><path d="M0 0 115 115h15l12 27L250 250V0z"/><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentcolor" style="transform-origin:130px 106px" class="octo-arm"/><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4l13.9-13.8C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8z" fill="currentcolor" class="octo-body"/></svg></a><div id=mask></div><noscript><div class=noscript-warning>FixIt 主题在启用 JavaScript 的情况下效果最佳。</div></noscript></div><link rel=stylesheet href=/lib/cookieconsent/cookieconsent.min.css><script src=/lib/sharer/sharer.min.js async defer></script><script src=/lib/cookieconsent/cookieconsent.min.js defer></script><script src=/lib/pangu/pangu.min.js defer></script><script>window.config={autoBookmark:!0,code:{copyTitle:"复制到剪贴板",editLockTitle:"锁定可编辑代码块",editUnLockTitle:"解锁可编辑代码块",editable:!0,maxShownLines:40},comment:{enable:!0,expired:!1,giscus:{darkTheme:"dark_dimmed",lightTheme:"light"}},cookieconsent:{content:{dismiss:"同意",link:"了解更多",message:"本网站使用 Cookies 来改善您的浏览体验。"},enable:!0,palette:{button:{background:"#f0f0f0"},popup:{background:"#1aa3ff"}},theme:"edgeless"},pangu:{enable:!0,selector:"article"}}</script><script src=/js/theme.min.js defer></script></body></html>