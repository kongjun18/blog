<!doctype html><html itemscope itemtype=http://schema.org/WebPage lang=zh-cn><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=2"><meta name=robots content="noodp"><title>【译】 如何设计正确运行多进程程序的多核计算机 - 孔俊的知识库</title><meta name=author content><meta name=author-link content><meta name=description content="TL;DR SC(Sequential Consistency)：任何执行的结果看起来就像所有处理器都顺序执行，并且单个处理器按照程序指定次序执行。 每个处理器都是顺序的，不意味着整个多核系统是顺序一致的。 SC 是一个定义在内存访问上的偏序。 为了实现 SC，处理器需要满足两个条件： 处理器按照程序次序发起请求。发起请求包括进入内存模块的队列。 内存模块按照 FIFO 次序响应请求。 SC 虽然符合人类直觉，但限制了处理器"><meta name=keywords content="Concurrency,Computer Architecture"><meta itemprop=name content="【译】 如何设计正确运行多进程程序的多核计算机"><meta itemprop=description content="TL;DR SC(Sequential Consistency)：任何执行的结果看起来就像所有处理器都顺序执行，并且单个处理器按照程序指定次序执行。 每个处理器都是顺序的，不意味着整个多核系统是顺序一致的。 SC 是一个定义在内存访问上的偏序。 为了实现 SC，处理器需要满足两个条件： 处理器按照程序次序发起请求。发起请求包括进入内存模块的队列。 内存模块按照 FIFO 次序响应请求。 SC 虽然符合人类直觉，但限制了处理器"><meta itemprop=datePublished content="2022-10-09T15:24:14+08:00"><meta itemprop=dateModified content="2022-10-09T15:24:14+08:00"><meta itemprop=wordCount content="3135"><meta itemprop=image content="/posts/2022/10/09/images/featured-image.webp"><meta itemprop=keywords content="Computer Architecture,Concurrency,"><meta property="og:title" content="【译】 如何设计正确运行多进程程序的多核计算机"><meta property="og:description" content="TL;DR SC(Sequential Consistency)：任何执行的结果看起来就像所有处理器都顺序执行，并且单个处理器按照程序指定次序执行。 每个处理器都是顺序的，不意味着整个多核系统是顺序一致的。 SC 是一个定义在内存访问上的偏序。 为了实现 SC，处理器需要满足两个条件： 处理器按照程序次序发起请求。发起请求包括进入内存模块的队列。 内存模块按照 FIFO 次序响应请求。 SC 虽然符合人类直觉，但限制了处理器"><meta property="og:type" content="article"><meta property="og:url" content="/posts/2022/10/09/"><meta property="og:image" content="/posts/2022/10/09/images/featured-image.webp"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-10-09T15:24:14+08:00"><meta property="article:modified_time" content="2022-10-09T15:24:14+08:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="/posts/2022/10/09/images/featured-image.webp"><meta name=twitter:title content="【译】 如何设计正确运行多进程程序的多核计算机"><meta name=twitter:description content="TL;DR SC(Sequential Consistency)：任何执行的结果看起来就像所有处理器都顺序执行，并且单个处理器按照程序指定次序执行。 每个处理器都是顺序的，不意味着整个多核系统是顺序一致的。 SC 是一个定义在内存访问上的偏序。 为了实现 SC，处理器需要满足两个条件： 处理器按照程序次序发起请求。发起请求包括进入内存模块的队列。 内存模块按照 FIFO 次序响应请求。 SC 虽然符合人类直觉，但限制了处理器"><meta name=application-name content="FixIt"><meta name=apple-mobile-web-app-title content="FixIt"><meta name=theme-color data-light=#f8f8f8 data-dark=#252627 content="#f8f8f8"><meta name=msapplication-TileColor content="#da532c"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=canonical href=/posts/2022/10/09/><link rel=prev href=/posts/2022/09/27/><link rel=next href=/posts/2022/10/13/><link rel=stylesheet href=/css/style.min.css><link rel=stylesheet href=/lib/fontawesome-free/all.min.css><link rel=stylesheet href=/lib/animate/animate.min.css><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"【译】 如何设计正确运行多进程程序的多核计算机","inLanguage":"zh-CN","mainEntityOfPage":{"@type":"WebPage","@id":"\/posts\/2022\/10\/09\/"},"image":[{"@type":"ImageObject","url":"\/posts\/2022\/10\/09\/images\/featured-image.webp","width":4600,"height":2588}],"genre":"posts","keywords":"Computer Architecture, Concurrency","wordcount":3135,"url":"\/posts\/2022\/10\/09\/","datePublished":"2022-10-09T15:24:14+08:00","dateModified":"2022-10-09T15:24:14+08:00","publisher":{"@type":"Organization","name":""},"author":{"@type":"Person","name":"孔俊"},"description":""}</script></head><body data-header-desktop=sticky data-header-mobile=auto><script>(window.localStorage?.getItem("theme")?localStorage.getItem("theme")==="dark":"auto"==="auto"?window.matchMedia("(prefers-color-scheme: dark)").matches:"auto"==="dark")&&document.body.setAttribute("data-theme","dark")</script><div class=wrapper data-page-style=normal><header class="desktop animate__faster" id=header-desktop><div class=header-wrapper data-github-corner=left><div class=header-title><a href=/ title=孔俊的知识库><img loading=lazy src=/logo.svg srcset="/logo.svg, /logo.svg 1.5x, /logo.svg 2x" sizes=auto data-title=孔俊的知识库 data-alt=孔俊的知识库 class=logo style="background:url(/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'><span class=header-title-text>孔俊的知识库</span></a><span class=header-subtitle></span></div><nav><ul class=menu><li class=menu-item><a class=menu-link href=/posts/>文章</a></li><li class=menu-item><a class=menu-link href=/categories/>分类</a></li><li class=menu-item><a class=menu-link href=/tags/>标签</a></li><li class=menu-item><a class=menu-link href=/archives/>归档</a></li><li class=menu-item><a class=menu-link href=/about/>关于我</a></li><li class="menu-item delimiter"></li><li class="menu-item theme-switch" title=切换主题><i class="fa-solid fa-adjust fa-fw" aria-hidden=true></i></li></ul></nav></div></header><header class="mobile animate__faster" id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title=孔俊的知识库><img loading=lazy src=/logo.svg srcset="/logo.svg, /logo.svg 1.5x, /logo.svg 2x" sizes=auto data-title=/logo.svg data-alt=/logo.svg class=logo style="background:url(/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'><span class=header-title-text>孔俊的知识库</span></a><span class=header-subtitle></span></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><nav><ul class=menu id=menu-mobile><li class=menu-item><a class=menu-link href=/posts/>文章</a></li><li class=menu-item><a class=menu-link href=/categories/>分类</a></li><li class=menu-item><a class=menu-link href=/tags/>标签</a></li><li class=menu-item><a class=menu-link href=/archives/>归档</a></li><li class=menu-item><a class=menu-link href=/about/>关于我</a></li><li class="menu-item menu-system"><span class="menu-system-item theme-switch" title=切换主题><i class="fa-solid fa-adjust fa-fw" aria-hidden=true></i></span></li></ul></nav></div></header><main class=container><aside class=toc id=toc-auto><h2 class=toc-title>目录&nbsp;<i class="toc-icon fa-solid fa-angle-down fa-fw" aria-hidden=true></i></h2><div class=toc-content id=toc-content-auto></div></aside><aside class=aside-custom></aside><article class="page single"><div class=header><h1 class="single-title animate__animated animate__flipInX"><span title=转载 class=icon-repost><i class="fa-solid fa-share fa-fw" aria-hidden=true></i></span><span>【译】 如何设计正确运行多进程程序的多核计算机</span></h1><p class="single-subtitle animate__animated animate__fadeIn">How to Make a Multiprocessor Computer That Correctly Executes Multiprocess Programs</p></div><div class=post-meta><div class=post-meta-line><span class=post-author><span class=author><i class="fa-solid fa-user-circle" aria-hidden=true></i>
孔俊</span></span>
<span class=post-category>收录于 <a href=/categories/computer-architecture/><i class="fa-regular fa-folder fa-fw" aria-hidden=true></i> Computer Architecture</a></span></div><div class=post-meta-line><span title="发布于 2022-10-09 15:24:14"><i class="fa-regular fa-calendar-alt fa-fw me-1" aria-hidden=true></i><time datetime=2022-10-09>2022-10-09</time></span>&nbsp;<span title="更新于 2022-10-09 15:24:14"><i class="fa-regular fa-edit fa-fw me-1" aria-hidden=true></i><time datetime=2022-10-09>2022-10-09</time></span>&nbsp;<span><i class="fa-solid fa-pencil-alt fa-fw me-1" aria-hidden=true></i>约 3135 字</span>&nbsp;<span><i class="fa-regular fa-clock fa-fw me-1" aria-hidden=true></i>预计阅读 7 分钟</span>&nbsp;</div></div><div class=featured-image><img loading=lazy src=/posts/2022/10/09/images/featured-image.webp srcset="/posts/2022/10/09/images/featured-image.webp, /posts/2022/10/09/images/featured-image.webp 1.5x, /posts/2022/10/09/images/featured-image.webp 2x" sizes=auto data-title=/posts/2022/10/09/images/featured-image.webp data-alt=/posts/2022/10/09/images/featured-image.webp style="background:url(/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'></div><div class="details toc" id=toc-static data-kept=false><div class="details-summary toc-title"><span>目录</span>
<span><i class="details-icon fa-solid fa-angle-right" aria-hidden=true></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><a href=#tldr>TL;DR</a></li><li><a href=#解读>解读</a></li><li><a href=#译文>译文</a></li></ul></nav></div></div><div class=content id=content><h2 id=tldr>TL;DR</h2><ul><li><p>SC(Sequential Consistency)：任何执行的结果看起来就像所有处理器都顺序执行，并且单个处理器按照程序指定次序执行。</p></li><li><p>每个处理器都是顺序的，不意味着整个多核系统是顺序一致的。</p></li><li><p>SC 是一个定义在内存访问上的偏序。</p></li><li><p>为了实现 SC，处理器需要满足两个条件：</p><ul><li><p>处理器按照程序次序发起请求。发起请求包括进入内存模块的队列。</p></li><li><p>内存模块按照 FIFO 次序响应请求。</p></li></ul></li><li><p>SC 虽然符合人类直觉，但限制了处理器性能。现代处理器实现的是更弱的一致性模型。</p></li></ul><h2 id=解读>解读</h2><p><em>How to Make a Multiprocessor Computer That Correctly Executes Multiprocess Program</em> 是 <a href=http://lamport.azurewebsites.net/ target=_blank rel="external nofollow noopener noreferrer">Leslie Lamport<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a> 在 1979 年发表的一篇著名论文，论文明确定义了多核处理器的<em>顺序一致模型</em>（<em>Sequential Consistency</em>，简称 SC），并给出了实现方法。</p><p>在单核系统上，程序的正确执行次序是顺序执行，即按照程序指定的次序执行指令。在多核系统上，运行在多个核心上的程序的正确执行次序是什么？直观地看，是每个核心都顺序执行，并且核心间交替执行，这种模型就是顺序一致模型。</p><p>方框表示指令，横轴表示次序。在处理器 1 上，先执行 A 再执行 B，处理器 2 上先执行 C 再执行 D。最终用户看到的执行次序是平移两个轴合并起来（保持相对次序，交替执行）。两种（不只两种）可能的次序如下。</p><p><figure><img src=./images/sequential-consistency.png alt="sequential consistency"><figcaption>sequential consistency</figcaption></figure></p><p>顺序一致模型不仅局限于多核处理器。从更普遍的角度看，顺序一致模型是分布式系统中符合用户直觉的一致性模型。多核处理器是分布式系统的一个特例。将上图的处理器替换为“节点”，将指令替换为”事件”，将执行次序替换为时间发生次序，就可以得到更加普遍的顺序一致性语义。事实上，本文中作者就使用了”事件“（<em>event</em>）一词，而非局限在处理器指令。</p><p>论文基于以下模型讨论处理器设计：数据存储在内存模块中，处理器内存模块发起内存访问请求，内存模块响应请求。</p><p><figure><img src=images/processor-memory-architecture.png alt=processor-memory-architecture><figcaption>processor-memory-architecture</figcaption></figure></p><p>论文中的 <em>process</em> 一词译为<em>进程</em>，但不指操作系统的”进程“，更像是<em>线程</em>或”运行在处理器上的逻辑流“。<em>multiprocessor</em> 译为多处理器。</p><h2 id=译文>译文</h2><center><b>How to Make a Multiprocessor Computer That Correctly Executes Multiprocess Programs</b></center>
<center>LESLIE LAMPORT</center><p><strong>摘要——许多大型顺序计算机以不同于程序指定的次序执行操作。正确执行产生的结果与按照程序次序执行得到的结果相同。对于一个多处理器系统，每个处理器的正确执行不能保证整个程序的正确执行。为了保证计算机正确执行多进程程序，必须添加额外条件。</strong></p><p><strong>关键词——计算机设计，并发编程，硬件正确性，多处理，并发处理。</strong></p><hr><p>高速处理器可能以不同于程序指定的次序执行指令。如果满足以下条件，则执行是正确的：执行的结果和按照程序次序执行的结果相同。满足这个条件的处理器可以称为<em>顺序的</em>（<em>sequential</em>）。考虑一个多处理器、统一内存访问的计算机。习惯性的做法是为这种计算机设计并证明满足以下条件的多进程算法[1]-[3]：任何执行的结果看起来就像所有处理器都顺序执行，并且单个处理器按照程序指定次序执行。满足这种条件的多处理器称为<em>顺序一致的</em>（<em>sequentially consistent</em>）。每个处理器的顺序执行不能保证整个计算机是顺序一致的。在这个简短的笔记中，我们描述一种通过带内存模块的、相连的顺序处理器实现顺序一致的多处理器系统的方法。</p><p>我们假设计算机由多个处理器和内存模块组成，所有专门的通信寄存器可以被认为是单独的内存模块。我们唯一考虑的处理器操作是对内存模块的读写请求（<em>load and store requests</em>）。我们假设处理器发送一系列读写请求（处理器有时必须等待请求被执行，但这和我们无关）。</p><p>我们通过一个简单的两进程互斥协议来阐明这个问题。每个进程都包含一个<em>临界区</em>（<em>critical seciton</em>），这个协议的目的是确保在任何时刻只有一个进程可以执行临界区。这个协议如下：</p><pre tabindex=0><code>process 1
---------
    a := 1;
    if b = 0 then critical section;
                    a := 0
             else    ...    fi
process 2
---------
    b : = 1;
    if a = 0 then critical section;
                    b := 0
             else    ...    fi
</code></pre><p>else 语句包含一些可以确保最终访问到临界区的机制，但这和我们的讨论无关。很容易证明这个协议保证了对临界区的互斥访问。（设计一个证明是非常好的使用如 [2] 和 [3] 中的断言技术的练习，这留给读者完成。）因此，当这个两进程程序被顺序一致多处理器执行时，两个进程不可能同时执行他们的临界区。</p><p>我们首先观察到顺序处理器可能以任意次序执行进程 1 的<code>b := 1</code>和<code>fetch b</code>操作。（当只考虑进程 1 的程序自身时，以哪种次序执行两个操作不重要。）显然先执行<code>fetch b</code>操作会导致错误——两个进程可以同时执行临界区。这启示了我们对多处理器计算机的第一个要求。</p><p><em>要求 R1: 每个处理器按程序指定的次序发起内存请求。</em></p><p>满足 R1 很复杂，因为只有计算出了值才能存储它。处理器经常在知道先前的写请求具体的值之前，就已经准备好发送读请求了。为了减少等待，处理器可以只发送写请求而不指定具体的值。当然，写请求不能被执行，直到它收到了要写的值。</p><p>要求 R1 不保证程序的正确执行。为了看到这一点，假设内存模块有多个端口，每个端口接收一个处理器（或 IO 信道）。让<code>a</code>和<code>b</code>分别存储于不同的内存模块，考虑以下事件序列：</p><ol><li><p>处理器 1 发送<code>a := 1</code>请求给它的内存模块 1 端口。此模块正忙于执行其他处理器（或 IO 信道）的操作。</p></li><li><p>处理器 1 发送<code>fetch b</code>请求给它的内存模块 2 端口。此模块空闲，开始执行请求。</p></li><li><p>处理器 2 发送<code>b := 1</code>请求给内存模块 2。这个请求在处理器 1 的<code>fetch b</code>请求完成后执行。</p></li><li><p>处理器 2 发送<code>fetch a</code>请求给它的内存模块 1 端口。此模块仍然繁忙。</p></li></ol><p>现在有两个操作等待内存模块 1 执行。如果处理器 2 的<code>fetch a</code>操作先执行，那么两个处理器可以同时进入临界区，互斥协议失败。如果内存模块使用轮转调度策略（round robin scheduling discipline）服务各端口，可能会发生这种错误。</p><p>这种情况下，仅在内存模块 1 不按两请求进入队列的次序服务时发生错误。这提出了以下要求。</p><p><em>要求 2: 任何处理器发送到某内存模块的内存请求都从它的 FIFO 队列被服务</em>。发送内存请求包括进入队列。</p><p>条件 R1 隐含一个处理器在当前请求进入队列之前，不能发送任何进一步的内存请求。因此处理器在队列满时等待。如果两个或多个处理器同时尝试发送请求到队列，那么他们被服务的次序不重要。</p><p><em>注意</em>。如果读操作请求的是已存在于队列中的写请求的内存位置上的值，这个读请求不需要进入队列。可以直接从队列中返回最近一次写请求的值。</p><p>要求 R1 和 R2 共同确保，每个处理器是顺序的，则整个多处理器计算机是顺序一致的。为了证明这一点，引入一个内存请求上的关系<code>-></code>。定义<code>A->B</code>当且仅当 <strong>1)</strong> A 和 B 是同一处理器发送的，并且 A 先于 B 发送；或 <strong>2)</strong> A 和 B 被发送到相同内存模块，并且 A 先于 B 进入队列（因此先于 B 执行）。很容易看到，R1 和 R2 隐含了<code>-></code>是内存请求上的偏序。基于每个处理器的顺序性，可以证明以下结论：每个读取和写入操作读取或写入好像所有操作都以任何顺序顺序执行时的值，这样<code>A->B</code>意味着 A 在 B 之前执行。</p><p>R2 要求内存模块必须按 FIFO 次序服务请求。这隐含了内存模块必须在队首请求是写请求且值未确定时保持空闲。可以弱化条件 R2 以允许内存模块在此情形下服务其他请求。我们只要求所有对<em>同一内存单元</em>（<em>the same memory cell</em>）的请求按进入队列的次序服务。不同内存单元的请求可以乱序服务。因为这种服务策略逻辑等价于把内存单元当成一个拥有自己队列的内存模块，仍然保证顺序一致性。（这些模块可能共用某些硬件，这会影响服务请求的速率和队列容量，但不影响顺序一致性这一逻辑属性。）</p><p>保证顺序一致性所需的要求排除了一些可用于加速单个顺序处理器的技术。对于一些应用，实现顺序一致性的好处可能不足以抵偿降低处理器性能的代价。在这种情况下，人们必须意识到不能依靠传统的设计多进程算法的方法来设计正确执行的程序。 必须在最底层设计用于同步处理器的协议，验证它们的正确性是一项艰巨的任务。</p><hr><p><strong>REFERENCES</strong></p><p>[1] E. W. Dijkstra, &ldquo;Hierarchical ordering of sequential processes,&rdquo; Acta Informatica, vol. 1, pp. 115-138, 1971.</p><p>[2] L. Lamport, &ldquo;Proving the correctness of multiprocess programs,&rdquo; IEEE Trans. Software Eng., vol. SE-3, pp. 125-143, Mar. 1977.</p><p>[3] S. Owicki and D. Gries, &lsquo;Verifying properties of parallel programs: an axiomatic approach," Commun. Assoc. Comput. Mach., vol. 19, pp. 279-285, May 1976.</p></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span title="更新于 2022-10-09 15:24:14">更新于 2022-10-09&nbsp;</span></div><div class=post-info-license><span><a rel="license external nofollow noopener noreferrer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span></div></div><div class=post-info-line><div class=post-info-md></div><div class=post-info-share><span><a href=javascript:void(0); title="分享到 Twitter" data-sharer=twitter data-url=/posts/2022/10/09/ data-title="【译】 如何设计正确运行多进程程序的多核计算机" data-hashtags="Computer Architecture,Concurrency"><i class="fa-brands fa-twitter fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); title="分享到 Facebook" data-sharer=facebook data-url=/posts/2022/10/09/ data-hashtag="Computer Architecture"><i class="fa-brands fa-facebook-square fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); title="分享到 微博" data-sharer=weibo data-url=/posts/2022/10/09/ data-title="【译】 如何设计正确运行多进程程序的多核计算机"><i class="fa-brands fa-weibo fa-fw" aria-hidden=true></i></a></span></div></div></div><div class=post-info-more><section class=post-tags><i class="fa-solid fa-tags fa-fw me-1" aria-hidden=true></i><a href=/tags/computer-architecture/ class=post-tag>Computer Architecture</a><a href=/tags/concurrency/ class=post-tag>Concurrency</a></section><section><span><a href=javascript:void(0); onclick=window.history.back()>返回</a></span>&nbsp;|&nbsp;<span><a href=/>主页</a></span></section></div><div class=post-nav><a href=/posts/2022/09/27/ class=post-nav-item rel=prev title="【译】拨开 Linux 平均负载的谜团"><i class="fa-solid fa-angle-left fa-fw" aria-hidden=true></i>【译】拨开 Linux 平均负载的谜团</a>
<a href=/posts/2022/10/13/ class=post-nav-item rel=next title=【译】一种面向多核架构的无锁、缓存高效的共享环形缓冲区>【译】一种面向多核架构的无锁、缓存高效的共享环形缓冲区<i class="fa-solid fa-angle-right fa-fw" aria-hidden=true></i></a></div></div><div class=post-reward><div class=comment></div><input type=checkbox class=reward-input name=reward id=fi-reward hidden>
<label class=reward-button for=fi-reward>赞赏</label><div class=reward-ways data-mode=static><div><img loading=lazy src=/alipay.jpg srcset="/alipay.jpg, /alipay.jpg 1.5x, /alipay.jpg 2x" sizes=auto data-title="孔俊 支付宝" data-alt="孔俊 支付宝" style="background:url(/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'><span>支付宝</span></div><div><img loading=lazy src=/wechatpay.png srcset="/wechatpay.png, /wechatpay.png 1.5x, /wechatpay.png 2x" sizes=auto data-title="孔俊 微信" data-alt="孔俊 微信" style="background:url(/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'><span>微信</span></div></div></div><div id=comments><div id=giscus><script src=https://giscus.app/client.js data-repo=kongjun18/kongjun18.github.io data-repo-id=R_kgDOICeqmQ data-category=Announcements data-category-id=DIC_kwDOICeqmc4CVeTb data-mapping=pathname data-strict=0 data-theme=preferred_color_scheme data-reactions-enabled=1 data-emit-metadata=0 data-input-position=top data-lang=zh-CN data-loading=lazy crossorigin=anonymous async defer></script></div><noscript>Please enable JavaScript to view the comments powered by <a href=https://giscus.app/ rel="external nofollow noopener noreferrer">giscus</a>.</noscript></div></article></main><footer class=footer><div class=footer-container><div class="footer-line powered">由 <a href=https://gohugo.io/ target=_blank rel="external nofollow noopener noreferrer" title="Hugo 0.110.0">Hugo</a> 强力驱动 | 主题 - <a href=https://github.com/hugo-fixit/FixIt target=_blank rel=external title="FixIt v0.2.18"><img class=fixit-icon src=/fixit.min.svg alt="FixIt logo">&nbsp;FixIt</a></div><div class="footer-line copyright" itemscope itemtype=http://schema.org/CreativeWork><i class="fa-regular fa-copyright fa-fw" aria-hidden=true></i>
<span itemprop=copyrightYear>2022 - 2023</span><span class=author itemprop=copyrightHolder>
<a href=/></a></span><span class="license footer-divider"><a rel="license external nofollow noopener noreferrer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span></div><div class="footer-line statistics"></div></div></footer></div><div class=widgets><div class="fixed-buttons animate__faster d-none"><div class="fixed-button back-to-top" role=button aria-label=回到顶部><i class="fa-solid fa-arrow-up fa-fw" aria-hidden=true></i><span class="variant-numeric d-none">0%</span></div><div class="fixed-button view-comments d-none" role=button aria-label=查看评论><i class="fa-solid fa-comment fa-fw" aria-hidden=true></i></div></div><a href=https://github.com/kongjun18/blog title=查看博客源代码 target=_blank rel="external nofollow" class="github-corner left d-none-mobile"><svg viewBox="0 0 250 250" aria-hidden="true"><path d="M0 0 115 115h15l12 27L250 250V0z"/><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentcolor" style="transform-origin:130px 106px" class="octo-arm"/><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4l13.9-13.8C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8z" fill="currentcolor" class="octo-body"/></svg></a><div id=mask></div><noscript><div class=noscript-warning>FixIt 主题在启用 JavaScript 的情况下效果最佳。</div></noscript></div><link rel=stylesheet href=/lib/cookieconsent/cookieconsent.min.css><script src=/lib/sharer/sharer.min.js async defer></script><script src=/lib/cookieconsent/cookieconsent.min.js defer></script><script src=/lib/pangu/pangu.min.js defer></script><script>window.config={autoBookmark:!0,code:{copyTitle:"复制到剪贴板",editLockTitle:"锁定可编辑代码块",editUnLockTitle:"解锁可编辑代码块",editable:!0,maxShownLines:40},comment:{enable:!0,expired:!1,giscus:{darkTheme:"dark_dimmed",lightTheme:"light"}},cookieconsent:{content:{dismiss:"同意",link:"了解更多",message:"本网站使用 Cookies 来改善您的浏览体验。"},enable:!0,palette:{button:{background:"#f0f0f0"},popup:{background:"#1aa3ff"}},theme:"edgeless"},pangu:{enable:!0,selector:"article"}}</script><script src=/js/theme.min.js defer></script></body></html>