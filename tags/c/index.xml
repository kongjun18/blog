<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>C - 标签 - 孔俊的知识库</title><link>/tags/c/</link><description>C - 标签 - 孔俊的知识库</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Mon, 12 Dec 2022 21:01:48 +0800</lastBuildDate><atom:link href="/tags/c/" rel="self" type="application/rss+xml"/><item><title>致敬经典：K&amp;R allocator 内存分配器</title><link>/posts/2022/12/12/</link><pubDate>Mon, 12 Dec 2022 21:01:48 +0800</pubDate><author>作者</author><guid>/posts/2022/12/12/</guid><description><![CDATA[k&amp;R allocator 是Brain Kernighan和 Dennis Ritchie 的名著 The C Programming Language 第 8.7 节中介绍的一个简单 malloc 实现。因为该书被称为 K&amp;R C，这个 malloc 实现也被称为 K&amp;C allocator。 K&amp;R allocator 的实现非常简洁，Linux 内核基于 K&amp;R allocator 实现了用于嵌入式系统 slob allocator。见 slob: introduce the SLOB allocator，邮件摘要如下： SLOB is a traditional K&amp;R/UNIX allocator with a SLAB emulation layer, similar to the original Linux kmalloc allocator that SLAB replaced. It&#39;s signicantly smaller code and is more memory efficient. But like all similar allocators, it scales poorly and suffers from fragmentation more than]]></description></item><item><title>C/C++ 的严格别名规则</title><link>/posts/2020/01/24/</link><pubDate>Fri, 24 Jan 2020 20:21:59 +0800</pubDate><author>作者</author><guid>/posts/2020/01/24/</guid><description>C/C++ 中的变量占有一块内存，这时这个变量就是这块内存的别名，指针也可以指向内存，因此同一块内存可能会有多个别名。 int main() { int i = 0; int *ip = &amp;amp;i; } 其中i和ip是同一块内存，都是它的别名。 内存别名的存在会影响编译器生成的代码的行为。 考虑以下代码块（来自 CSAPP 5.1 节）： void twiddle1(long *xp, long *yp) { *xp += *yp; *xp += yp; } void tiwddle2(long *xp, long *yp) { *xp *= 2 * *yp; } 这两个函数的功能看起来是相同的，但其实不然。加入，xp和yp指向</description></item><item><title>GNU C 内联汇编</title><link>/posts/2020/01/24/</link><pubDate>Fri, 24 Jan 2020 16:19:13 +0800</pubDate><author>作者</author><guid>/posts/2020/01/24/</guid><description>GNU C 允许在 C 代码中嵌入汇编代码，这种特性被称为内联汇编。使用内联汇编可以同时发挥 C 和汇编的强大能力。 本文介绍 GCC 的内联汇编拓展，Clang 编译器兼容大部分 GCC 语言拓展，因此 GNU C 的内联汇编特性大部分在 Clang 中工作正常。 本文实验环境如下： Linux Friday 5.8.17-300.fc33.x86_64 #1 SMP Thu Oct 29 15:55:40 UTC 2020 x86_64 x86_64 x86_64 GNU/Linux gcc (GCC) 10.2.1 20201016 (Red Hat 10.2.1-6) 使用 64 位 AT&amp;amp;T 风格 x86 汇编，为了和编译器自动生成的注释区分开，我添加的注释使用##风格。 基本内联</description></item></channel></rss>